<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è‚‰é¸½ç‰›ç‰› - v0.8.1 å…¨å±é€‚é…+å†²åˆº</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        html, body { 
            width: 100%; 
            height: 100%; 
            background: #0a0a14; 
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameCanvas { 
            display: block; 
            background: #0d0d1a;
            max-width: 100%;
            max-height: 100%;
        }
        #loading { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: #0a0a14; display: flex; flex-direction: column; 
            justify-content: center; align-items: center; z-index: 1000;
            transition: opacity 0.5s;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        .cow { font-size: 100px; animation: bounce 0.6s infinite alternate; }
        @keyframes bounce { from { transform: translateY(0) scale(1); } to { transform: translateY(-30px) scale(1.1); } }
        .loading-text { color: #4488ff; margin-top: 30px; font-size: 24px; font-family: Arial; }
        .loading-bar { width: 300px; height: 10px; background: #333; border-radius: 5px; margin-top: 20px; overflow: hidden; }
        .loading-progress { width: 0%; height: 100%; background: #4488ff; transition: width 0.3s; }
        .controls-hint { 
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #666; font-family: Arial; font-size: 14px; text-align: center;
            background: rgba(0,0,0,0.8); padding: 10px 20px; border-radius: 20px;
            z-index: 100;
        }
        .key { background: #333; color: #fff; padding: 2px 8px; border-radius: 4px; margin: 0 2px; }
    </style>
</head>
<body>
    <div id="loading">
        <div class="cow">ğŸ®</div>
        <div class="loading-text" id="loadingText">æ­£åœ¨åŠ è½½ç²¾çµå›¾èµ„æº...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>
    
    <div id="story" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#0a0a14; z-index:999; color:#fff; font-family:Arial; overflow-y:auto;">
        <div style="max-width:800px; margin:50px auto; padding:20px; line-height:1.8;">
            <h1 style="color:#4f4; text-align:center; margin-bottom:30px;">ğŸŒ¾ æ·±æ ¹ä¹‹ç–«</h1>
            <div id="storyContent" style="font-size:18px; color:#ccc;">
                <p style="margin-bottom:20px;">åœ¨<strong style="color:#fa0;">é’ç©—å¤§è‰åŸ</strong>çš„è…¹åœ°ï¼Œæµä¼ ç€ä¸€ä¸ªå¤è€çš„é¢„è¨€ï¼š</p>
                <p style="margin:20px 0; padding:20px; background:rgba(255,255,255,0.05); border-left:4px solid #fa0; font-style:italic;">"å½“å¤§åœ°å¼€å§‹æ¸´é¥®é²œè¡€ï¼Œæ ¹é¡»å°†åå™¬å¤©ç©ºã€‚å”¯æœ‰çŠ„è§’åˆºç ´é»‘æš—è€…ï¼Œæ–¹èƒ½å”¤é†’æ²‰ç¡çš„å¤ªé˜³ã€‚"</p>
                <p style="margin-bottom:20px;">ç‰›ç‰›å‡ºç”Ÿåœ¨<strong style="color:#48f;">è§’æ—éƒ¨è½</strong>ï¼Œä¸–ä»£å®ˆæŠ¤ç€è‰åŸçš„<strong style="color:#4f4;">çµè„‰èŠ‚ç‚¹</strong>â€”â€”åƒæ ¹åœ£æ‰€ã€‚</p>
                <p style="margin-bottom:20px;">ä½†åœ¨ä»–å¤–å‡ºä¿®è¡Œå½’æ¥æ—¶ï¼Œè‰åŸå·²å˜æˆä¸€ç‰‡æ­»å¯‚ã€‚éƒ¨è½ç©ºæ— ä¸€äººï¼Œåªæœ‰ä¸€ä¸ªé€šå¾€åœ°åº•çš„æ´ç©´ï¼Œæ•£å‘ç€è…çƒ‚çš„ç”œé¦™...</p>
                <p style="margin-bottom:20px;">ä»–å¬è§äº†åœ°åº•æ·±å¤„çš„å¿ƒè·³å£°ï¼Œè¿˜æœ‰æ¯äº²ç†Ÿæ‚‰çš„å“¼å”±ã€‚</p>
                <p style="margin-bottom:20px; color:#f44;">"ç­‰æˆ‘ï¼Œé˜¿å¦ˆã€‚"</p>
            </div>
            <div style="text-align:center; margin-top:40px;">
                <button id="startGameBtn" style="padding:15px 40px; font-size:20px; background:#4f4; color:#000; border:none; border-radius:8px; cursor:pointer;">è¸å…¥æ´ç©´</button>
            </div>
        </div>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="600"></canvas>
    </div>
    
    <div class="controls-hint">
        <span class="key">WASD</span>ç§»åŠ¨ 
        <span class="key">ç©ºæ ¼</span>å†²åˆº 
        <span class="key">1-9</span>é“å…· 
        <span class="key">E</span>äº¤äº’/å•†åº— 
        <span class="key">V</span>æ­¦å™¨è¿›åŒ– 
        <span class="key">F</span>å…¨å±
    </div>

<script>
// ============================================================================
// è‚‰é¸½ç‰›ç‰› v0.8.0 å®Œæ•´ç‰ˆ - æ­¦å™¨è¿›åŒ–ç³»ç»Ÿ
// ============================================================================

const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
const dist = (x1, y1, x2, y2) => Math.sqrt((x2-x1)**2 + (y2-y1)**2);
const rand = (min, max) => Math.random() * (max - min) + min;
const randInt = (min, max) => Math.floor(rand(min, max));
const randChoice = (arr) => arr[Math.floor(Math.random() * arr.length)];

// ç²¾çµå›¾åŠ è½½å™¨
class SpriteLoader {
    constructor() {
        this.sprites = {};
        this.loaded = 0;
        this.total = 0;
        this.errors = [];
    }
    
    load(name, src) {
        this.total++;
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                this.sprites[name] = img;
                this.loaded++;
                console.log(`âœ“ Loaded: ${name}`);
                resolve(img);
            };
            
            img.onerror = () => {
                console.warn(`âœ— Failed to load: ${src}`);
                this.errors.push({ name, src });
                this.loaded++;
                resolve(null);
            };
            
            setTimeout(() => {
                if (!img.complete) {
                    console.warn(`â± Timeout: ${src}`);
                    this.errors.push({ name, src, timeout: true });
                    resolve(null);
                }
            }, 5000);
            
            img.src = src;
        });
    }
    
    get(name) { return this.sprites[name]; }
    has(name) { return name in this.sprites; }
    isReady() { return this.loaded >= this.total; }
    getProgress() { return this.total > 0 ? this.loaded / this.total : 1; }
    getErrorCount() { return this.errors.length; }
}

// ç²’å­ç³»ç»Ÿ
class ParticleSystem {
    constructor(max = 200) {
        this.pool = Array(max).fill(null).map(() => ({
            x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 1,
            color: '#fff', size: 4, active: false
        }));
        this.active = [];
    }

    emit(x, y, color, opts = {}) {
        const p = this.pool.find(p => !p.active) || this.pool[0];
        p.x = x; p.y = y; p.color = color; p.active = true;
        p.life = opts.life || 1; p.maxLife = p.life;
        p.size = opts.size || 4;
        const speed = opts.speed || 100;
        const angle = opts.angle != null ? opts.angle : Math.random() * Math.PI * 2;
        p.vx = Math.cos(angle) * speed;
        p.vy = Math.sin(angle) * speed;
        if (!this.active.includes(p)) this.active.push(p);
    }

    burst(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
            this.emit(x, y, color, { 
                speed: rand(50, 150), 
                life: rand(0.3, 0.8),
                size: rand(2, 5)
            });
        }
    }

    update(dt) {
        for (let i = this.active.length - 1; i >= 0; i--) {
            const p = this.active[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt;
            if (p.life <= 0) {
                p.active = false;
                this.active.splice(i, 1);
            }
        }
    }

    draw(ctx) {
        for (const p of this.active) {
            const alpha = p.life / p.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
        }
        ctx.globalAlpha = 1;
    }
}

// éŸ³æ•ˆç³»ç»Ÿ
class SoundManager {
    constructor() {
        this.ctx = null;
        this.enabled = true;
    }
    
    init() {
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn('Web Audio API not supported');
            this.enabled = false;
        }
    }
    
    play(type) {
        if (!this.enabled || !this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        switch(type) {
            case 'shoot':
                osc.frequency.value = 800;
                gain.gain.value = 0.1;
                osc.start();
                osc.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.stop(this.ctx.currentTime + 0.1);
                break;
            case 'hit':
                osc.frequency.value = 200;
                osc.type = 'square';
                gain.gain.value = 0.15;
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.stop(this.ctx.currentTime + 0.15);
                break;
            case 'kill':
                osc.frequency.value = 600;
                gain.gain.value = 0.2;
                osc.start();
                osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                osc.frequency.setValueAtTime(800, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.stop(this.ctx.currentTime + 0.3);
                break;
            case 'levelup':
                osc.frequency.value = 400;
                gain.gain.value = 0.25;
                osc.start();
                for (let i = 0; i < 5; i++) {
                    osc.frequency.setValueAtTime(400 + i * 100, this.ctx.currentTime + i * 0.05);
                }
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.stop(this.ctx.currentTime + 0.5);
                break;
            case 'evolve':
                osc.frequency.value = 300;
                gain.gain.value = 0.3;
                osc.start();
                for (let i = 0; i < 8; i++) {
                    osc.frequency.setValueAtTime(300 + i * 100, this.ctx.currentTime + i * 0.05);
                }
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.8);
                osc.stop(this.ctx.currentTime + 0.8);
                break;
            case 'buy':
                osc.frequency.value = 500;
                gain.gain.value = 0.2;
                osc.start();
                osc.frequency.setValueAtTime(500, this.ctx.currentTime);
                osc.frequency.setValueAtTime(700, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.stop(this.ctx.currentTime + 0.3);
                break;
        }
    }
}

// ææ–™ç³»ç»Ÿ
const MATERIALS = {
    fire: { name: 'ç«ç„°ç²¾å', icon: 'ğŸ”¥', color: '#f44' },
    ice: { name: 'å†°éœœç»“æ™¶', icon: 'â„ï¸', color: '#48f' },
    thunder: { name: 'é›·ç”µæ ¸å¿ƒ', icon: 'âš¡', color: '#fc0' },
    shadow: { name: 'æš—å½±ç¢ç‰‡', icon: 'ğŸŒ‘', color: '#848' },
    life: { name: 'ç”Ÿå‘½ç²¾å', icon: 'ğŸŒ¿', color: '#4f4' },
    steel: { name: 'é’¢é“ç¢ç‰‡', icon: 'ğŸ”©', color: '#888' },
    magic: { name: 'é­”æ³•ç²‰å°˜', icon: 'âœ¨', color: '#f8f' },
    ancient: { name: 'è¿œå¤é—ç‰©', icon: 'ğŸº', color: '#fa0' }
};

class MaterialManager {
    constructor() {
        this.materials = {};
        for (const key in MATERIALS) {
            this.materials[key] = 0;
        }
    }
    
    add(type, amount = 1) {
        if (this.materials[type] !== undefined) {
            this.materials[type] += amount;
            return true;
        }
        return false;
    }
    
    has(type, amount = 1) {
        return (this.materials[type] || 0) >= amount;
    }
    
    consume(type, amount = 1) {
        if (this.has(type, amount)) {
            this.materials[type] -= amount;
            return true;
        }
        return false;
    }
    
    getCount(type) {
        return this.materials[type] || 0;
    }
    
    getAll() {
        return Object.entries(this.materials)
            .filter(([_, count]) => count > 0)
            .map(([type, count]) => ({ ...MATERIALS[type], type, count }));
    }
}

// æ­¦å™¨è¿›åŒ–é…ç½®
const WEAPON_EVOLUTIONS = {
    whip: {
        fire: { 
            name: 'ç«ç„°é­', icon: 'ğŸ”¥', 
            req: { fire: 3 }, 
            bonus: { fireDmg: 5, color: '#f44' },
            desc: 'é™„åŠ ç«ç„°ä¼¤å®³'
        },
        thunder: { 
            name: 'é›·ç”µé­', icon: 'âš¡', 
            req: { thunder: 3 }, 
            bonus: { thunderDmg: 5, stunChance: 0.1, color: '#fc0' },
            desc: 'é›·ç”µä¼¤å®³+éº»ç—¹'
        },
        thorn: { 
            name: 'è†æ£˜é­', icon: 'ğŸŒ¿', 
            req: { life: 3 }, 
            bonus: { lifeSteal: 0.08, color: '#4f4' },
            desc: 'å¸è¡€æ•ˆæœ'
        }
    },
    wand: {
        ice: { 
            name: 'å†°éœœé­”æ–', icon: 'â„ï¸', 
            req: { ice: 3 }, 
            bonus: { slowChance: 0.2, slowAmount: 0.3, color: '#48f' },
            desc: 'å‡é€Ÿæ•ˆæœ'
        },
        arcane: { 
            name: 'å¥¥æ•°é­”æ–', icon: 'âœ¨', 
            req: { magic: 3 }, 
            bonus: { pierce: 2, color: '#f8f' },
            desc: 'ç©¿é€+2'
        },
        life: { 
            name: 'ç”Ÿå‘½é­”æ–', icon: 'ğŸ’š', 
            req: { life: 3 }, 
            bonus: { healOnHit: 1, color: '#4f4' },
            desc: 'æ”»å‡»å›è¡€'
        }
    },
    knife: {
        poison: { 
            name: 'æ¯’åˆƒ', icon: 'â˜ ï¸', 
            req: { shadow: 2, life: 1 }, 
            bonus: { poisonDmg: 3, poisonDuration: 3, color: '#4a4' },
            desc: 'ä¸­æ¯’æ•ˆæœ'
        },
        shadow: { 
            name: 'æš—å½±é£åˆ€', icon: 'ğŸŒ‘', 
            req: { shadow: 3 }, 
            bonus: { critChance: 0.15, color: '#848' },
            desc: 'æš´å‡»ç‡æå‡'
        },
        steel: { 
            name: 'ç²¾é’¢é£åˆ€', icon: 'ğŸ”ª', 
            req: { steel: 3 }, 
            bonus: { dmg: 1.3, pierce: 1, color: '#ccc' },
            desc: 'ä¼¤å®³+ç©¿é€'
        }
    },
    axe: {
        war: { 
            name: 'æˆ˜æ–§', icon: 'ğŸª“', 
            req: { steel: 3 }, 
            bonus: { dmg: 1.4, color: '#a52' },
            desc: 'ä¼¤å®³æå‡'
        },
        throwing: { 
            name: 'æŠ•æ·æ–§', icon: 'ğŸ¯', 
            req: { steel: 2, magic: 1 }, 
            bonus: { range: 1.5, speed: 1.2, color: '#8b4513' },
            desc: 'å°„ç¨‹+é€Ÿåº¦'
        },
        curse: { 
            name: 'è¯…å’’æ–§', icon: 'ğŸ’€', 
            req: { shadow: 2, ancient: 1 }, 
            bonus: { curseDmg: 5, color: '#404' },
            desc: 'è¯…å’’ä¼¤å®³'
        }
    },
    // æ–°å¢æ­¦å™¨è¿›åŒ–ï¼ˆç¬¬2æ¬¡è¿­ä»£ï¼‰
    bible: {
        eternal: { 
            name: 'ä¸æ´æ™šç¥·', icon: 'ğŸ“œ', 
            req: { magic: 2, life: 1 }, 
            bonus: { duration: 2, color: '#ffd700' },
            desc: 'ç¯ç»•æ—¶é—´å»¶é•¿'
        },
        shield: { 
            name: 'å®ˆæŠ¤åœ£ç»', icon: 'ğŸ›¡ï¸', 
            req: { steel: 2, life: 1 }, 
            bonus: { block: 1, color: '#c0c0c0' },
            desc: 'å¯æ ¼æŒ¡å­å¼¹'
        }
    },
    fireball: {
        inferno: { 
            name: 'åœ°ç‹±ç«', icon: 'ğŸŒ‹', 
            req: { fire: 3 }, 
            bonus: { explosion: 1.5, color: '#ff0000' },
            desc: 'çˆ†ç‚¸èŒƒå›´+50%'
        },
        meteor: { 
            name: 'é™¨çŸ³æœ¯', icon: 'â˜„ï¸', 
            req: { fire: 2, ancient: 1 }, 
            bonus: { dmg: 1.5, cd: 1.3, color: '#ff4500' },
            desc: 'ä¼¤å®³+50% å†·å´+30%'
        }
    },
    lightning: {
        chain: { 
            name: 'é›·éœ†å¾ªç¯', icon: 'â›“ï¸', 
            req: { thunder: 3 }, 
            bonus: { chain: 3, color: '#ffff00' },
            desc: 'è¿é”+3ç›®æ ‡'
        },
        storm: { 
            name: 'é›·æš´', icon: 'ğŸŒ©ï¸', 
            req: { thunder: 2, wind: 1 }, 
            bonus: { aoe: 1, color: '#9400d3' },
            desc: 'èŒƒå›´ä¼¤å®³'
        }
    },
    holy_water: {
        tracking: { 
            name: 'æ’’æ‹‰é€Šä¹‹æ°´', icon: 'ğŸ¯', 
            req: { magic: 2, water: 1 }, 
            bonus: { homing: 0.5, color: '#00ffff' },
            desc: 'è¿½è¸ªæ•Œäºº'
        },
        healing: { 
            name: 'åœ£ç–—ä¹‹æ°´', icon: 'ğŸ’š', 
            req: { life: 3 }, 
            bonus: { heal: 2, color: '#00ff00' },
            desc: 'ç«™åœ¨åŒºåŸŸå†…å›è¡€'
        }
    }
};

// é“å…·æ•°æ®åº“
const ITEMS = {
    1: { id: 1, name: 'å¤šé‡å°„å‡»', icon: 'ğŸ¯', rarity: 'common', effect: 'projCount', value: 1, desc: 'å­å¼¹+1', price: 40 },
    2: { id: 2, name: 'å·¨å¤§åŒ–', icon: 'ğŸ“', rarity: 'common', effect: 'projSize', value: 0.3, desc: 'å­å¼¹å˜å¤§', price: 35 },
    3: { id: 3, name: 'å¿«é€Ÿå°„å‡»', icon: 'âš¡', rarity: 'common', effect: 'fireRate', value: 0.15, desc: 'å°„é€Ÿ+15%', price: 45 },
    4: { id: 4, name: 'ç©¿ç”²å¼¹', icon: 'ğŸ”©', rarity: 'rare', effect: 'pierce', value: 1, desc: 'ç©¿é€+1', price: 80 },
    5: { id: 5, name: 'æš´å‡»é•œç‰‡', icon: 'ğŸ”', rarity: 'rare', effect: 'crit', value: 0.1, desc: 'æš´å‡»+10%', price: 75 },
    6: { id: 6, name: 'å¿ƒä¹‹å®¹å™¨', icon: 'â¤ï¸', rarity: 'common', effect: 'maxHp', value: 2, desc: 'ç”Ÿå‘½+2', price: 50 },
    7: { id: 7, name: 'é’¢é“æŠ¤ç”²', icon: 'ğŸ›¡ï¸', rarity: 'rare', effect: 'armor', value: 1, desc: 'æŠ¤ç”²+1', price: 85 },
    8: { id: 8, name: 'å¸è¡€ç ç‰™', icon: 'ğŸ¦·', rarity: 'rare', effect: 'lifeSteal', value: 0.05, desc: 'å¸è¡€5%', price: 90 },
    9: { id: 9, name: 'åŠ é€Ÿé´', icon: 'ğŸ‘Ÿ', rarity: 'common', effect: 'speed', value: 0.2, desc: 'ç§»é€Ÿ+20%', price: 40 },
    10: { id: 10, name: 'é£è¡Œç¿…è†€', icon: 'ğŸ¦…', rarity: 'epic', effect: 'fly', value: 1, desc: 'å¯ä»¥é£è¡Œ', price: 150 },
    11: { id: 11, name: 'ç£é“', icon: 'ğŸ§²', rarity: 'rare', effect: 'magnet', value: 50, desc: 'å¸èŒƒå›´+50', price: 70 },
    12: { id: 12, name: 'é‡‘è›‹', icon: 'ğŸ¥š', rarity: 'epic', effect: 'goldBonus', value: 0.5, desc: 'é‡‘å¸+50%', price: 120 },
    13: { id: 13, name: 'ç«ç„°é™„é­”', icon: 'ğŸ”¥', rarity: 'rare', effect: 'fireDmg', value: 5, desc: 'ç«ç„°ä¼¤å®³+5', price: 85 },
    14: { id: 14, name: 'å†°å†»æ ¸å¿ƒ', icon: 'â„ï¸', rarity: 'rare', effect: 'slow', value: 0.2, desc: 'å‡é€Ÿæ•Œäºº20%', price: 80 },
    15: { id: 15, name: 'é›·ç”µå®ç ', icon: 'âš¡', rarity: 'epic', effect: 'chain', value: 1, desc: 'è¿é”æ”»å‡»+1', price: 140 },
    // v0.8.0 æœ€ç»ˆæ•´åˆ
    16: { id: 16, name: 'ç‹‚æš´ä¹‹è¡€', icon: 'ğŸ©¸', rarity: 'rare', effect: 'crit', value: 0.1, desc: 'æš´å‡»ç‡+10%', price: 80 },
    17: { id: 17, name: 'çˆ†ç‚¸å¼¹', icon: 'ğŸ’£', rarity: 'rare', effect: 'fireDmg', value: 5, desc: 'çˆ†ç‚¸ä¼¤å®³+5', price: 90 },
    18: { id: 18, name: 'å†°å†»å¼¹', icon: 'ğŸ§Š', rarity: 'rare', effect: 'slow', value: 0.2, desc: 'å‡é€Ÿæ•ˆæœ+20%', price: 85 },
    19: { id: 19, name: 'æŠ¤ç›¾å‘ç”Ÿå™¨', icon: 'ğŸ›¡ï¸', rarity: 'rare', effect: 'armor', value: 2, desc: 'æŠ¤ç”²+2', price: 100 },
    20: { id: 20, name: 'å¤æ´»å¸', icon: 'ğŸª™', rarity: 'legendary', effect: 'maxHp', value: 2, desc: 'ç”Ÿå‘½ä¸Šé™+2', price: 300 },
    21: { id: 21, name: 'ç»éªŒä¹¦', icon: 'ğŸ“š', rarity: 'common', effect: 'speed', value: 0.1, desc: 'ç§»é€Ÿ+10%', price: 40 },
    22: { id: 22, name: 'é‡‘ç£é“', icon: 'ğŸ§²', rarity: 'rare', effect: 'magnet', value: 80, desc: 'æ‹¾å–èŒƒå›´+80', price: 75 },
    23: { id: 23, name: 'ç–¾é£é´', icon: 'ğŸ‘¢', rarity: 'epic', effect: 'speed', value: 0.3, desc: 'ç§»é€Ÿ+30%', price: 140 },
    24: { id: 24, name: 'å¤©ä½¿ç¥ç¦', icon: 'ğŸ‘¼', rarity: 'legendary', effect: 'maxHp', value: 3, desc: 'ç”Ÿå‘½+3', price: 350 },
    25: { id: 25, name: 'é»‘æ´æ ¸å¿ƒ', icon: 'ğŸ•³ï¸', rarity: 'legendary', effect: 'magnet', value: 200, desc: 'æ‹¾å–èŒƒå›´+200', price: 400 },
    26: { id: 26, name: 'é›·ç”µä¹‹åˆƒ', icon: 'âš¡', rarity: 'epic', effect: 'chain', value: 1, desc: 'è¿é”æ”»å‡»+1', price: 140 },
    // ç¬¬1æ¬¡è¿­ä»£ï¼šæ–°å¢24ä¸ªé“å…· (27-50)
    // æ”»å‡»ç±»æ‰©å±•
    27: { id: 27, name: 'éœ°å¼¹æ‰©æ•£', icon: 'ğŸ“¦', rarity: 'common', effect: 'spread', value: 15, desc: 'æ•£å°„è§’åº¦+15Â°', price: 35 },
    28: { id: 28, name: 'è¿½è¸ªèŠ¯ç‰‡', icon: 'ğŸ§¿', rarity: 'rare', effect: 'homing', value: 0.3, desc: 'è¿½è¸ªå¼ºåº¦+30%', price: 95 },
    29: { id: 29, name: 'å¼¹è·³å­å¼¹', icon: 'ğŸ±', rarity: 'rare', effect: 'bounce', value: 1, desc: 'å¼¹è·³+1æ¬¡', price: 85 },
    30: { id: 30, name: 'æ¯’æ¶²æ¶‚å±‚çš„', icon: 'ğŸ§ª', rarity: 'rare', effect: 'poisonDmg', value: 3, desc: 'æ¯’ä¼¤å®³+3/ç§’', price: 80 },
    31: { id: 31, name: 'ç‹™å‡»é•œ', icon: 'ğŸ”­', rarity: 'epic', effect: 'critDmg', value: 0.5, desc: 'æš´å‡»ä¼¤å®³+50%', price: 130 },
    32: { id: 32, name: 'è¿å‘è£…ç½®', icon: 'ğŸ”«', rarity: 'epic', effect: 'burst', value: 1, desc: 'è¿å°„+1å‘', price: 150 },
    // é˜²å¾¡ç±»æ‰©å±•
    33: { id: 33, name: 'å†ç”Ÿå› å­', icon: 'ğŸ§¬', rarity: 'rare', effect: 'regen', value: 0.5, desc: 'æ¯ç§’å›å¤0.5HP', price: 100 },
    34: { id: 34, name: 'è†æ£˜æŠ¤ç”²', icon: 'ğŸŒµ', rarity: 'rare', effect: 'thorn', value: 2, desc: 'åå¼¹2ç‚¹ä¼¤å®³', price: 90 },
    35: { id: 35, name: 'é—ªé¿é´', icon: 'ğŸ‘»', rarity: 'epic', effect: 'dodge', value: 0.1, desc: 'é—ªé¿+10%', price: 130 },
    36: { id: 36, name: 'ç¥åœ£æŠ¤ç›¾', icon: 'âœ¨', rarity: 'legendary', effect: 'shield', value: 1, desc: 'å…ä¼¤ç›¾+1å±‚', price: 300 },
    37: { id: 37, name: 'ä¸æœ½ä¹‹å¿ƒ', icon: 'ğŸ’', rarity: 'legendary', effect: 'revive', value: 1, desc: 'æ­»äº¡æ—¶å¤æ´»ä¸€æ¬¡', price: 500 },
    // ç§»åŠ¨ç±»æ‰©å±•
    38: { id: 38, name: 'ç¬ç§»è£…ç½®', icon: 'ğŸŒ€', rarity: 'epic', effect: 'dashDist', value: 0.5, desc: 'å†²åˆºè·ç¦»+50%', price: 120 },
    39: { id: 39, name: 'æ—¶é—´æ€€è¡¨', icon: 'â±ï¸', rarity: 'legendary', effect: 'slowTime', value: 0.2, desc: 'å­å¼¹æ—¶é—´20%', price: 400 },
    // èµ„æºç±»æ‰©å±•
    40: { id: 40, name: 'å¹¸è¿å¸', icon: 'ğŸ€', rarity: 'rare', effect: 'luck', value: 0.2, desc: 'å¹¸è¿+20%', price: 110 },
    41: { id: 41, name: 'è´ªå©ªä¹‹æ‰‹', icon: 'ğŸ¤²', rarity: 'rare', effect: 'goldOnKill', value: 2, desc: 'å‡»æ€é‡‘å¸+2', price: 95 },
    42: { id: 42, name: 'ç»éªŒåŠ æˆ', icon: 'ğŸ“ˆ', rarity: 'common', effect: 'expBonus', value: 0.2, desc: 'ç»éªŒ+20%', price: 45 },
    43: { id: 43, name: 'é‡‡é›†å™¨', icon: 'ğŸ“¡', rarity: 'epic', effect: 'pickupRange', value: 50, desc: 'æ‹¾å–èŒƒå›´+50', price: 125 },
    // å¬å”¤ç±»
    44: { id: 44, name: 'å°ç²¾çµ', icon: 'ğŸ§š', rarity: 'rare', effect: 'fairy', value: 1, desc: 'å°ç²¾çµè·Ÿéšå°„å‡»', price: 140 },
    45: { id: 45, name: 'å®ˆæŠ¤çƒ', icon: 'ğŸ”®', rarity: 'epic', effect: 'orbit', value: 1, desc: 'ç¯ç»•æ”»å‡»çƒ+1', price: 160 },
    46: { id: 46, name: 'å® ç‰©é¾™', icon: 'ğŸ‰', rarity: 'legendary', effect: 'dragon', value: 1, desc: 'å–·ç«å¹¼é¾™è·Ÿéš', price: 450 },
    // è¯…å’’ç±»ï¼ˆé«˜é£é™©é«˜å›æŠ¥ï¼‰
    47: { id: 47, name: 'ç‹‚æš´æ¨¡å¼', icon: 'ğŸ˜ˆ', rarity: 'cursed', effect: 'glassCannon', value: 1, desc: 'ä¼¤å®³+50% ç”Ÿå‘½-30%', price: 0 },
    48: { id: 48, name: 'çŒ®ç¥­ä¹‹å¿ƒ', icon: 'ğŸ’”', rarity: 'cursed', effect: 'bloodMoney', value: 1, desc: 'é‡‘å¸+100% æ¯ç§’æ‰£è¡€', price: 0 },
    // ç‰¹æ®Šé“å…·
    49: { id: 49, name: 'ç›²çœ¼èƒå–æ¶²', icon: 'ğŸ§´', rarity: 'legendary', effect: 'invincible', value: 3, desc: '3ç§’æ— æ•Œæ—¶é—´', price: 350 },
    50: { id: 50, name: 'å›¾è…¾éª¨ç‰‡', icon: 'ğŸ¦´', rarity: 'legendary', effect: 'upgradeAll', value: 1, desc: 'å…¨å±æ€§+10%', price: 600 }
};

function getItemPrice(itemId) {
    const item = ITEMS[itemId];
    if (!item) return 100;
    const basePrice = item.price || 50;
    const variance = basePrice * 0.2;
    return Math.floor(basePrice + rand(-variance, variance));
}

class ItemManager {
    constructor(player) {
        this.player = player;
        this.owned = {};
        this.cache = null;
        this.dirty = true;
    }

    add(id) {
        const item = ITEMS[id];
        if (!item) return false;
        this.owned[id] = (this.owned[id] || 0) + 1;
        this.dirty = true;
        
        if (item.effect === 'maxHp') {
            this.player.maxHp += item.value;
            this.player.hp += item.value;
        }
        return true;
    }

    getStats() {
        if (!this.dirty) return this.cache;
        
        const s = {
            // åŸºç¡€å±æ€§
            projCount: 1, projSize: 1, fireRate: 1, pierce: 0,
            crit: 0, critDmg: 1.5, maxHp: 0, armor: 0, lifeSteal: 0,
            speed: 1, fly: false, magnet: 100, goldBonus: 1,
            // ä¼¤å®³ç±»å‹
            fireDmg: 0, thunderDmg: 0, poisonDmg: 0, curseDmg: 0,
            // æ§åˆ¶æ•ˆæœ
            slowChance: 0, slowAmount: 0, stunChance: 0,
            // æ–°å±æ€§ï¼ˆç¬¬1æ¬¡è¿­ä»£ï¼‰
            spread: 0, homing: 0, bounce: 0, burst: 0,
            regen: 0, thorn: 0, dodge: 0, shield: 0, revive: 0,
            dashDist: 1, slowTime: 0, luck: 0, goldOnKill: 0, expBonus: 0,
            pickupRange: 0, fairy: 0, orbit: 0, dragon: 0,
            glassCannon: 0, bloodMoney: 0, invincible: 0, upgradeAll: 0,
            // æ²»ç–—
            healOnHit: 0
        };
        
        for (const [id, count] of Object.entries(this.owned)) {
            const item = ITEMS[id];
            if (!item) continue;
            const v = item.value * count;
            
            switch (item.effect) {
                // åŸºç¡€æ”»å‡»
                case 'projCount': s.projCount += v; break;
                case 'projSize': s.projSize += v; break;
                case 'fireRate': s.fireRate *= (1 + v); break;
                case 'pierce': s.pierce += v; break;
                case 'crit': s.crit = Math.min(1, s.crit + v); break;
                case 'critDmg': s.critDmg += v; break;
                // é˜²å¾¡
                case 'maxHp': s.maxHp += v; break;
                case 'armor': s.armor += v; break;
                case 'lifeSteal': s.lifeSteal += v; break;
                case 'regen': s.regen += v; break;
                case 'thorn': s.thorn += v; break;
                case 'dodge': s.dodge = Math.min(0.5, s.dodge + v); break;
                case 'shield': s.shield += v; break;
                case 'revive': s.revive += v; break;
                // ç§»åŠ¨
                case 'speed': s.speed += v; break;
                case 'fly': s.fly = true; break;
                case 'dashDist': s.dashDist += v; break;
                case 'slowTime': s.slowTime += v; break;
                // èµ„æº
                case 'magnet': s.magnet += v; break;
                case 'goldBonus': s.goldBonus += v; break;
                case 'luck': s.luck += v; break;
                case 'goldOnKill': s.goldOnKill += v; break;
                case 'expBonus': s.expBonus += v; break;
                case 'pickupRange': s.pickupRange += v; break;
                // ä¼¤å®³ç±»å‹
                case 'fireDmg': s.fireDmg += v; break;
                case 'thunderDmg': s.thunderDmg += v; break;
                case 'poisonDmg': s.poisonDmg += v; break;
                case 'curseDmg': s.curseDmg += v; break;
                case 'slow': s.slowAmount += v; break;
                case 'chain': s.chain = (s.chain || 0) + v; break;
                // ç‰¹æ®Šæ•ˆæœ
                case 'spread': s.spread += v; break;
                case 'homing': s.homing += v; break;
                case 'bounce': s.bounce += v; break;
                case 'burst': s.burst += v; break;
                // å¬å”¤
                case 'fairy': s.fairy += v; break;
                case 'orbit': s.orbit += v; break;
                case 'dragon': s.dragon += v; break;
                // è¯…å’’
                case 'glassCannon': s.glassCannon += v; break;
                case 'bloodMoney': s.bloodMoney += v; break;
                // ç‰¹æ®Š
                case 'invincible': s.invincible += v; break;
                case 'upgradeAll': s.upgradeAll += v; break;
            }
        }
        
        // è¯…å’’æ•ˆæœå¤„ç†
        if (s.glassCannon > 0) {
            s.fireRate *= 1.5;
            s.maxHp *= 0.7;
        }
        if (s.bloodMoney > 0) {
            s.goldBonus *= 2;
        }
        if (s.upgradeAll > 0) {
            s.speed *= 1.1;
            s.fireRate *= 1.1;
            s.crit = Math.min(1, s.crit * 1.1 + 0.1);
        }
        
        this.cache = s;
        this.dirty = false;
        return s;
    }

    has(id) { return (this.owned[id] || 0) > 0; }
    count(id) { return this.owned[id] || 0; }
}

// æ­¦å™¨ç³»ç»Ÿ - æ”¯æŒè¿›åŒ–
const WEAPONS = {
    // åŸæœ‰4ç§æ­¦å™¨
    whip: { key: 'whip', name: 'é­å­', icon: 'ğŸª„', dmg: 20, cd: 1.0, range: 100, type: 'melee', color: '#f60' },
    wand: { key: 'wand', name: 'é­”æ–', icon: 'ğŸ”®', dmg: 15, cd: 0.6, speed: 300, type: 'proj', color: '#48f' },
    knife: { key: 'knife', name: 'é£åˆ€', icon: 'ğŸ—¡ï¸', dmg: 12, cd: 0.4, speed: 400, pierce: 3, type: 'proj', color: '#ccc' },
    axe: { key: 'axe', name: 'æ–§å¤´', dmg: 25, cd: 1.2, speed: 250, type: 'proj', color: '#8b4513' },
    // æ–°å¢4ç§æ­¦å™¨ï¼ˆç¬¬2æ¬¡è¿­ä»£ï¼‰
    bible: { key: 'bible', name: 'åœ£ç»', icon: 'ğŸ“–', dmg: 10, cd: 0.8, range: 80, type: 'orbit', color: '#ffd700' },
    fireball: { key: 'fireball', name: 'ç«çƒ', icon: 'ğŸ”¥', dmg: 30, cd: 1.5, speed: 200, type: 'proj', color: '#ff4500' },
    lightning: { key: 'lightning', name: 'é—ªç”µ', icon: 'âš¡', dmg: 18, cd: 0.5, range: 150, type: 'instant', color: '#ffff00' },
    holy_water: { key: 'holy_water', name: 'åœ£æ°´', icon: 'ğŸ’§', dmg: 8, cd: 1.0, range: 60, type: 'area', color: '#00bfff' }
};

class Weapon {
    constructor(key, level = 1, evolution = null) {
        this.baseKey = key;
        this.cfg = { ...WEAPONS[key] };
        this.level = level;
        this.evolution = evolution;
        this.cd = 0;
        this.xp = 0;
        this.xpToNext = 100;
        
        // åº”ç”¨è¿›åŒ–å±æ€§
        if (evolution) {
            const evoData = WEAPON_EVOLUTIONS[key]?.[evolution];
            if (evoData) {
                this.cfg.name = evoData.name;
                this.cfg.icon = evoData.icon;
                this.cfg.color = evoData.bonus.color || this.cfg.color;
                // åº”ç”¨å±æ€§åŠ æˆ
                if (evoData.bonus.dmg) this.cfg.dmg *= evoData.bonus.dmg;
                if (evoData.bonus.range) this.cfg.range *= evoData.bonus.range;
                if (evoData.bonus.speed) this.cfg.speed *= evoData.bonus.speed;
                if (evoData.bonus.pierce) this.cfg.pierce = (this.cfg.pierce || 0) + evoData.bonus.pierce;
            }
        }
    }
    
    getDamage(stats) { 
        let dmg = this.cfg.dmg * (1 + (this.level - 1) * 0.15) * stats.projSize;
        return dmg;
    }
    
    update(dt) { this.cd -= dt; }
    canFire() { return this.cd <= 0; }
    
    addXp(amount) {
        this.xp += amount;
        if (this.xp >= this.xpToNext) {
            this.xp -= this.xpToNext;
            this.level++;
            this.xpToNext = Math.floor(this.xpToNext * 1.5);
            return true;
        }
        return false;
    }
    
    getLevelColor() {
        if (this.evolution) return '#f0f'; // è¿›åŒ–æ­¦å™¨ç´«è‰²
        if (this.level >= 5) return '#fa0';
        if (this.level >= 3) return '#0ff';
        if (this.level >= 2) return '#fff';
        return '#aaa';
    }
    
    fire(player, target, stats) {
        this.cd = this.cfg.cd / stats.fireRate;
        const bullets = [];
        const count = Math.floor(stats.projCount);
        
        for (let i = 0; i < count; i++) {
            let angle = 0;
            if (target) {
                angle = Math.atan2(target.y - player.y, target.x - player.x);
                if (count > 1) angle += (i - (count - 1) / 2) * 0.15;
            } else {
                angle = Math.random() * Math.PI * 2;
            }
            
            bullets.push({
                x: player.x, y: player.y,
                vx: Math.cos(angle) * (this.cfg.speed || 200),
                vy: Math.sin(angle) * (this.cfg.speed || 200),
                dmg: this.getDamage(stats),
                color: this.cfg.color,
                life: this.cfg.type === 'melee' ? 0.3 : 3,
                pierce: (this.cfg.pierce || 0) + stats.pierce,
                type: this.cfg.type,
                range: this.cfg.range,
                hits: new Set(),
                homing: this.cfg.type !== 'melee',
                target: target,
                weapon: this
            });
        }
        return bullets;
    }
}

// æ•Œäººé…ç½®
const ENEMY_TYPES = {
    chick: { name: 'å˜å¼‚å°é¸¡', hp: 10, speed: 80, dmg: 1, exp: 2, gold: 5, color: '#ff6', sprite: 'chick' },
    pig: { name: 'å˜å¼‚å°çŒª', hp: 20, speed: 50, dmg: 2, exp: 4, gold: 8, color: '#f9c', sprite: 'pig' },
    sheep: { name: 'å˜å¼‚å°ç¾Š', hp: 15, speed: 60, dmg: 1, exp: 3, gold: 6, color: '#eee', sprite: 'sheep' },
    dog: { name: 'ç–¯ç‹—', hp: 18, speed: 100, dmg: 2, exp: 5, gold: 7, color: '#963', sprite: 'dog' },
    cat: { name: 'å˜å¼‚çŒ«', hp: 12, speed: 90, dmg: 1, exp: 3, gold: 6, color: '#fa3', sprite: 'cat' },
    bear: { name: 'å·¨ç†Š', hp: 35, speed: 40, dmg: 3, exp: 8, gold: 15, color: '#630', sprite: 'bear' },
    
    tiaotiao: { name: 'è·³è·³', hp: 25, speed: 120, dmg: 2, exp: 6, gold: 12, color: '#c85', sprite: 'rabbit', special: 'jump' },
    tiezhua: { name: 'é“çˆª', hp: 22, speed: 150, dmg: 3, exp: 7, gold: 14, color: '#a52', sprite: 'bird', special: 'dive' },
    nibei: { name: 'æ³¥èƒŒ', hp: 50, speed: 30, dmg: 2, exp: 8, gold: 20, color: '#6a5', sprite: 'turtle', special: 'tank', armor: 2 },
    yinya: { name: 'é“¶ç‰™', hp: 30, speed: 90, dmg: 2, exp: 10, gold: 18, color: '#789', sprite: 'dog2', special: 'summon' }
};

// BOSSé…ç½®
const BOSS_TYPES = {
    mother: {
        name: 'æ¯ä½“',
        hp: 500,
        speed: 30,
        dmg: 5,
        exp: 100,
        gold: 200,
        color: '#f0f',
        sprite: 'bear',
        scale: 2,
        phases: [
            { hpPercent: 100, behavior: 'normal' },
            { hpPercent: 70, behavior: 'enrage' },
            { hpPercent: 30, behavior: 'desperate' }
        ]
    }
};

class Enemy {
    constructor(x, y, typeKey) {
        const cfg = ENEMY_TYPES[typeKey] || ENEMY_TYPES.chick;
        this.x = x; this.y = y;
        this.typeKey = typeKey;
        this.hp = cfg.hp + (cfg.armor || 0) * 10;
        this.maxHp = this.hp;
        this.speed = cfg.speed;
        this.dmg = cfg.dmg;
        this.exp = cfg.exp;
        this.gold = cfg.gold || 5;
        this.color = cfg.color;
        this.sprite = cfg.sprite;
        this.special = cfg.special;
        this.armor = cfg.armor || 0;
        this.vx = 0; this.vy = 0;
        this.hitTimer = 0;
        this.attackCd = 0;
        this.specialCd = 0;
        
        // çŠ¶æ€æ•ˆæœ
        this.slowTimer = 0;
        this.stunTimer = 0;
        this.poisonTimer = 0;
        this.poisonDmg = 0;
    }

    update(dt, player, room) {
        // çŠ¶æ€æ•ˆæœå¤„ç†
        if (this.stunTimer > 0) {
            this.stunTimer -= dt;
            return; // çœ©æ™•æ—¶æ— æ³•è¡ŒåŠ¨
        }
        
        if (this.slowTimer > 0) {
            this.slowTimer -= dt;
            dt *= 0.5; // å‡é€Ÿ50%
        }
        
        if (this.poisonTimer > 0) {
            this.poisonTimer -= dt;
            this.hp -= this.poisonDmg * dt;
        }
        
        // ç‰¹æ®Šè¡Œä¸º
        if (this.special === 'jump' && this.specialCd <= 0) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d > 0 && d < 200) {
                this.vx = (dx / d) * this.speed * 2;
                this.vy = (dy / d) * this.speed * 2;
                this.specialCd = 2;
            }
        } else if (this.special === 'dive' && this.specialCd <= 0) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d > 100 && d < 400) {
                this.vx = (dx / d) * this.speed * 3;
                this.vy = (dy / d) * this.speed * 3;
                this.specialCd = 3;
            }
        } else {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            
            if (d > 0) {
                this.vx = (dx / d) * this.speed;
                this.vy = (dy / d) * this.speed;
            }
        }
        
        if (this.special === 'tank') {
            this.vx *= 0.8;
            this.vy *= 0.8;
        }
        
        if (this.special === 'summon' && this.specialCd <= 0 && room.enemies.length < 10) {
            this.specialCd = 5;
            const angle = Math.random() * Math.PI * 2;
            const r = 30;
            room.enemies.push(new Enemy(
                this.x + Math.cos(angle) * r,
                this.y + Math.sin(angle) * r,
                'dog'
            ));
        }
        
        for (const other of room.enemies) {
            if (other === this) continue;
            const odx = this.x - other.x;
            const ody = this.y - other.y;
            const od = Math.sqrt(odx*odx + ody*ody);
            if (od < 30 && od > 0) {
                this.vx += (odx / od) * 50;
                this.vy += (ody / od) * 50;
            }
        }
        
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        this.x = clamp(this.x, 50, 850);
        this.y = clamp(this.y, 50, 550);
        
        if (this.hitTimer > 0) this.hitTimer -= dt;
        if (this.attackCd > 0) this.attackCd -= dt;
        if (this.specialCd > 0) this.specialCd -= dt;
    }

    takeDamage(dmg, stats = {}) {
        const actualDmg = Math.max(1, dmg - this.armor);
        this.hp -= actualDmg;
        this.hitTimer = 0.1;
        
        // åº”ç”¨çŠ¶æ€æ•ˆæœ
        if (stats.slowChance && Math.random() < stats.slowChance) {
            this.slowTimer = 2;
        }
        if (stats.stunChance && Math.random() < stats.stunChance) {
            this.stunTimer = 1;
        }
        
        return this.hp <= 0;
    }

    applyPoison(dmg, duration) {
        this.poisonDmg = Math.max(this.poisonDmg, dmg);
        this.poisonTimer = Math.max(this.poisonTimer, duration);
    }

    draw(ctx, sprites) {
        const size = this.isBoss ? 36 : 16;
        
        if (this.hitTimer > 0 && Math.floor(Date.now() / 50) % 2) {
            ctx.globalAlpha = 0.5;
        }
        
        // çŠ¶æ€æ•ˆæœè§†è§‰
        if (this.slowTimer > 0) {
            ctx.strokeStyle = '#48f';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size + 5, 0, Math.PI * 2);
            ctx.stroke();
        }
        if (this.poisonTimer > 0) {
            ctx.strokeStyle = '#4a4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size + 8, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        if (this.isBoss) {
            ctx.strokeStyle = `rgba(255, 0, 255, ${0.3 + Math.sin(Date.now() / 200) * 0.2})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size + 10, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        const sprite = sprites.get(this.sprite);
        if (sprite) {
            ctx.drawImage(sprite, this.x - size, this.y - size, size * 2, size * 2);
        } else {
            const emojiMap = {
                chick: 'ğŸ¤', pig: 'ğŸ·', sheep: 'ğŸ‘', dog: 'ğŸ•',
                cat: 'ğŸ±', bear: 'ğŸ»', rabbit: 'ğŸ¦˜', bird: 'ğŸ¦…',
                turtle: 'ğŸ¢', dog2: 'ğŸº'
            };
            ctx.font = this.isBoss ? '48px Arial' : '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(emojiMap[this.sprite] || 'ğŸ‘¾', this.x, this.y + 8);
        }
        
        ctx.globalAlpha = 1;
        
        if (this.hp < this.maxHp) {
            const barWidth = this.isBoss ? 100 : 24;
            ctx.fillStyle = '#000';
            ctx.fillRect(this.x - barWidth/2, this.y - size - 10, barWidth, 6);
            ctx.fillStyle = this.isBoss ? '#f0f' : '#f00';
            ctx.fillRect(this.x - barWidth/2, this.y - size - 10, barWidth * (this.hp / this.maxHp), 6);
        }
        
        if (this.isBoss) {
            ctx.fillStyle = '#f0f';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(this.name, this.x, this.y - size - 20);
        }
    }
}

// ç›²çœ¼NPCç±»
class ShopNPC {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.name = 'ç›²çœ¼';
    }
    
    draw(ctx, playerNear = false) {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(this.x - 35, this.y - 35, 70, 70);
        ctx.strokeStyle = '#4a4';
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x - 35, this.y - 35, 70, 70);
        
        ctx.font = '32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ¦¯', this.x - 8, this.y + 8);
        ctx.fillText('ğŸ‘ï¸', this.x + 8, this.y + 8);
        
        ctx.fillStyle = '#4f4';
        ctx.font = '12px Arial';
        ctx.fillText('ç›²çœ¼', this.x, this.y + 30);
        
        if (playerNear) {
            ctx.fillStyle = '#ff0';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('æŒ‰ E æ‰“å¼€å•†åº—', this.x, this.y - 45);
        }
    }
}

// å›¾è…¾ç³»ç»Ÿ
const TOTEMS = {
    1: { id: 1, name: 'å…ˆç¥–ä¹‹åŠ›', icon: 'ğŸ¦´', desc: 'æ”»å‡»åŠ›+10%', effect: 'dmg', value: 0.1 },
    2: { id: 2, name: 'åœ°è„‰å®ˆæŠ¤', icon: 'ğŸ›¡ï¸', desc: 'æœ€å¤§ç”Ÿå‘½+1', effect: 'maxHp', value: 1 },
    3: { id: 3, name: 'ç–¾é£æ­¥', icon: 'ğŸ‘Ÿ', desc: 'ç§»åŠ¨é€Ÿåº¦+10%', effect: 'speed', value: 0.1 },
    4: { id: 4, name: 'æ™ºæ…§ä¹‹çœ¼', icon: 'ğŸ‘ï¸', desc: 'ç»éªŒè·å–+20%', effect: 'exp', value: 0.2 },
    5: { id: 5, name: 'è´ªå©ªä¹‹æ‰‹', icon: 'ğŸ’°', desc: 'é‡‘å¸è·å–+25%', effect: 'gold', value: 0.25 },
    6: { id: 6, name: 'å†ç”Ÿä¹‹è¡€', icon: 'â¤ï¸', desc: 'ç”Ÿå‘½æ¢å¤+0.1/ç§’', effect: 'regen', value: 0.1 },
    7: { id: 7, name: 'å¹¸è¿æ˜Ÿ', icon: 'â­', desc: 'æš´å‡»ç‡+5%', effect: 'crit', value: 0.05 }
};

class TotemManager {
    constructor() {
        this.owned = new Set();
        this.load();
    }
    
    load() {
        try {
            const saved = localStorage.getItem('rougecow_totems');
            if (saved) this.owned = new Set(JSON.parse(saved));
        } catch (e) {}
    }
    
    save() {
        try {
            localStorage.setItem('rougecow_totems', JSON.stringify([...this.owned]));
        } catch (e) {}
    }
    
    collect(id) {
        if (this.owned.has(id)) return false;
        this.owned.add(id);
        this.save();
        return true;
    }
    
    has(id) { return this.owned.has(id); }
    getCount() { return this.owned.size; }
    
    getAllBonuses() {
        const bonuses = { dmg: 0, maxHp: 0, speed: 0, exp: 0, gold: 0, regen: 0, crit: 0 };
        for (const id of this.owned) {
            const totem = TOTEMS[id];
            if (totem) bonuses[totem.effect] += totem.value;
        }
        return bonuses;
    }
}

// æˆ¿é—´ç±»
class Room {
    constructor(gx, gy, type = 'normal', floor = 1, templateKey = null) {
        this.gx = gx; this.gy = gy;
        this.id = `${gx},${gy}`;
        this.type = type;
        this.floor = floor;
        this.doors = { up: null, down: null, left: null, right: null };
        this.enemies = [];
        this.cleared = type === 'start' || type === 'treasure' || type === 'shop';
        this.visited = false;
        this.items = [];
        this.npc = null;
        
        // å¤§æˆ¿é—´å°ºå¯¸
        this.width = SURVIVOR_CONFIG.ROOM_WIDTH;
        this.height = SURVIVOR_CONFIG.ROOM_HEIGHT;
        this.centerX = this.width / 2;
        this.centerY = this.height / 2;
        
        // é€‰æ‹©æ¨¡æ¿ï¼ˆ8ä¸ªä¹‹ä¸€ï¼‰
        const keys = Object.keys(ROOM_TEMPLATES);
        this.templateKey = templateKey || keys[Math.floor(Math.random() * keys.length)];
        this.template = ROOM_TEMPLATES[this.templateKey];
        this.obstacles = this.template.obstacles.map(o => ({...o}));
        this.spawnPoints = this.template.spawnPoints.map(p => ({...p}));
        
        // æ³¢æ¬¡ç®¡ç†å™¨
        this.hordeManager = null;
        if (type === 'normal' || type === 'boss') {
            this.hordeManager = new HordeManager(this);
        }
        
        if (type === 'shop') {
            this.npc = new ShopNPC(200, this.centerY);
        }
        
        this.spawnRoomItems();
    }
    
    spawnRoomItems() {
        if (this.type === 'treasure') {
            const count = randInt(2, 4);
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const r = 200;
                const x = this.centerX + Math.cos(angle) * r;
                const y = this.centerY + Math.sin(angle) * r;
                const itemId = randInt(1, 16);
                const item = ITEMS[itemId];
                if (item) {
                    this.items.push({ x, y, id: itemId, icon: item.icon, name: item.name });
                }
            }
        } else if (this.type === 'hidden') {
            const itemId = randInt(1, 16);
            const item = ITEMS[itemId];
            if (item) {
                this.items.push({
                    x: this.centerX, y: this.centerY,
                    id: itemId, icon: item.icon,
                    name: item.name + '(è¯…å’’)', cursed: true
                });
            }
        }
    }
    
    // è·å–å½“å‰æ´»è·ƒæ•Œäººï¼ˆä¾›å¤–éƒ¨ä½¿ç”¨ï¼‰
    getActiveEnemies() {
        if (this.hordeManager) {
            return this.hordeManager.getActiveEnemies();
        }
        return this.enemies.filter(e => e.hp > 0);
    }
    
    update(dt) {
        if (this.hordeManager) {
            this.hordeManager.update(dt);
            // æŒç»­è¡¥å……æ•Œäººç›´åˆ°è¾¾åˆ°æœ¬æ³¢ç›®æ ‡
            if (this.hordeManager.spawnedThisWave < this.hordeManager.targetCount) {
                this.hordeManager.spawnBatch();
            }
        }
    }

    spawnEnemies() {
        if (this.type === 'start' || this.type === 'treasure' || this.type === 'shop') return;
        
        if (this.type === 'hidden') {
            const eliteTypes = ['bear', 'yinya'];
            const typeKey = randChoice(eliteTypes);
            const elite = new Enemy(450, 300, typeKey);
            elite.hp *= 2;
            elite.maxHp *= 2;
            elite.dmg *= 1.5;
            elite.isElite = true;
            this.enemies.push(elite);
            return;
        }
        
        if (this.type === 'boss') {
            const bossCfg = BOSS_TYPES.mother;
            const boss = new Enemy(450, 200, 'bear');
            boss.name = bossCfg.name;
            boss.hp = bossCfg.hp;
            boss.maxHp = bossCfg.hp;
            boss.speed = bossCfg.speed;
            boss.dmg = bossCfg.dmg;
            boss.exp = bossCfg.exp;
            boss.gold = bossCfg.gold;
            boss.color = bossCfg.color;
            boss.isBoss = true;
            boss.phase = 0;
            this.enemies.push(boss);
            return;
        }
        
        const count = randInt(3, 7);
        const types = Object.keys(ENEMY_TYPES).filter(k => !ENEMY_TYPES[k].special);
        
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const r = 150 + Math.random() * 100;
            const x = 450 + Math.cos(angle) * r;
            const y = 300 + Math.sin(angle) * r;
            
            if (Math.random() < 0.1 && (this.gx + this.gy) > 2) {
                const specialTypes = ['tiaotiao', 'tiezhua', 'nibei', 'yinya'];
                this.enemies.push(new Enemy(x, y, randChoice(specialTypes)));
            } else {
                this.enemies.push(new Enemy(x, y, randChoice(types)));
            }
        }
    }

    draw(ctx, camera) {
        const floorColors = { 
            start: '#1a1a2e', normal: '#16213e', boss: '#2d1b2e', 
            treasure: '#2d2d1b', shop: '#1b1b2d', hidden: '#2d1b2d'
        };
        
        // åªç»˜åˆ¶è§†é‡å†…çš„åœ°æ¿
        const viewLeft = camera.x - camera.viewWidth / 2;
        const viewTop = camera.y - camera.viewHeight / 2;
        const viewRight = viewLeft + camera.viewWidth;
        const viewBottom = viewTop + camera.viewHeight;
        
        ctx.fillStyle = floorColors[this.type] || '#16213e';
        ctx.fillRect(0, 0, camera.viewWidth, camera.viewHeight);
        
        // ç»˜åˆ¶ç½‘æ ¼ï¼ˆè£…é¥°ï¼‰
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1;
        const gridOffsetX = -viewLeft % 50;
        const gridOffsetY = -viewTop % 50;
        for (let x = gridOffsetX; x < camera.viewWidth; x += 50) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, camera.viewHeight); ctx.stroke();
        }
        for (let y = gridOffsetY; y < camera.viewHeight; y += 50) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(camera.viewWidth, y); ctx.stroke();
        }
        
        // ç»˜åˆ¶éšœç¢ç‰©ï¼ˆåªç»˜åˆ¶è§†é‡å†…çš„ï¼‰
        ctx.fillStyle = '#2a2a3a';
        for (const obs of this.obstacles) {
            if (obs.x + obs.w > viewLeft && obs.x < viewRight &&
                obs.y + obs.h > viewTop && obs.y < viewBottom) {
                const screenPos = camera.worldToScreen(obs.x, obs.y);
                ctx.fillRect(screenPos.x, screenPos.y, obs.w, obs.h);
                // éšœç¢ç‰©è¾¹æ¡†
                ctx.strokeStyle = '#3a3a4a';
                ctx.strokeRect(screenPos.x, screenPos.y, obs.w, obs.h);
            }
        }
        
        // ç»˜åˆ¶æˆ¿é—´è¾¹ç•Œï¼ˆåšå¢™ï¼‰
        ctx.fillStyle = '#0f0f1a';
        const wallThickness = 100;
        // åªç»˜åˆ¶è§†é‡å†…çš„å¢™
        if (viewLeft < wallThickness) {
            const screenX = camera.worldToScreen(0, 0).x;
            ctx.fillRect(screenX, 0, wallThickness - viewLeft, camera.viewHeight);
        }
        if (viewRight > this.width - wallThickness) {
            const screenX = camera.worldToScreen(this.width - wallThickness, 0).x;
            ctx.fillRect(screenX, 0, viewRight - (this.width - wallThickness), camera.viewHeight);
        }
        if (viewTop < wallThickness) {
            const screenY = camera.worldToScreen(0, 0).y;
            ctx.fillRect(0, screenY, camera.viewWidth, wallThickness - viewTop);
        }
        if (viewBottom > this.height - wallThickness) {
            const screenY = camera.worldToScreen(0, this.height - wallThickness).y;
            ctx.fillRect(0, screenY, camera.viewWidth, viewBottom - (this.height - wallThickness));
        }
        
        // ç»˜åˆ¶é—¨ï¼ˆåªåœ¨é è¿‘è¾¹ç•Œæ—¶ï¼‰
        for (const [dir, door] of Object.entries(this.doors)) {
            if (!door) continue;
            ctx.fillStyle = door.open ? '#4a4' : '#a44';
            let doorX, doorY, doorW, doorH;
            switch(dir) {
                case 'up': doorX = this.centerX - 30; doorY = 0; doorW = 60; doorH = 40; break;
                case 'down': doorX = this.centerX - 30; doorY = this.height - 40; doorW = 60; doorH = 40; break;
                case 'left': doorX = 0; doorY = this.centerY - 40; doorW = 40; doorH = 80; break;
                case 'right': doorX = this.width - 40; doorY = this.centerY - 40; doorW = 40; doorH = 80; break;
            }
            if (doorX < viewRight && doorX + doorW > viewLeft &&
                doorY < viewBottom && doorY + doorH > viewTop) {
                const screenPos = camera.worldToScreen(doorX, doorY);
                ctx.fillRect(screenPos.x, screenPos.y, doorW, doorH);
            }
        }
        
        // æ˜¾ç¤ºæˆ¿é—´åç§°
        const roomLabels = {
            start: 'èµ·ç‚¹', normal: this.template.name, boss: 'BOSS',
            treasure: 'ğŸ’ å®ç®±æˆ¿', shop: 'ğŸª å•†åº—', hidden: 'ğŸ‘ï¸ éšè—æˆ¿'
        };
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(roomLabels[this.type] || this.template.name, 20, 30);
        
        // æ³¢æ¬¡ä¿¡æ¯
        if (this.hordeManager && this.type === 'normal') {
            ctx.fillStyle = '#aaa';
            ctx.font = '14px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`æ³¢æ¬¡: ${this.hordeManager.wave}`, camera.viewWidth - 20, 30);
            ctx.fillText(`æ•Œäºº: ${this.hordeManager.getActiveEnemies().length}`, camera.viewWidth - 20, 50);
        }
    }
}

// æ³¢æ¬¡ç®¡ç†å™¨
class HordeManager {
    constructor(room) {
        this.room = room;
        this.wave = 0;
        this.timer = 0;
        this.spawnedThisWave = 0;
        this.targetCount = 0;
        this.enemies = [];
        this.maxActiveEnemies = 100;
        this.spawnPoints = room.spawnPoints || [{ x: 300, y: 300 }];
    }
    
    update(dt) {
        this.timer += dt;
        if (this.timer >= SURVIVOR_CONFIG.WAVE_INTERVAL) {
            this.startNewWave();
        }
        this.enemies = this.enemies.filter(e => e.hp > 0);
    }
    
    startNewWave() {
        this.wave++;
        this.timer = 0;
        this.targetCount = SURVIVOR_CONFIG.WAVE_BASE_COUNT + this.wave * SURVIVOR_CONFIG.WAVE_INCREMENT;
        this.spawnedThisWave = 0;
        console.log(`ğŸŒŠ ç¬¬ ${this.wave} æ³¢ï¼ç›®æ ‡ï¼š${this.targetCount} åª`);
        this.spawnBatch();
    }
    
    spawnBatch() {
        const batchSize = Math.min(10, this.targetCount - this.spawnedThisWave);
        const activeCount = this.enemies.filter(e => e.hp > 0).length;
        if (activeCount >= this.maxActiveEnemies) return;
        
        for (let i = 0; i < batchSize; i++) {
            const point = this.spawnPoints[Math.floor(Math.random() * this.spawnPoints.length)];
            const enemy = this.createEnemy(point.x + (Math.random()-0.5)*100, point.y + (Math.random()-0.5)*100);
            this.enemies.push(enemy);
            this.spawnedThisWave++;
        }
    }
    
    createEnemy(x, y) {
        const types = Object.keys(ENEMY_TYPES).filter(k => !ENEMY_TYPES[k].special);
        const typeKey = types[Math.floor(Math.random() * types.length)];
        const enemy = new Enemy(x, y, typeKey);
        // æ ¹æ®æ³¢æ•°å¢å¼º
        const multiplier = 1 + this.wave * 0.1;
        enemy.hp *= multiplier;
        enemy.maxHp = enemy.hp;
        enemy.dmg *= multiplier;
        return enemy;
    }
    
    getActiveEnemies() {
        return this.enemies.filter(e => e.hp > 0);
    }
}

// åœ°å›¾ç”Ÿæˆå™¨
class MapGenerator {
    generate(floor = 1) {
        const rooms = new Map();
        const start = new Room(0, 0, 'start', floor);
        rooms.set(start.id, start);
        
        const queue = [start];
        const dirs = [
            { dx: 0, dy: -1, name: 'up', opp: 'down' },
            { dx: 1, dy: 0, name: 'right', opp: 'left' },
            { dx: 0, dy: 1, name: 'down', opp: 'up' },
            { dx: -1, dy: 0, name: 'left', opp: 'right' }
        ];
        
        let count = 1;
        const maxRooms = 8 + floor * 2;
        
        while (queue.length && count < maxRooms) {
            const cur = queue.shift();
            for (const dir of dirs.sort(() => Math.random() - 0.5)) {
                const nx = cur.gx + dir.dx, ny = cur.gy + dir.dy;
                const id = `${nx},${ny}`;
                
                if (rooms.has(id)) {
                    const ex = rooms.get(id);
                    if (!cur.doors[dir.name]) {
                        cur.doors[dir.name] = { open: cur.cleared, target: ex };
                        ex.doors[dir.opp] = { open: ex.cleared, target: cur };
                    }
                    continue;
                }
                
                if (Math.random() > 0.4 || count < 5) {
                    let type = 'normal';
                    if (count === maxRooms - 1) {
                        type = 'boss';
                    } else if (count > 3) {
                        const roll = Math.random();
                        if (roll < 0.15) type = 'treasure';
                        else if (roll < 0.30) type = 'shop';
                        else if (roll < 0.35) type = 'hidden';
                    }
                    
                    const nr = new Room(nx, ny, type, floor);
                    cur.doors[dir.name] = { open: cur.cleared, target: nr };
                    nr.doors[dir.opp] = { open: nr.cleared, target: cur };
                    rooms.set(id, nr);
                    queue.push(nr);
                    count++;
                }
            }
        }
        
        return { start, rooms };
    }
}

// ============================================================================
// ä¸»æ¸¸æˆç±» v0.7.2
// ============================================================================
// ==================== å¸è¡€é¬¼å¹¸å­˜è€…é£æ ¼é‡æ„ ====================
const SURVIVOR_CONFIG = {
    ROOM_WIDTH: 2700, ROOM_HEIGHT: 1800,
    VIEW_WIDTH: 900, VIEW_HEIGHT: 600,
    CAMERA_SMOOTH: 0.1,
    WAVE_INTERVAL: 30, WAVE_BASE_COUNT: 20, WAVE_INCREMENT: 5,
    GRID_CELL_SIZE: 150
};

class SurvivorCamera {
    constructor() {
        this.x = SURVIVOR_CONFIG.ROOM_WIDTH / 2;
        this.y = SURVIVOR_CONFIG.ROOM_HEIGHT / 2;
        this.target = null;
        this.viewWidth = SURVIVOR_CONFIG.VIEW_WIDTH;
        this.viewHeight = SURVIVOR_CONFIG.VIEW_HEIGHT;
    }
    follow(target) { this.target = target; }
    update() {
        if (!this.target) return;
        this.x += (this.target.x - this.x) * SURVIVOR_CONFIG.CAMERA_SMOOTH;
        this.y += (this.target.y - this.y) * SURVIVOR_CONFIG.CAMERA_SMOOTH;
        const minX = this.viewWidth / 2, maxX = SURVIVOR_CONFIG.ROOM_WIDTH - this.viewWidth / 2;
        const minY = this.viewHeight / 2, maxY = SURVIVOR_CONFIG.ROOM_HEIGHT - this.viewHeight / 2;
        this.x = Math.max(minX, Math.min(maxX, this.x));
        this.y = Math.max(minY, Math.min(maxY, this.y));
    }
    worldToScreen(wx, wy) {
        return { x: wx - this.x + this.viewWidth / 2, y: wy - this.y + this.viewHeight / 2 };
    }
    isVisible(wx, wy, radius = 50) {
        return Math.abs(wx - this.x) < this.viewWidth / 2 + radius && Math.abs(wy - this.y) < this.viewHeight / 2 + radius;
    }
}

class SpatialGrid {
    constructor() {
        this.cellSize = SURVIVOR_CONFIG.GRID_CELL_SIZE;
        this.cells = new Map();
    }
    getKey(cx, cy) { return `${cx},${cy}`; }
    getCellByPos(x, y) {
        return { cx: Math.floor(x / this.cellSize), cy: Math.floor(y / this.cellSize) };
    }
    clear() { this.cells.clear(); }
    insert(entity) {
        const { cx, cy } = this.getCellByPos(entity.x, entity.y);
        const key = this.getKey(cx, cy);
        if (!this.cells.has(key)) this.cells.set(key, []);
        this.cells.get(key).push(entity);
        entity._gridCell = { cx, cy };
    }
    getNearby(x, y) {
        const { cx, cy } = this.getCellByPos(x, y);
        const result = [];
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const cell = this.cells.get(this.getKey(cx + dx, cy + dy));
                if (cell) result.push(...cell);
            }
        }
        return result;
    }
}

// 8ä¸ªæˆ¿é—´æ¨¡æ¿
const ROOM_TEMPLATES = {
    maze: { name: 'å›å­—å½¢è¿·å®«', obstacles: [{x:200,y:100,w:2300,h:100},{x:200,y:1600,w:2300,h:100},{x:100,y:200,w:100,h:1400},{x:2500,y:200,w:100,h:1400},{x:800,y:500,w:1100,h:80},{x:800,y:1200,w:1100,h:80},{x:800,y:580,w:80,h:620},{x:1820,y:580,w:80,h:620}], spawnPoints: [{x:500,y:300},{x:2200,y:300},{x:500,y:1500},{x:2200,y:1500}] },
    cross: { name: 'åå­—æ²³æµ', obstacles: [{x:1300,y:0,w:100,h:700},{x:1300,y:1100,w:100,h:700},{x:0,y:850,w:1000,h:100},{x:1700,y:850,w:1000,h:100}], spawnPoints: [{x:500,y:400},{x:2200,y:400},{x:500,y:1400},{x:2200,y:1400}] },
    spiral: { name: 'èºæ—‹æ­»äº¡', obstacles: [{x:400,y:400,w:1900,h:100},{x:2200,y:400,w:100,h:500},{x:600,y:800,w:1700,h:100},{x:600,y:900,w:100,h:500},{x:700,y:1300,w:1300,h:100},{x:1900,y:1000,w:100,h:300}], spawnPoints: [{x:300,y:300},{x:2400,y:300},{x:300,y:1500},{x:2400,y:1500}] },
    islands: { name: 'å²›å±¿ç¾¤', obstacles: [{x:300,y:300,w:200,h:200},{x:800,y:200,w:250,h:150},{x:1500,y:300,w:200,h:200},{x:2100,y:250,w:250,h:200},{x:400,y:800,w:300,h:200},{x:1200,y:750,w:300,h:300},{x:2000,y:800,w:250,h:200},{x:300,y:1300,w:250,h:200},{x:900,y:1400,w:200,h:200},{x:1600,y:1350,w:250,h:200},{x:2200,y:1300,w:200,h:200}], spawnPoints: [{x:200,y:600},{x:2500,y:600},{x:200,y:1200},{x:2500,y:1200}] },
    arena: { name: 'ç«æŠ€åœº', obstacles: [{x:0,y:0,w:800,h:300},{x:1900,y:0,w:800,h:300},{x:0,y:1500,w:800,h:300},{x:1900,y:1500,w:800,h:300},{x:0,y:300,w:300,h:1200},{x:2400,y:300,w:300,h:1200}], spawnPoints: [{x:400,y:400},{x:2300,y:400},{x:400,y:1400},{x:2300,y:1400}] },
    dual: { name: 'åŒé€šé“', obstacles: [{x:0,y:550,w:1000,h:100},{x:1700,y:550,w:1000,h:100},{x:0,y:1150,w:1000,h:100},{x:1700,y:1150,w:1000,h:100},{x:1200,y:850,w:300,h:100}], spawnPoints: [{x:200,y:300},{x:2500,y:300},{x:200,y:1500},{x:2500,y:1500}] },
    ruins: { name: 'åºŸå¢Ÿè¿·å®«', obstacles: [{x:400,y:300,w:150,h:400},{x:800,y:600,w:200,h:100},{x:1200,y:200,w:100,h:300},{x:1600,y:500,w:150,h:250},{x:2000,y:300,w:100,h:400},{x:300,y:900,w:200,h:100},{x:700,y:1100,w:150,h:200},{x:1100,y:900,w:200,h:150},{x:1500,y:1200,w:100,h:300},{x:1900,y:1000,w:250,h:100},{x:2300,y:1300,w:100,h:200},{x:500,y:1400,w:300,h:100},{x:1000,y:1500,w:150,h:200},{x:1800,y:1500,w:200,h:150}], spawnPoints: [{x:200,y:200},{x:2500,y:200},{x:200,y:1600},{x:2500,y:1600}] },
    corridor: { name: 'æ— å°½é•¿å»Š', obstacles: [{x:0,y:0,w:200,h:1800},{x:2500,y:0,w:200,h:1800},{x:600,y:400,w:100,h:200},{x:1300,y:800,w:100,h:200},{x:2000,y:1200,w:100,h:200}], spawnPoints: [{x:300,y:200},{x:300,y:600},{x:300,y:1000},{x:300,y:1400},{x:2400,y:300},{x:2400,y:900},{x:2400,y:1500}] }
};

// å…¨å±é€‚é…å™¨
class FullscreenAdapter {
    constructor(canvas, gameWidth = 900, gameHeight = 600) {
        this.canvas = canvas;
        this.gameWidth = gameWidth;
        this.gameHeight = gameHeight;
        this.scale = 1;
        this.setup();
        window.addEventListener('resize', () => this.resize());
    }
    setup() {
        document.body.style.margin = '0';
        document.body.style.padding = '0';
        document.body.style.overflow = 'hidden';
        this.resize();
    }
    resize() {
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const scaleX = windowWidth / this.gameWidth;
        const scaleY = windowHeight / this.gameHeight;
        this.scale = Math.min(scaleX, scaleY, 2);
        const displayWidth = this.gameWidth * this.scale;
        const displayHeight = this.gameHeight * this.scale;
        this.canvas.style.width = displayWidth + 'px';
        this.canvas.style.height = displayHeight + 'px';
        this.canvas.style.position = 'absolute';
        this.canvas.style.left = ((windowWidth - displayWidth) / 2) + 'px';
        this.canvas.style.top = ((windowHeight - displayHeight) / 2) + 'px';
        this.canvas.width = this.gameWidth;
        this.canvas.height = this.gameHeight;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // å…¨å±é€‚é…
        this.fullscreen = new FullscreenAdapter(this.canvas, 900, 600);
        
        // ç›¸æœºç³»ç»Ÿ
        this.camera = new SurvivorCamera();
        
        // ç©ºé—´ç½‘æ ¼ï¼ˆç¢°æ’ä¼˜åŒ–ï¼‰
        this.spatialGrid = new SpatialGrid();
        
        this.sprites = new SpriteLoader();
        this.state = 'loading';
        
        // ç©å®¶åˆå§‹ä½ç½®åœ¨å¤§æˆ¿é—´ä¸­å¿ƒ
        const startX = SURVIVOR_CONFIG.ROOM_WIDTH / 2;
        const startY = SURVIVOR_CONFIG.ROOM_HEIGHT / 2;
        this.player = { x: startX, y: startY, hp: 6, maxHp: 6, exp: 0, lv: 1, gold: 100, 
            facingRight: true, isMoving: false, walkCycle: 0,
            isDashing: false, dashTime: 0, dashCooldown: 0, dashDirection: {x:0, y:0}, dashTrail: [], jumpY: 0
        };
        
        // ç›¸æœºè·Ÿéšç©å®¶
        this.camera.follow(this.player);
        this.items = new ItemManager(this.player);
        this.totems = new TotemManager();
        this.materials = new MaterialManager(); // ææ–™ç³»ç»Ÿ
        this.weapons = [new Weapon('whip', 1)];
        this.activeWeapon = 0;
        this.bullets = [];
        this.particles = new ParticleSystem();
        this.gems = [];
        this.goldDrops = [];
        
        this.currentFloor = 1;
        this.maxFloors = 6; // 6å±‚åœ°å›¾ï¼šèŒä¸åŒºã€å­µåŒ–æ¸©å®¤ã€ç¥ç»ç´¢ã€æ¶ˆåŒ–ç†”ç‚‰ã€æ¯è™«åº­é™¢ã€åƒæ ¹ä¹‹å¿ƒ
        this.allFloors = new Map();
        
        const gen = new MapGenerator();
        const map = gen.generate(1);
        this.curRoom = map.start;
        this.allRooms = map.rooms;
        this.curRoom.visited = true;
        this.allFloors.set(1, { start: map.start, rooms: map.rooms });
        
        this.keys = {};
        this.transition = { active: false, timer: 0, dir: null, target: null };
        this.rafId = null;
        this.godMode = false;
        
        this.shopOpen = false;
        this.shopItems = [];
        this.shopSelected = -1;
        
        this.evolutionOpen = false; // æ­¦å™¨è¿›åŒ–ç•Œé¢
        this.evolutionSelected = -1;
        
        this.sounds = new SoundManager();
        this.setupInput();
    }

    async loadSprites() {
        const basePath = 'https://wearescientist.github.io/rouge-cow/assets/sprites/';
        await this.sprites.load('player', basePath + 'player_cow.png');
        
        const enemies = ['chick', 'pig', 'sheep', 'dog', 'cat', 'bear'];
        for (const name of enemies) {
            await this.sprites.load(name, basePath + name + '.png');
            this.updateLoadingProgress();
        }
        
        const specialEnemies = ['rabbit', 'bird', 'turtle', 'dog2'];
        for (const name of specialEnemies) {
            await this.sprites.load(name, basePath + name + '.png');
            this.updateLoadingProgress();
        }
    }
    
    updateLoadingProgress() {
        const progress = this.sprites.getProgress() * 100;
        const progressBar = document.getElementById('loadingProgress');
        const loadingText = document.getElementById('loadingText');
        if (progressBar) progressBar.style.width = `${progress}%`;
        if (loadingText) loadingText.textContent = `æ­£åœ¨åŠ è½½... ${Math.floor(progress)}%`;
    }

    setupInput() {
        window.addEventListener('keydown', e => {
            this.keys[e.key] = true;
            
            // æ­¦å™¨è¿›åŒ–ç•Œé¢
            if (e.key === 'v' || e.key === 'V') {
                if (this.evolutionOpen) {
                    this.closeEvolution();
                } else {
                    this.openEvolution();
                }
                return;
            }
            
            // è¿›åŒ–ç•Œé¢æ“ä½œ
            if (this.evolutionOpen) {
                if (e.key >= '1' && e.key <= '3') {
                    this.evolveWeapon(parseInt(e.key) - 1);
                }
                return;
            }
            
            // å•†åº—äº¤äº’
            if (e.key === 'e' || e.key === 'E') {
                if (this.shopOpen) {
                    this.closeShop();
                } else if (this.curRoom.type === 'shop' && this.curRoom.npc) {
                    const d = dist(this.player.x, this.player.y, this.curRoom.npc.x, this.curRoom.npc.y);
                    if (d < 80) {
                        this.openShop();
                    }
                }
            }
            
            if (this.shopOpen) {
                if (e.key >= '1' && e.key <= '3') {
                    this.buyItem(parseInt(e.key) - 1);
                }
                return;
            }
            
            if (e.key >= '1' && e.key <= '9') {
                const id = parseInt(e.key);
                if (this.items.add(id)) {
                    this.particles.burst(this.player.x, this.player.y, '#ff0', 15);
                }
            }
            
            if (e.key === 'f' || e.key === 'F') {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }
            
            if (e.key === 'g' || e.key === 'G') {
                this.godMode = !this.godMode;
                console.log(`æ— æ•Œæ¨¡å¼: ${this.godMode ? 'å¼€å¯' : 'å…³é—­'}`);
            }
        });
        
        window.addEventListener('keyup', e => this.keys[e.key] = false);
    }
    
    openEvolution() {
        this.evolutionOpen = true;
        console.log('æ­¦å™¨è¿›åŒ–ç•Œé¢å·²æ‰“å¼€');
    }
    
    closeEvolution() {
        this.evolutionOpen = false;
        this.evolutionSelected = -1;
        console.log('æ­¦å™¨è¿›åŒ–ç•Œé¢å·²å…³é—­');
    }
    
    evolveWeapon(index) {
        const weapon = this.weapons[this.activeWeapon];
        if (!weapon) return;
        
        const evolutions = WEAPON_EVOLUTIONS[weapon.baseKey];
        if (!evolutions) return;
        
        const evoKeys = Object.keys(evolutions);
        if (index >= evoKeys.length) return;
        
        const evoKey = evoKeys[index];
        const evoData = evolutions[evoKey];
        
        // æ£€æŸ¥ææ–™
        let canEvolve = true;
        for (const [mat, count] of Object.entries(evoData.req)) {
            if (!this.materials.has(mat, count)) {
                canEvolve = false;
                break;
            }
        }
        
        if (canEvolve) {
            // æ¶ˆè€—ææ–™
            for (const [mat, count] of Object.entries(evoData.req)) {
                this.materials.consume(mat, count);
            }
            
            // è¿›åŒ–æ­¦å™¨
            const oldName = weapon.cfg.name;
            this.weapons[this.activeWeapon] = new Weapon(weapon.baseKey, weapon.level, evoKey);
            
            this.particles.burst(this.player.x, this.player.y, '#f0f', 30);
            this.sounds.play('evolve');
            console.log(`æ­¦å™¨è¿›åŒ–: ${oldName} â†’ ${evoData.name}`);
            
            this.closeEvolution();
        } else {
            console.log('ææ–™ä¸è¶³ï¼Œæ— æ³•è¿›åŒ–');
        }
    }
    
    openShop() {
        if (this.shopItems.length === 0) {
            const itemIds = Object.keys(ITEMS).map(Number);
            const selected = [];
            while (selected.length < 3 && itemIds.length > 0) {
                const idx = Math.floor(Math.random() * itemIds.length);
                const itemId = itemIds.splice(idx, 1)[0];
                const item = ITEMS[itemId];
                if (item) {
                    selected.push({
                        id: itemId,
                        icon: item.icon,
                        name: item.name,
                        desc: item.desc,
                        price: getItemPrice(itemId),
                        rarity: item.rarity
                    });
                }
            }
            this.shopItems = selected;
        }
        this.shopOpen = true;
        console.log('å•†åº—å·²æ‰“å¼€');
    }
    
    closeShop() {
        this.shopOpen = false;
        this.shopSelected = -1;
        console.log('å•†åº—å·²å…³é—­');
    }
    
    buyItem(index) {
        if (index < 0 || index >= this.shopItems.length) return;
        const item = this.shopItems[index];
        if (this.player.gold >= item.price) {
            this.player.gold -= item.price;
            this.items.add(item.id);
            this.particles.burst(this.player.x, this.player.y, '#ff0', 20);
            this.sounds.play('buy');
            this.shopItems.splice(index, 1);
            console.log(`è´­ä¹°æˆåŠŸ: ${item.name}`);
        } else {
            console.log('é‡‘å¸ä¸è¶³');
        }
    }

    async start() {
        await this.loadSprites();
        this.sounds.init();
        document.getElementById('loading').classList.add('hidden');
        
        document.getElementById('story').style.display = 'block';
        document.getElementById('startGameBtn').addEventListener('click', () => {
            document.getElementById('story').style.display = 'none';
            this.state = 'playing';
            this.loop(0);
        });
    }

    update(dt) {
        if (this.shopOpen || this.evolutionOpen) return;
        
        // æ›´æ–°æˆ¿é—´ï¼ˆæ³¢æ¬¡ç³»ç»Ÿï¼‰
        this.curRoom.update(dt);
        
        if (this.transition.active) {
            this.transition.timer -= dt;
            if (this.transition.timer <= 0) {
                this.curRoom = this.transition.target;
                this.curRoom.visited = true;
                const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
                const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
                const wallT = 100;
                // å¤§æˆ¿é—´ä¼ é€ä½ç½®
                if (this.transition.dir === 'left') this.player.x = roomW - wallT - 50;
                else if (this.transition.dir === 'right') this.player.x = wallT + 50;
                else this.player.x = roomW / 2;
                
                if (this.transition.dir === 'up') this.player.y = roomH - wallT - 50;
                else if (this.transition.dir === 'down') this.player.y = wallT + 50;
                else this.player.y = roomH / 2;
                
                this.transition.active = false;
            }
            return;
        }

        const stats = this.items.getStats();
        const totemBonuses = this.totems.getAllBonuses();
        stats.dmg = (stats.dmg || 1) * (1 + totemBonuses.dmg);
        stats.maxHp += totemBonuses.maxHp;
        stats.speed *= (1 + totemBonuses.speed);
        stats.crit = Math.min(1, stats.crit + totemBonuses.crit);
        
        const speed = 150 * stats.speed;
        
        // å†²åˆºå†·å´æ›´æ–°
        if (this.player.dashCooldown > 0) this.player.dashCooldown -= dt;
        
        // å†²åˆºå¤„ç†
        if (this.player.isDashing) {
            this.player.dashTime -= dt;
            if (this.player.dashTime <= 0) {
                this.player.isDashing = false;
                this.player.jumpY = 0;
            } else {
                // å†²åˆºä¸­ - å¿«é€Ÿç§»åŠ¨
                const dashSpeed = 400;
                this.player.x += this.player.dashDirection.x * dashSpeed * dt;
                this.player.y += this.player.dashDirection.y * dashSpeed * dt;
                // è·³è·ƒå¼§çº¿
                const progress = 1 - (this.player.dashTime / 0.15);
                this.player.jumpY = -Math.sin(progress * Math.PI) * 12;
                // æ·»åŠ æ®‹å½±
                if (Math.random() < 0.5) {
                    this.player.dashTrail.push({x: this.player.x, y: this.player.y + this.player.jumpY, alpha: 0.5});
                }
            }
        }
        
        // æ™®é€šç§»åŠ¨
        let dx = 0, dy = 0;
        if (this.keys['w'] || this.keys['W'] || this.keys['ArrowUp']) dy -= 1;
        if (this.keys['s'] || this.keys['S'] || this.keys['ArrowDown']) dy += 1;
        if (this.keys['a'] || this.keys['A'] || this.keys['ArrowLeft']) { dx -= 1; this.player.facingRight = false; }
        if (this.keys['d'] || this.keys['D'] || this.keys['ArrowRight']) { dx += 1; this.player.facingRight = true; }
        
        // ç©ºæ ¼å†²åˆºè§¦å‘
        if (this.keys[' '] && this.player.dashCooldown <= 0 && !this.player.isDashing) {
            if (dx !== 0 || dy !== 0) {
                const len = Math.sqrt(dx*dx + dy*dy);
                this.player.isDashing = true;
                this.player.dashTime = 0.15;
                this.player.dashCooldown = 0.6;
                this.player.dashDirection = {x: dx/len, y: dy/len};
            }
        }
        
        this.player.isMoving = (dx !== 0 || dy !== 0);
        if (this.player.isMoving && !this.player.isDashing) {
            this.player.walkCycle += dt * 15;
        } else {
            this.player.walkCycle = 0;
        }
        
        // æ›´æ–°æ®‹å½±
        for (let i = this.player.dashTrail.length - 1; i >= 0; i--) {
            this.player.dashTrail[i].alpha -= 0.1;
            if (this.player.dashTrail[i].alpha <= 0) this.player.dashTrail.splice(i, 1);
        }
        
        if ((dx !== 0 || dy !== 0) && !this.player.isDashing) {
            const len = Math.sqrt(dx*dx + dy*dy);
            const newX = this.player.x + (dx / len) * speed * dt;
            const newY = this.player.y + (dy / len) * speed * dt;
            
            const wallThickness = 40;
            
            let canMoveX = true;
            const roomWidth = SURVIVOR_CONFIG.ROOM_WIDTH;
            const roomHeight = SURVIVOR_CONFIG.ROOM_HEIGHT;
            const centerX = roomWidth / 2;
            const centerY = roomHeight / 2;
            
            if (newX < wallThickness) {
                if (!(this.player.y > centerY - 40 && this.player.y < centerY + 40 && this.curRoom.doors.left && this.curRoom.doors.left.open)) {
                    canMoveX = false;
                }
            }
            if (newX > roomWidth - wallThickness) {
                if (!(this.player.y > centerY - 40 && this.player.y < centerY + 40 && this.curRoom.doors.right && this.curRoom.doors.right.open)) {
                    canMoveX = false;
                }
            }
            
            let canMoveY = true;
            if (newY < wallThickness) {
                if (!(this.player.x > centerX - 30 && this.player.x < centerX + 30 && this.curRoom.doors.up && this.curRoom.doors.up.open)) {
                    canMoveY = false;
                }
            }
            if (newY > roomHeight - wallThickness) {
                if (!(this.player.x > centerX - 30 && this.player.x < centerX + 30 && this.curRoom.doors.down && this.curRoom.doors.down.open)) {
                    canMoveY = false;
                }
            }
            
            // éšœç¢ç‰©ç¢°æ’æ£€æµ‹
            for (const obs of this.curRoom.obstacles) {
                if (newX > obs.x - 20 && newX < obs.x + obs.w + 20 &&
                    newY > obs.y - 20 && newY < obs.y + obs.h + 20) {
                    canMoveX = false;
                    canMoveY = false;
                    break;
                }
            }
            
            if (canMoveX) this.player.x = newX;
            if (canMoveY) this.player.y = newY;
        }
        
        this.player.x = clamp(this.player.x, wallThickness, SURVIVOR_CONFIG.ROOM_WIDTH - wallThickness);
        this.player.y = clamp(this.player.y, wallThickness, SURVIVOR_CONFIG.ROOM_HEIGHT - wallThickness);
        
        if (this.curRoom.cleared) {
            const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
            const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
            for (const [dir, door] of Object.entries(this.curRoom.doors)) {
                if (!door || !door.open) continue;
                const pos = { 
                    up: [roomW/2 - 30, 0, 60, 40], 
                    down: [roomW/2 - 30, roomH - 40, 60, 40], 
                    left: [0, roomH/2 - 40, 40, 80], 
                    right: [roomW - 40, roomH/2 - 40, 40, 80] 
                }[dir];
                if (this.player.x > pos[0] && this.player.x < pos[0] + pos[2] &&
                    this.player.y > pos[1] && this.player.y < pos[1] + pos[3]) {
                    this.transition = { active: true, timer: 0.3, dir, target: door.target };
                    break;
                }
            }
        }
        
        // æ›´æ–°æ•Œäººï¼ˆä½¿ç”¨æ³¢æ¬¡ç®¡ç†å™¨çš„æ´»è·ƒæ•Œäººï¼‰
        const activeEnemies = this.curRoom.getActiveEnemies ? this.curRoom.getActiveEnemies() : this.curRoom.enemies;
        for (const e of activeEnemies) {
            if (e.hp <= 0) continue;
            e.update(dt, this.player, this.curRoom);
            const d = dist(e.x, e.y, this.player.x, this.player.y);
            if (d < 25 && e.attackCd <= 0) {
                if (!this.godMode && !this.player.isDashing) {
                    this.player.hp -= Math.max(0, e.dmg - stats.armor);
                }
                e.attackCd = 0.5;
                if (this.player.hp <= 0) this.state = 'gameover';
            }
        }
        
        if (this.curRoom.enemies.length === 0 && !this.curRoom.cleared) {
            this.curRoom.cleared = true;
            for (const door of Object.values(this.curRoom.doors)) {
                if (door) door.open = true;
            }
            this.particles.burst(450, 300, '#4f4', 30);
            
            if (this.curRoom.type === 'boss') {
                this.state = 'victory';
                this.spawnTotemPickup();
                return;
            }
            
            this.spawnRoomReward();
        }
        
        // å¯»æ‰¾æœ€è¿‘ç›®æ ‡ï¼ˆä»æ´»è·ƒæ•Œäººä¸­ï¼‰
        let target = null, minD = 9999;
        for (const e of activeEnemies) {
            if (e.hp <= 0) continue;
            const d = dist(e.x, e.y, this.player.x, this.player.y);
            if (d < minD) { minD = d; target = e; }
        }
        
        for (const w of this.weapons) w.update(dt);
        
        const activeW = this.weapons[this.activeWeapon];
        if (activeW && activeW.canFire() && target) {
            this.bullets.push(...activeW.fire(this.player, target, stats));
            this.sounds.play('shoot');
        }
        
        // å­å¼¹è¾¹ç•Œæ£€æŸ¥ï¼ˆå¤§æˆ¿é—´ï¼‰
        const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
        const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            const b = this.bullets[i];
            
            if (b.x < 0 || b.x > roomW || b.y < 0 || b.y > roomH) {
                this.bullets.splice(i, 1);
                continue;
            }
            
            if (b.homing && b.target && activeEnemies.includes(b.target)) {
                const dx = b.target.x - b.x;
                const dy = b.target.y - b.y;
                const d = Math.sqrt(dx*dx + dy*dy);
                if (d > 0) {
                    const targetAngle = Math.atan2(dy, dx);
                    const currentAngle = Math.atan2(b.vy, b.vx);
                    let angleDiff = targetAngle - currentAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    const turnRate = 3 * dt;
                    const newAngle = currentAngle + Math.max(-turnRate, Math.min(turnRate, angleDiff));
                    const spd = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
                    b.vx = Math.cos(newAngle) * spd;
                    b.vy = Math.sin(newAngle) * spd;
                }
            }
            
            b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
            
            if (b.life <= 0) { this.bullets.splice(i, 1); continue; }
            
            let hit = false;
            // ä½¿ç”¨ç©ºé—´ç½‘æ ¼ä¼˜åŒ–ç¢°æ’æ£€æµ‹
            const nearbyEnemies = this.spatialGrid.getNearby(b.x, b.y);
            for (const e of nearbyEnemies) {
                if (e.hp <= 0) continue;
                if (dist(b.x, b.y, e.x, e.y) < 20 && !b.hits.has(e)) {
                    b.hits.add(e);
                    
                    // è®¡ç®—æ€»ä¼¤å®³
                    let totalDmg = b.dmg;
                    if (stats.fireDmg) totalDmg += stats.fireDmg;
                    if (stats.thunderDmg && Math.random() < 0.3) totalDmg += stats.thunderDmg;
                    
                    const killed = e.takeDamage(totalDmg, stats);
                    
                    if (stats.poisonDmg) e.applyPoison(stats.poisonDmg, 3);
                    if (stats.healOnHit) {
                        this.player.hp = Math.min(this.player.maxHp, this.player.hp + stats.healOnHit);
                    }
                    
                    if (killed) {
                        e.hp = 0; // æ ‡è®°æ­»äº¡
                        this.gems.push({ x: e.x, y: e.y, v: e.exp || 10, life: 30 });
                        this.goldDrops.push({ x: e.x, y: e.y, v: e.gold || 5, life: 30 });
                        
                        // ææ–™æ‰è½
                        if (Math.random() < 0.15) {
                            const matTypes = Object.keys(MATERIALS);
                            const matType = randChoice(matTypes);
                            this.materials.add(matType, 1);
                            console.log(`è·å¾—ææ–™: ${MATERIALS[matType].name}`);
                        }
                        
                        this.particles.burst(e.x, e.y, e.color, 8);
                        this.sounds.play('kill');
                    } else {
                        this.sounds.play('hit');
                    }
                    if (b.pierce-- <= 0) { hit = true; break; }
                }
            }
            if (hit) this.bullets.splice(i, 1);
        }
        
        for (let i = this.gems.length - 1; i >= 0; i--) {
            const g = this.gems[i];
            const d = dist(g.x, g.y, this.player.x, this.player.y);
            if (d < stats.magnet) {
                g.x += (this.player.x - g.x) * 5 * dt;
                g.y += (this.player.y - g.y) * 5 * dt;
            }
            if (d < 20) {
                this.player.exp += g.v;
                this.gems.splice(i, 1);
                if (this.player.exp >= this.player.lv * 100) {
                    this.player.exp -= this.player.lv * 100;
                    this.player.lv++;
                    this.player.maxHp++;
                    this.player.hp++;
                    this.particles.burst(this.player.x, this.player.y, '#ff0', 20);
                    this.sounds.play('levelup');
                }
            }
        }
        
        for (let i = this.goldDrops.length - 1; i >= 0; i--) {
            const g = this.goldDrops[i];
            const d = dist(g.x, g.y, this.player.x, this.player.y);
            if (d < stats.magnet) {
                g.x += (this.player.x - g.x) * 5 * dt;
                g.y += (this.player.y - g.y) * 5 * dt;
            }
            if (d < 20) {
                this.player.gold += g.v;
                this.goldDrops.splice(i, 1);
                this.particles.burst(this.player.x, this.player.y, '#fc0', 5);
            }
        }
        
        for (let i = this.curRoom.items.length - 1; i >= 0; i--) {
            const item = this.curRoom.items[i];
            const d = dist(item.x, item.y, this.player.x, this.player.y);
            
            if (d < 30) {
                if (item.type === 'weapon') {
                    const existingIdx = this.weapons.findIndex(w => w.cfg.key === item.weaponKey);
                    if (existingIdx >= 0) {
                        const leveledUp = this.weapons[existingIdx].addXp(100);
                        if (leveledUp) this.particles.burst(item.x, item.y, '#f0f', 20);
                    } else if (this.weapons.length < 5) {
                        this.weapons.push(new Weapon(item.weaponKey, 1));
                    }
                } else if (item.type === 'totem') {
                    if (this.totems.collect(item.totemId)) {
                        this.particles.burst(item.x, item.y, '#ff0', 30);
                        const totem = TOTEMS[item.totemId];
                        if (totem.effect === 'maxHp') {
                            this.player.maxHp += totem.value;
                            this.player.hp += totem.value;
                        }
                    }
                } else {
                    this.items.add(item.id);
                }
                this.curRoom.items.splice(i, 1);
                this.particles.burst(item.x, item.y, '#ff0', 10);
            }
        }
        
        this.particles.update(dt);
    }

    draw() {
        // æ›´æ–°ç›¸æœº
        this.camera.update();
        
        // æ¸…ç©ºç”»å¸ƒ
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, 900, 600);
        
        // ç»˜åˆ¶æˆ¿é—´ï¼ˆä¼ å…¥ç›¸æœºï¼‰
        this.curRoom.draw(this.ctx, this.camera);
        
        // ç»˜åˆ¶æ‰è½ç‰©ï¼ˆåªç»˜åˆ¶è§†é‡å†…çš„ï¼‰
        for (const g of this.goldDrops) {
            if (!this.camera.isVisible(g.x, g.y, 20)) continue;
            const pos = this.camera.worldToScreen(g.x, g.y);
            this.ctx.fillStyle = '#fc0';
            this.ctx.font = '16px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('ğŸ’°', pos.x, pos.y);
        }
        
        for (const g of this.gems) {
            if (!this.camera.isVisible(g.x, g.y, 20)) continue;
            const pos = this.camera.worldToScreen(g.x, g.y);
            this.ctx.fillStyle = '#48f';
            this.ctx.beginPath();
            this.ctx.moveTo(pos.x, pos.y - 5);
            this.ctx.lineTo(pos.x + 4, pos.y);
            this.ctx.lineTo(pos.x, pos.y + 5);
            this.ctx.lineTo(pos.x - 4, pos.y);
            this.ctx.fill();
        }
        
        for (const b of this.bullets) {
            if (!this.camera.isVisible(b.x, b.y, 20)) continue;
            const pos = this.camera.worldToScreen(b.x, b.y);
            this.ctx.fillStyle = b.color;
            this.ctx.beginPath();
            this.ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        for (const item of this.curRoom.items) {
            if (!this.camera.isVisible(item.x, item.y, 30)) continue;
            const pos = this.camera.worldToScreen(item.x, item.y);
            this.ctx.fillStyle = '#ff0';
            this.ctx.font = '20px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(item.icon, pos.x, pos.y + 5);
            
            this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(pos.x, pos.y, 15 + Math.sin(Date.now() / 200) * 3, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        
        // è·å–æ´»è·ƒæ•Œäººå¹¶æ›´æ–°ç©ºé—´ç½‘æ ¼
        const activeEnemies = this.curRoom.hordeManager ? this.curRoom.hordeManager.getActiveEnemies() : this.curRoom.enemies;
        this.spatialGrid.clear();
        for (const e of activeEnemies) {
            if (e.hp > 0) this.spatialGrid.insert(e);
        }
        
        for (const e of activeEnemies) {
            if (!this.camera.isVisible(e.x, e.y, 30)) continue;
            // æ•Œäººä½¿ç”¨ç›¸æœºåæ ‡ç»˜åˆ¶ï¼ˆéœ€è¦åœ¨Enemyç±»ä¸­æ”¯æŒï¼‰
            const pos = this.camera.worldToScreen(e.x, e.y);
            this.ctx.save();
            this.ctx.translate(pos.x, pos.y);
            // ç®€åŒ–çš„æ•Œäººç»˜åˆ¶
            this.ctx.fillStyle = e.color || '#c44';
            this.ctx.beginPath();
            this.ctx.arc(0, 0, e.radius || 15, 0, Math.PI * 2);
            this.ctx.fill();
            // è¡€æ¡
            const hpPercent = e.hp / e.maxHp;
            this.ctx.fillStyle = '#300';
            this.ctx.fillRect(-15, -25, 30, 4);
            this.ctx.fillStyle = hpPercent > 0.5 ? '#4f4' : '#f44';
            this.ctx.fillRect(-15, -25, 30 * hpPercent, 4);
            this.ctx.restore();
        }
        
        if (this.curRoom.type === 'shop' && this.curRoom.npc) {
            const npc = this.curRoom.npc;
            if (this.camera.isVisible(npc.x, npc.y, 40)) {
                const pos = this.camera.worldToScreen(npc.x, npc.y);
                const d = dist(this.player.x, this.player.y, npc.x, npc.y);
                // ç®€åŒ–çš„NPCç»˜åˆ¶
                this.ctx.fillStyle = '#4a4';
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('ğŸ¦¯', pos.x, pos.y + 5);
                if (d < 80 && !this.shopOpen) {
                    this.ctx.fillStyle = '#4f4';
                    this.ctx.fillText('æŒ‰Eäº¤äº’', pos.x, pos.y - 30);
                }
            }
        }
        
        // ç©å®¶å±å¹•åæ ‡
        const playerScreen = this.camera.worldToScreen(this.player.x, this.player.y);
        
        // ç»˜åˆ¶å†²åˆºæ®‹å½±
        for (const trail of this.player.dashTrail) {
            const trailScreen = this.camera.worldToScreen(trail.x, trail.y);
            this.ctx.globalAlpha = trail.alpha * 0.4;
            this.ctx.fillStyle = '#88ccff';
            this.ctx.beginPath();
            this.ctx.arc(trailScreen.x, trailScreen.y, 12, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1;
        
        // ç»˜åˆ¶é˜´å½±
        const shadowScale = this.player.isDashing ? 0.7 : 1;
        this.ctx.fillStyle = 'rgba(0,0,0,0.25)';
        this.ctx.beginPath();
        this.ctx.ellipse(playerScreen.x, playerScreen.y + 12, 10 * shadowScale, 3 * shadowScale, 0, 0, Math.PI * 2);
        this.ctx.fill();
        
        // ç»˜åˆ¶ç©å®¶ï¼ˆå¸¦åŠ¨ç”»ï¼‰
        const breathY = Math.sin(Date.now() / 300) * 1;
        const totalScreenY = playerScreen.y + (this.player.jumpY || 0) + breathY;
        const legOffset = Math.sin(this.player.walkCycle) * 4;
        
        const playerSprite = this.sprites.get('player');
        this.ctx.save();
        this.ctx.translate(playerScreen.x, totalScreenY);
        if (!this.player.facingRight) this.ctx.scale(-1, 1);
        
        if (playerSprite) {
            this.ctx.drawImage(playerSprite, -16, -16, 32, 32);
            // è…¿éƒ¨åŠ¨ç”»
            if (this.player.isMoving && !this.player.isDashing) {
                this.ctx.fillStyle = '#553322';
                this.ctx.fillRect(-6, 10, 4, 8 + Math.abs(legOffset));
                this.ctx.fillRect(2, 10, 4, 8 - Math.abs(legOffset));
            }
        } else {
            // ç¨‹åºåŒ–ç»˜åˆ¶
            this.ctx.fillStyle = '#e8e8e8';
            this.ctx.beginPath();
            this.ctx.ellipse(0, breathY, 13, 10, 0, 0, Math.PI * 2);
            this.ctx.fill();
            // çœ¼ç›
            this.ctx.fillStyle = '#333';
            this.ctx.beginPath();
            this.ctx.arc(12, -6 + breathY, 1.2, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.restore();
        
        // å†²åˆºç‰¹æ•ˆ
        if (this.player.isDashing) {
            this.ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
            this.ctx.lineWidth = 2;
            const dir = this.player.facingRight ? 1 : -1;
            for (let i = 0; i < 3; i++) {
                const offset = (Date.now() / 30 + i * 15) % 25;
                this.ctx.beginPath();
                this.ctx.moveTo(playerScreen.x - dir * (15 + offset), totalScreenY - 10 + i * 8);
                this.ctx.lineTo(playerScreen.x - dir * (25 + offset), totalScreenY - 10 + i * 8);
                this.ctx.stroke();
            }
        }
        
        this.particles.draw(this.ctx);
        
        if (this.transition.active) {
            const alpha = Math.sin(this.transition.timer / 0.3 * Math.PI);
            this.ctx.fillStyle = `rgba(0,0,0,${alpha})`;
            this.ctx.fillRect(0, 0, 900, 600);
        }
        
        // å•†åº—UI
        if (this.shopOpen) {
            this.drawShopUI();
        }
        
        // æ­¦å™¨è¿›åŒ–UI
        if (this.evolutionOpen) {
            this.drawEvolutionUI();
        }
        
        this.drawUI();
    }
    
    drawShopUI() {
        const ctx = this.ctx;
        const boxWidth = 500;
        const boxHeight = 350;
        const boxX = 450 - boxWidth / 2;
        const boxY = 300 - boxHeight / 2;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = '#4a4';
        ctx.lineWidth = 3;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        ctx.fillStyle = '#4f4';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ¦¯ ç›²çœ¼çš„å•†åº— ğŸ‘ï¸', 450, boxY + 40);
        
        ctx.fillStyle = '#fc0';
        ctx.font = '18px Arial';
        ctx.fillText(`ğŸ’° ${this.player.gold}`, 450, boxY + 70);
        
        const itemWidth = 130;
        const itemHeight = 160;
        const startX = 450 - (this.shopItems.length * itemWidth) / 2 + itemWidth / 2;
        
        this.shopItems.forEach((item, i) => {
            const ix = startX + i * (itemWidth + 20);
            const iy = boxY + 160;
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(ix - itemWidth/2, iy - itemHeight/2, itemWidth, itemHeight);
            ctx.strokeStyle = this.player.gold >= item.price ? '#4a4' : '#a44';
            ctx.lineWidth = 2;
            ctx.strokeRect(ix - itemWidth/2, iy - itemHeight/2, itemWidth, itemHeight);
            
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(item.icon, ix, iy - 20);
            
            ctx.fillStyle = '#fff';
            ctx.font = '14px Arial';
            ctx.fillText(item.name, ix, iy + 15);
            
            ctx.fillStyle = '#aaa';
            ctx.font = '11px Arial';
            ctx.fillText(item.desc, ix, iy + 35);
            
            ctx.fillStyle = this.player.gold >= item.price ? '#fc0' : '#f44';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`ğŸ’°${item.price}`, ix, iy + 60);
            
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.fillText(`[${i + 1}]`, ix, iy + 80);
        });
        
        ctx.fillStyle = '#888';
        ctx.font = '14px Arial';
        ctx.fillText('æŒ‰ 1-3 è´­ä¹° | æŒ‰ E å…³é—­', 450, boxY + boxHeight - 20);
    }
    
    drawEvolutionUI() {
        const ctx = this.ctx;
        const weapon = this.weapons[this.activeWeapon];
        if (!weapon) return;
        
        const boxWidth = 600;
        const boxHeight = 400;
        const boxX = 450 - boxWidth / 2;
        const boxY = 300 - boxHeight / 2;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = '#f0f';
        ctx.lineWidth = 3;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        ctx.fillStyle = '#f0f';
        ctx.font = 'bold 28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('âš”ï¸ æ­¦å™¨è¿›åŒ– âš”ï¸', 450, boxY + 40);
        
        // å½“å‰æ­¦å™¨
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.fillText(`å½“å‰: ${weapon.cfg.icon} ${weapon.cfg.name} (Lv.${weapon.level})`, 450, boxY + 80);
        
        // ææ–™æ˜¾ç¤º
        ctx.fillStyle = '#aaa';
        ctx.font = '14px Arial';
        const mats = this.materials.getAll();
        if (mats.length > 0) {
            let matText = 'ææ–™: ';
            mats.forEach((m, i) => {
                matText += `${m.icon}${m.count} `;
            });
            ctx.fillText(matText, 450, boxY + 110);
        } else {
            ctx.fillText('ææ–™: æ—  (å‡»è´¥æ•Œäººè·å¾—)', 450, boxY + 110);
        }
        
        // è¿›åŒ–é€‰é¡¹
        const evolutions = WEAPON_EVOLUTIONS[weapon.baseKey];
        if (evolutions) {
            const evoKeys = Object.keys(evolutions);
            const evoWidth = 160;
            const startX = 450 - (evoKeys.length * evoWidth) / 2 + evoWidth / 2;
            
            evoKeys.forEach((evoKey, i) => {
                const evo = evolutions[evoKey];
                const ix = startX + i * (evoWidth + 20);
                const iy = boxY + 220;
                
                // æ£€æŸ¥ææ–™æ˜¯å¦è¶³å¤Ÿ
                let canEvolve = true;
                for (const [mat, count] of Object.entries(evo.req)) {
                    if (!this.materials.has(mat, count)) {
                        canEvolve = false;
                        break;
                    }
                }
                
                ctx.fillStyle = canEvolve ? '#2a1a3a' : '#1a1a1a';
                ctx.fillRect(ix - evoWidth/2, iy - 70, evoWidth, 180);
                ctx.strokeStyle = canEvolve ? '#f0f' : '#444';
                ctx.lineWidth = 2;
                ctx.strokeRect(ix - evoWidth/2, iy - 70, evoWidth, 180);
                
                ctx.font = '40px Arial';
                ctx.fillText(evo.icon, ix, iy - 30);
                
                ctx.fillStyle = canEvolve ? '#fff' : '#666';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(evo.name, ix, iy);
                
                ctx.fillStyle = '#aaa';
                ctx.font = '12px Arial';
                ctx.fillText(evo.desc, ix, iy + 20);
                
                // ææ–™éœ€æ±‚
                ctx.fillStyle = '#888';
                ctx.font = '11px Arial';
                let reqY = iy + 45;
                for (const [mat, count] of Object.entries(evo.req)) {
                    const has = this.materials.getCount(mat);
                    const matInfo = MATERIALS[mat];
                    ctx.fillStyle = has >= count ? '#4f4' : '#f44';
                    ctx.fillText(`${matInfo.icon} ${has}/${count}`, ix, reqY);
                    reqY += 16;
                }
                
                ctx.fillStyle = '#666';
                ctx.font = '12px Arial';
                ctx.fillText(`[${i + 1}]`, ix, iy + 95);
            });
        }
        
        ctx.fillStyle = '#888';
        ctx.font = '14px Arial';
        ctx.fillText('æŒ‰ 1-3 é€‰æ‹©è¿›åŒ– | æŒ‰ V å…³é—­', 450, boxY + boxHeight - 20);
    }

    drawUI() {
        const ctx = this.ctx;
        const pad = 20;
        
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(pad, pad, 200, 130);
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('â¤ï¸'.repeat(Math.max(0, Math.ceil(this.player.hp))), pad + 10, pad + 35);
        
        ctx.fillStyle = '#48f';
        ctx.fillText(`Lv.${this.player.lv} EXP:${Math.floor(this.player.exp)}/${this.player.lv*100}`, pad + 10, pad + 60);
        
        ctx.fillStyle = '#fc0';
        ctx.fillText(`ğŸ’° ${this.player.gold}`, pad + 10, pad + 85);
        
        ctx.fillStyle = '#aaa';
        ctx.fillText(`ç¬¬ ${this.currentFloor}/${this.maxFloors} å±‚`, pad + 10, pad + 105);
        
        // æ˜¾ç¤ºææ–™æ•°é‡ï¼ˆç®€è¦ï¼‰
        const mats = this.materials.getAll();
        if (mats.length > 0) {
            ctx.fillStyle = '#f8f';
            ctx.font = '12px Arial';
            let matStr = '';
            mats.slice(0, 4).forEach(m => matStr += `${m.icon}${m.count} `);
            ctx.fillText(matStr, pad + 10, pad + 125);
        }
        
        if (this.godMode) {
            ctx.fillStyle = '#f0f';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('ğŸ‘‘ GOD MODE', pad + 10, pad + 145);
        }
        
        ctx.textAlign = 'right';
        ctx.fillStyle = '#fff';
        const names = { start: 'èµ·ç‚¹', normal: 'æˆ˜æ–—', boss: 'BOSS', treasure: 'å®ç®±', shop: 'å•†åº—', hidden: 'éšè—' };
        ctx.fillText(`${names[this.curRoom.type]}æˆ¿é—´`, 880, pad + 35);
        ctx.fillText(`æ•Œäºº:${this.curRoom.enemies.length}`, 880, pad + 60);
        
        if (!this.curRoom.cleared) {
            ctx.fillStyle = '#f44';
            ctx.fillText('ğŸ”’ é”å®š', 880, pad + 85);
        } else {
            ctx.fillStyle = '#4f4';
            ctx.fillText('âœ“ å·²æ¸…ç†', 880, pad + 85);
        }
        
        const mx = 750, my = 140;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(mx, my, 130, 130);
        
        for (const [, r] of this.allRooms) {
            if (!r.visited) continue;
            const rx = mx + 10 + (r.gx + 5) * 10;
            const ry = my + 10 + (r.gy + 5) * 10;
            ctx.fillStyle = r === this.curRoom ? '#ff0' : { normal: '#666', boss: '#f00', treasure: '#0f0', start: '#66f', shop: '#48f', hidden: '#f0f' }[r.type];
            ctx.fillRect(rx, ry, 8, 8);
        }
        
        const by = 530;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(pad, by, 350, 50);
        
        let wx = pad + 10;
        for (let i = 0; i < this.weapons.length; i++) {
            const w = this.weapons[i];
            ctx.fillStyle = i === this.activeWeapon ? '#444' : '#333';
            ctx.fillRect(wx, by + 5, 50, 40);
            
            ctx.fillStyle = w.getLevelColor();
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(w.cfg.icon, wx + 25, by + 32);
            
            if (w.level > 1 || w.evolution) {
                ctx.fillStyle = w.evolution ? '#f0f' : '#ff0';
                ctx.font = '10px Arial';
                ctx.fillText(w.evolution ? 'â˜…' : '+' + (w.level - 1), wx + 42, by + 15);
            }
            
            wx += 60;
        }
        
        const totemCount = this.totems.getCount();
        if (totemCount > 0) {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(370, by, 100, 50);
            ctx.fillStyle = '#fc0';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`å›¾è…¾: ${totemCount}/7`, 420, by + 20);
        }
        
        if (this.state === 'gameover') {
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, 900, 600);
            ctx.fillStyle = '#f44';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('æ¸¸æˆç»“æŸ', 450, 280);
            ctx.font = '24px Arial';
            ctx.fillStyle = '#fff';
            ctx.fillText(`åˆ°è¾¾å±‚æ•°: ${this.currentFloor} | é‡‘å¸: ${this.player.gold}`, 450, 340);
        }
        
        if (this.state === 'victory') {
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, 900, 600);
            ctx.fillStyle = '#4f4';
            ctx.font = 'bold 56px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸ‰ èƒœåˆ©! ğŸ‰', 450, 260);
        }
    }
    
    spawnRoomReward() {
        const roll = Math.random();
        if (this.curRoom.type === 'boss') {
            this.spawnWeaponPickup();
        } else if (this.curRoom.type === 'treasure') {
            this.spawnItemPickup();
        } else if (roll < 0.3) {
            this.spawnItemPickup();
        } else if (roll < 0.5) {
            this.spawnWeaponPickup();
        }
    }
    
    spawnItemPickup() {
        const itemId = randInt(1, 16);
        const item = ITEMS[itemId];
        if (!item) return;
        this.curRoom.items.push({ x: 450, y: 300, id: itemId, icon: item.icon, name: item.name });
    }
    
    spawnWeaponPickup() {
        const wKeys = Object.keys(WEAPONS);
        const randKey = wKeys[Math.floor(Math.random() * wKeys.length)];
        this.curRoom.items.push({
            x: 450, y: 300,
            type: 'weapon', weaponKey: randKey,
            icon: WEAPONS[randKey].icon, name: WEAPONS[randKey].name
        });
    }
    
    spawnTotemPickup() {
        const totemId = randInt(1, 8);
        const totem = TOTEMS[totemId];
        if (!totem) return;
        this.curRoom.items.push({
            x: 450, y: 300,
            type: 'totem', totemId: totemId,
            icon: totem.icon, name: totem.name
        });
    }

    loop(t) {
        const dt = Math.min((t - (this.lastT || t)) / 1000, 0.1);
        this.lastT = t;
        
        if (this.state === 'playing' || this.transition.active) {
            this.update(dt);
        }
        this.draw();
        
        this.rafId = requestAnimationFrame(t => this.loop(t));
    }
}

// å¯åŠ¨
window.onload = () => {
    const game = new Game();
    setTimeout(() => game.start(), 500);
};
</script>
</body>
</html>
