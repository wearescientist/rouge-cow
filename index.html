<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è‚‰é¸½ç‰›ç‰› - v0.9.0 å¹¸å­˜è€…æ¨¡å¼é‡æ„</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        html, body { 
            width: 100%; 
            height: 100%; 
            background: #0a0a14; 
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameCanvas { 
            display: block; 
            background: #0d0d1a;
            max-width: 100%;
            max-height: 100%;
        }
        #loading { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: #0a0a14; display: flex; flex-direction: column; 
            justify-content: center; align-items: center; z-index: 1000;
            transition: opacity 0.5s;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        .cow { font-size: 100px; animation: bounce 0.6s infinite alternate; }
        @keyframes bounce { from { transform: translateY(0) scale(1); } to { transform: translateY(-30px) scale(1.1); } }
        .loading-text { color: #4488ff; margin-top: 30px; font-size: 24px; font-family: Arial; }
        .loading-bar { width: 300px; height: 10px; background: #333; border-radius: 5px; margin-top: 20px; overflow: hidden; }
        .loading-progress { width: 0%; height: 100%; background: #4488ff; transition: width 0.3s; }
        .controls-hint { 
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #666; font-family: Arial; font-size: 14px; text-align: center;
            background: rgba(0,0,0,0.8); padding: 10px 20px; border-radius: 20px;
            z-index: 100;
        }
        .key { background: #333; color: #fff; padding: 2px 8px; border-radius: 4px; margin: 0 2px; }
        
        /* é€Ÿåº¦æ§åˆ¶æŒ‰é’® */
        #speedControl {
            position: fixed;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 200;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 20px;
            border: 1px solid #444;
        }
        .speed-btn {
            padding: 5px 12px;
            font-size: 12px;
            background: #333;
            color: #888;
            border: 1px solid #555;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: Arial, sans-serif;
        }
        .speed-btn:hover {
            background: #444;
            color: #fff;
        }
        .speed-btn.active {
            background: #4488ff;
            color: #fff;
            border-color: #4488ff;
            box-shadow: 0 0 10px rgba(68,136,255,0.5);
        }
        #speedLabel {
            position: fixed;
            top: 45px;
            right: 10px;
            color: #4488ff;
            font-size: 11px;
            font-family: Arial, sans-serif;
            z-index: 200;
        }
        
        /* ä¸»æ¸¸æˆå¸ƒå±€ - ä¸‰æ é“ºæ»¡å±å¹• */
        #mainLayout {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
            background: #0a0a14;
        }
        
        #mainLayout.active {
            display: flex;
            flex-direction: row;
        }
        
        #leftSidebar {
            width: 260px;
            height: 100%;
            background: rgba(10,10,20,0.95);
            border-right: 1px solid #222;
            padding: 15px 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-shrink: 0;
        }
        
        #centerGame {
            flex: 1;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #050508;
            position: relative;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            background: #0d0d1a;
            /* å¡«æ»¡å®¹å™¨ */
            width: 100%;
            height: 100%;
        }
        
        #rightSidebar {
            width: 260px;
            height: 100%;
            background: rgba(10,10,20,0.95);
            border-left: 1px solid #222;
            padding: 15px 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-shrink: 0;
        }
        
        /* ä¾§è¾¹æ åŒºå— */
        .sidebar-section {
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid #222;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid #333;
            color: #4f4;
        }
        
        #rightSidebar .section-title {
            color: #48f;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 6px 0;
            font-size: 13px;
        }
        
        .stat-label { 
            color: #888; 
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .stat-value { 
            color: #fff; 
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        
        .stat-value.hp { color: #f44; }
        .stat-value.lv { color: #48f; }
        .stat-value.gold { color: #fc0; }
        
        /* æ­¦å™¨åˆ—è¡¨ */
        .weapon-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .weapon-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            font-size: 12px;
            border: 1px solid transparent;
        }
        
        .weapon-item.active {
            border-color: #4f4;
            background: rgba(100,255,100,0.1);
        }
        
        .weapon-icon { font-size: 16px; }
        .weapon-name { flex: 1; }
        .weapon-lv {
            font-size: 10px;
            color: #888;
        }
        
        /* å°åœ°å›¾ */
        .mini-map-wrapper {
            width: 100%;
            aspect-ratio: 1;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #333;
        }
        
        #miniMapCanvas {
            width: 100%;
            height: 100%;
        }
        
        /* é“å…·æ ¼å­ */
        .item-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
        }
        
        .item-cell {
            aspect-ratio: 1;
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            border: 1px solid #222;
        }
        
        .item-cell.filled {
            background: rgba(100,100,100,0.2);
            border-color: #444;
        }
        
        /* é¡¶éƒ¨ä¸­å¤®åˆ†æ•° */
        #topScoreBar {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 10px 30px;
            border-radius: 10px;
            border: 2px solid #fa0;
            z-index: 300;
            text-align: center;
            display: none;
        }
        
        #scoreValue {
            color: #ff0;
            font-size: 28px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px rgba(255,255,0,0.5);
        }
        
        #killStreak {
            color: #f44;
            font-size: 12px;
            margin-top: 2px;
        }
        
        /* åº•éƒ¨çŠ¶æ€æ¡ */
        #bottomStatusBar {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 300;
            display: none;
        }
        
        .status-pill {
            background: rgba(0,0,0,0.8);
            padding: 6px 15px;
            border-radius: 15px;
            font-size: 12px;
            color: #aaa;
            border: 1px solid #333;
        }
        
        .status-pill span { color: #fff; font-weight: bold; }
    </style>
</head>
<body>
    <div id="loading">
        <div class="cow">ğŸ®</div>
        <div class="loading-text" id="loadingText">æ­£åœ¨åŠ è½½ç²¾çµå›¾èµ„æº...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>
    
    <div id="story" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#0a0a14; z-index:999; color:#fff; font-family:Arial; overflow-y:auto;">
        <div style="max-width:800px; margin:50px auto; padding:20px; line-height:1.8;">
            <h1 style="color:#4f4; text-align:center; margin-bottom:30px;">ğŸŒ¾ æ·±æ ¹ä¹‹ç–«</h1>
            <div id="storyContent" style="font-size:18px; color:#ccc;">
                <p style="margin-bottom:20px;">åœ¨<strong style="color:#fa0;">é’ç©—å¤§è‰åŸ</strong>çš„è…¹åœ°ï¼Œæµä¼ ç€ä¸€ä¸ªå¤è€çš„é¢„è¨€ï¼š</p>
                <p style="margin:20px 0; padding:20px; background:rgba(255,255,255,0.05); border-left:4px solid #fa0; font-style:italic;">"å½“å¤§åœ°å¼€å§‹æ¸´é¥®é²œè¡€ï¼Œæ ¹é¡»å°†åå™¬å¤©ç©ºã€‚å”¯æœ‰çŠ„è§’åˆºç ´é»‘æš—è€…ï¼Œæ–¹èƒ½å”¤é†’æ²‰ç¡çš„å¤ªé˜³ã€‚"</p>
                <p style="margin-bottom:20px;">ç‰›ç‰›å‡ºç”Ÿåœ¨<strong style="color:#48f;">è§’æ—éƒ¨è½</strong>ï¼Œä¸–ä»£å®ˆæŠ¤ç€è‰åŸçš„<strong style="color:#4f4;">çµè„‰èŠ‚ç‚¹</strong>â€”â€”åƒæ ¹åœ£æ‰€ã€‚</p>
                <p style="margin-bottom:20px;">ä½†åœ¨ä»–å¤–å‡ºä¿®è¡Œå½’æ¥æ—¶ï¼Œè‰åŸå·²å˜æˆä¸€ç‰‡æ­»å¯‚ã€‚éƒ¨è½ç©ºæ— ä¸€äººï¼Œåªæœ‰ä¸€ä¸ªé€šå¾€åœ°åº•çš„æ´ç©´ï¼Œæ•£å‘ç€è…çƒ‚çš„ç”œé¦™...</p>
                <p style="margin-bottom:20px;">ä»–å¬è§äº†åœ°åº•æ·±å¤„çš„å¿ƒè·³å£°ï¼Œè¿˜æœ‰æ¯äº²ç†Ÿæ‚‰çš„å“¼å”±ã€‚</p>
                <p style="margin-bottom:20px; color:#f44;">"ç­‰æˆ‘ï¼Œé˜¿å¦ˆã€‚"</p>
            </div>
            <div style="text-align:center; margin-top:40px;">
                <button id="startGameBtn" style="padding:15px 40px; font-size:20px; background:#4f4; color:#000; border:none; border-radius:8px; cursor:pointer;">è¸å…¥æ´ç©´</button>
            </div>
        </div>
    </div>
    
    <!-- ä¸»æ¸¸æˆå¸ƒå±€ï¼ˆä¸‰æ ï¼‰ -->
    <div id="mainLayout">
        <!-- å·¦ä¾§è¾¹æ  -->
        <div id="leftSidebar">
            <!-- è§’è‰²çŠ¶æ€ -->
            <div class="sidebar-section">
                <div class="section-title">ğŸ® è§’è‰²çŠ¶æ€</div>
                <div class="stat-row">
                    <span class="stat-label">â¤ï¸ ç”Ÿå‘½</span>
                    <span class="stat-value hp" id="sidebarHp">6/6</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">â­ ç­‰çº§</span>
                    <span class="stat-value lv" id="sidebarLv">Lv.1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ğŸ’° é‡‘å¸</span>
                    <span class="stat-value gold" id="sidebarGold">100</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ğŸ“ å±‚æ•°</span>
                    <span class="stat-value" id="sidebarFloor">1/6</span>
                </div>
            </div>
            
            <!-- æˆ˜æ–—å±æ€§ -->
            <div class="sidebar-section">
                <div class="section-title">âš”ï¸ æˆ˜æ–—å±æ€§</div>
                <div class="stat-row">
                    <span class="stat-label">ğŸ—¡ï¸ æ”»å‡»åŠ›</span>
                    <span class="stat-value" id="sidebarDmg">15</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ğŸ’¨ ç§»é€Ÿ</span>
                    <span class="stat-value" id="sidebarSpeed">100%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">âš¡ æ”»é€Ÿ</span>
                    <span class="stat-value" id="sidebarFireRate">100%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ğŸ¯ æš´å‡»</span>
                    <span class="stat-value" id="sidebarCrit">0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ğŸ›¡ï¸ æŠ¤ç”²</span>
                    <span class="stat-value" id="sidebarArmor">0</span>
                </div>
            </div>
            
            <!-- æ­¦å™¨åˆ—è¡¨ -->
            <div class="sidebar-section">
                <div class="section-title">ğŸ”« æ­¦å™¨è£…å¤‡</div>
                <div class="weapon-list" id="sidebarWeapons">
                    <!-- åŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
            
            <!-- ææ–™ -->
            <div class="sidebar-section">
                <div class="section-title">ğŸ’ ææ–™</div>
                <div id="sidebarMaterials">æš‚æ— </div>
            </div>
        </div>
        
        <!-- ä¸­é—´æ¸¸æˆåŒºåŸŸ -->
        <div id="centerGame">
            <canvas id="gameCanvas"></canvas>
        </div>
        
        <!-- å³ä¾§è¾¹æ  -->
        <div id="rightSidebar">
            <!-- ä»¥æ’’é£æ ¼å°åœ°å›¾ -->
            <div class="sidebar-section">
                <div class="section-title">ğŸ—ºï¸ åœ°å›¾</div>
                <div class="mini-map-wrapper">
                    <canvas id="miniMapCanvas" width="220" height="220"></canvas>
                </div>
                <div class="stat-row" style="margin-top:8px;">
                    <span class="stat-label">å½“å‰æˆ¿é—´</span>
                    <span class="stat-value" id="sidebarRoomType">èµ·ç‚¹</span>
                </div>
            </div>
            
            <!-- é“å…·èƒŒåŒ… -->
            <div class="sidebar-section">
                <div class="section-title">ğŸ’ é“å…·</div>
                <div class="item-grid" id="sidebarItems">
                    <!-- åŠ¨æ€ç”Ÿæˆ20æ ¼ -->
                </div>
            </div>
            
            <!-- æœ¬å±€ç»Ÿè®¡ -->
            <div class="sidebar-section">
                <div class="section-title">ğŸ“Š æœ¬å±€ç»Ÿè®¡</div>
                <div class="stat-row">
                    <span class="stat-label">ğŸ’¯ åˆ†æ•°</span>
                    <span class="stat-value gold" id="sidebarScore">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">âš”ï¸ å‡»æ€</span>
                    <span class="stat-value" id="sidebarKills">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ğŸšª æ¢ç´¢</span>
                    <span class="stat-value" id="sidebarRooms">0</span>
                </div>
            </div>
            
            <!-- æ“ä½œæç¤º -->
            <div class="sidebar-section controls-hint-section">
                <div class="section-title">âŒ¨ï¸ æ“ä½œ</div>
                <div class="controls-hint">
                    <div><span class="key">WASD</span> ç§»åŠ¨</div>
                    <div><span class="key">ç©ºæ ¼</span> å†²åˆº</div>
                    <div><span class="key">1-3</span> é€‰æ‹©</div>
                    <div><span class="key">E</span> å•†åº—</div>
                    <div><span class="key">V</span> è¿›åŒ–</div>
                    <div><span class="key">F</span> å…¨å±</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- é¡¶éƒ¨åˆ†æ•°æ¡ -->
    <div id="topScoreBar">
        <div id="scoreValue">0</div>
        <div id="killStreak" style="display:none">ğŸ”¥ è¿æ€ x<span id="streakCount">0</span></div>
    </div>
    
    <!-- åº•éƒ¨çŠ¶æ€æ¡ -->
    <div id="bottomStatusBar">
        <div class="status-pill">ç¬¬ <span id="bottomFloor">1</span> / <span id="bottomMaxFloor">6</span> å±‚</div>
        <div class="status-pill">æ•Œäºº: <span id="bottomEnemies">0</span></div>
        <div class="status-pill" id="bottomRoomStatus">âœ“ å·²æ¸…ç†</div>
    </div>
    
    <!-- é€Ÿåº¦æ§åˆ¶ -->
    <div id="speedControl">
        <button class="speed-btn" data-speed="1" onclick="window.game.setSpeed(1)">1x</button>
        <button class="speed-btn" data-speed="2" onclick="window.game.setSpeed(2)">2x</button>
        <button class="speed-btn" data-speed="5" onclick="window.game.setSpeed(5)">5x</button>
        <button class="speed-btn" data-speed="10" onclick="window.game.setSpeed(10)">10x</button>
    </div>
    

        <div class="stat-row">
            <span class="stat-label">å‡»æ€</span>
            <span class="stat-value" id="panelKills">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">æ¢ç´¢</span>
            <span class="stat-value" id="panelRooms">0</span>
        </div>
    </div>
    
    <!-- å±‚æ•°æŒ‡ç¤ºå™¨ -->
    <div class="floor-indicator" id="floorIndicator" style="display:none;">
        ç¬¬ <span id="currentFloor">1</span> / <span id="maxFloors">6</span> å±‚
    </div>

<script>
// ============================================================================
// è‚‰é¸½ç‰›ç‰› v0.9.0 å¹¸å­˜è€…æ¨¡å¼é‡æ„ - å…¨æ­¦å™¨åŒæ—¶æ”»å‡»+3é€‰1+åˆ·æ€ªé‡åš
// ============================================================================

const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
const dist = (x1, y1, x2, y2) => Math.sqrt((x2-x1)**2 + (y2-y1)**2);
const rand = (min, max) => Math.random() * (max - min) + min;
const randInt = (min, max) => Math.floor(rand(min, max));
const randChoice = (arr) => arr[Math.floor(Math.random() * arr.length)];

// ç²¾çµå›¾åŠ è½½å™¨
class SpriteLoader {
    constructor() {
        this.sprites = {};
        this.loaded = 0;
        this.total = 0;
        this.errors = [];
    }
    
    load(name, src) {
        this.total++;
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                this.sprites[name] = img;
                this.loaded++;
                console.log(`âœ“ Loaded: ${name}`);
                resolve(img);
            };
            
            img.onerror = () => {
                console.warn(`âœ— Failed to load: ${src}`);
                this.errors.push({ name, src });
                this.loaded++;
                resolve(null);
            };
            
            setTimeout(() => {
                if (!img.complete) {
                    console.warn(`â± Timeout: ${src}`);
                    this.errors.push({ name, src, timeout: true });
                    resolve(null);
                }
            }, 5000);
            
            img.src = src;
        });
    }
    
    get(name) { return this.sprites[name]; }
    has(name) { return name in this.sprites; }
    isReady() { return this.loaded >= this.total; }
    getProgress() { return this.total > 0 ? this.loaded / this.total : 1; }
    getErrorCount() { return this.errors.length; }
}

// ç²’å­ç³»ç»Ÿ
class ParticleSystem {
    constructor(max = 200) {
        this.pool = Array(max).fill(null).map(() => ({
            x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 1,
            color: '#fff', size: 4, active: false
        }));
        this.active = [];
    }

    emit(x, y, color, opts = {}) {
        const p = this.pool.find(p => !p.active) || this.pool[0];
        p.x = x; p.y = y; p.color = color; p.active = true;
        p.life = opts.life || 1; p.maxLife = p.life;
        p.size = opts.size || 4;
        const speed = opts.speed || 100;
        const angle = opts.angle != null ? opts.angle : Math.random() * Math.PI * 2;
        p.vx = Math.cos(angle) * speed;
        p.vy = Math.sin(angle) * speed;
        if (!this.active.includes(p)) this.active.push(p);
    }

    burst(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
            this.emit(x, y, color, { 
                speed: rand(50, 150), 
                life: rand(0.3, 0.8),
                size: rand(2, 5)
            });
        }
    }

    update(dt) {
        for (let i = this.active.length - 1; i >= 0; i--) {
            const p = this.active[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt;
            if (p.life <= 0) {
                p.active = false;
                this.active.splice(i, 1);
            }
        }
    }

    draw(ctx) {
        for (const p of this.active) {
            const alpha = p.life / p.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
        }
        ctx.globalAlpha = 1;
    }
}

// éŸ³æ•ˆç³»ç»Ÿ
class SoundManager {
    constructor() {
        this.ctx = null;
        this.enabled = true;
    }
    
    init() {
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn('Web Audio API not supported');
            this.enabled = false;
        }
    }
    
    play(type) {
        if (!this.enabled || !this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        switch(type) {
            case 'shoot':
                osc.frequency.value = 800;
                gain.gain.value = 0.1;
                osc.start();
                osc.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.stop(this.ctx.currentTime + 0.1);
                break;
            case 'hit':
                osc.frequency.value = 200;
                osc.type = 'square';
                gain.gain.value = 0.15;
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.stop(this.ctx.currentTime + 0.15);
                break;
            case 'kill':
                osc.frequency.value = 600;
                gain.gain.value = 0.2;
                osc.start();
                osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                osc.frequency.setValueAtTime(800, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.stop(this.ctx.currentTime + 0.3);
                break;
            case 'levelup':
                osc.frequency.value = 400;
                gain.gain.value = 0.25;
                osc.start();
                for (let i = 0; i < 5; i++) {
                    osc.frequency.setValueAtTime(400 + i * 100, this.ctx.currentTime + i * 0.05);
                }
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.stop(this.ctx.currentTime + 0.5);
                break;
            case 'evolve':
                osc.frequency.value = 300;
                gain.gain.value = 0.3;
                osc.start();
                for (let i = 0; i < 8; i++) {
                    osc.frequency.setValueAtTime(300 + i * 100, this.ctx.currentTime + i * 0.05);
                }
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.8);
                osc.stop(this.ctx.currentTime + 0.8);
                break;
            case 'buy':
                osc.frequency.value = 500;
                gain.gain.value = 0.2;
                osc.start();
                osc.frequency.setValueAtTime(500, this.ctx.currentTime);
                osc.frequency.setValueAtTime(700, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.stop(this.ctx.currentTime + 0.3);
                break;
        }
    }
}

// ææ–™ç³»ç»Ÿ
const MATERIALS = {
    fire: { name: 'ç«ç„°ç²¾å', icon: 'ğŸ”¥', color: '#f44' },
    ice: { name: 'å†°éœœç»“æ™¶', icon: 'â„ï¸', color: '#48f' },
    thunder: { name: 'é›·ç”µæ ¸å¿ƒ', icon: 'âš¡', color: '#fc0' },
    shadow: { name: 'æš—å½±ç¢ç‰‡', icon: 'ğŸŒ‘', color: '#848' },
    life: { name: 'ç”Ÿå‘½ç²¾å', icon: 'ğŸŒ¿', color: '#4f4' },
    steel: { name: 'é’¢é“ç¢ç‰‡', icon: 'ğŸ”©', color: '#888' },
    magic: { name: 'é­”æ³•ç²‰å°˜', icon: 'âœ¨', color: '#f8f' },
    ancient: { name: 'è¿œå¤é—ç‰©', icon: 'ğŸº', color: '#fa0' }
};

class MaterialManager {
    constructor() {
        this.materials = {};
        for (const key in MATERIALS) {
            this.materials[key] = 0;
        }
    }
    
    add(type, amount = 1) {
        if (this.materials[type] !== undefined) {
            this.materials[type] += amount;
            return true;
        }
        return false;
    }
    
    has(type, amount = 1) {
        return (this.materials[type] || 0) >= amount;
    }
    
    consume(type, amount = 1) {
        if (this.has(type, amount)) {
            this.materials[type] -= amount;
            return true;
        }
        return false;
    }
    
    getCount(type) {
        return this.materials[type] || 0;
    }
    
    getAll() {
        return Object.entries(this.materials)
            .filter(([_, count]) => count > 0)
            .map(([type, count]) => ({ ...MATERIALS[type], type, count }));
    }
}

// æ­¦å™¨è¿›åŒ–é…ç½®
const WEAPON_EVOLUTIONS = {
    whip: {
        fire: { 
            name: 'ç«ç„°é­', icon: 'ğŸ”¥', 
            req: { fire: 3 }, 
            bonus: { fireDmg: 5, color: '#f44' },
            desc: 'é™„åŠ ç«ç„°ä¼¤å®³'
        },
        thunder: { 
            name: 'é›·ç”µé­', icon: 'âš¡', 
            req: { thunder: 3 }, 
            bonus: { thunderDmg: 5, stunChance: 0.1, color: '#fc0' },
            desc: 'é›·ç”µä¼¤å®³+éº»ç—¹'
        },
        thorn: { 
            name: 'è†æ£˜é­', icon: 'ğŸŒ¿', 
            req: { life: 3 }, 
            bonus: { lifeSteal: 0.08, color: '#4f4' },
            desc: 'å¸è¡€æ•ˆæœ'
        }
    },
    wand: {
        ice: { 
            name: 'å†°éœœé­”æ–', icon: 'â„ï¸', 
            req: { ice: 3 }, 
            bonus: { slowChance: 0.2, slowAmount: 0.3, color: '#48f' },
            desc: 'å‡é€Ÿæ•ˆæœ'
        },
        arcane: { 
            name: 'å¥¥æ•°é­”æ–', icon: 'âœ¨', 
            req: { magic: 3 }, 
            bonus: { pierce: 2, color: '#f8f' },
            desc: 'ç©¿é€+2'
        },
        life: { 
            name: 'ç”Ÿå‘½é­”æ–', icon: 'ğŸ’š', 
            req: { life: 3 }, 
            bonus: { healOnHit: 1, color: '#4f4' },
            desc: 'æ”»å‡»å›è¡€'
        }
    },
    knife: {
        poison: { 
            name: 'æ¯’åˆƒ', icon: 'â˜ ï¸', 
            req: { shadow: 2, life: 1 }, 
            bonus: { poisonDmg: 3, poisonDuration: 3, color: '#4a4' },
            desc: 'ä¸­æ¯’æ•ˆæœ'
        },
        shadow: { 
            name: 'æš—å½±é£åˆ€', icon: 'ğŸŒ‘', 
            req: { shadow: 3 }, 
            bonus: { critChance: 0.15, color: '#848' },
            desc: 'æš´å‡»ç‡æå‡'
        },
        steel: { 
            name: 'ç²¾é’¢é£åˆ€', icon: 'ğŸ”ª', 
            req: { steel: 3 }, 
            bonus: { dmg: 1.3, pierce: 1, color: '#ccc' },
            desc: 'ä¼¤å®³+ç©¿é€'
        }
    },
    axe: {
        war: { 
            name: 'æˆ˜æ–§', icon: 'ğŸª“', 
            req: { steel: 3 }, 
            bonus: { dmg: 1.4, color: '#a52' },
            desc: 'ä¼¤å®³æå‡'
        },
        throwing: { 
            name: 'æŠ•æ·æ–§', icon: 'ğŸ¯', 
            req: { steel: 2, magic: 1 }, 
            bonus: { range: 1.5, speed: 1.2, color: '#8b4513' },
            desc: 'å°„ç¨‹+é€Ÿåº¦'
        },
        curse: { 
            name: 'è¯…å’’æ–§', icon: 'ğŸ’€', 
            req: { shadow: 2, ancient: 1 }, 
            bonus: { curseDmg: 5, color: '#404' },
            desc: 'è¯…å’’ä¼¤å®³'
        }
    },
    // æ–°å¢æ­¦å™¨è¿›åŒ–ï¼ˆç¬¬2æ¬¡è¿­ä»£ï¼‰
    bible: {
        eternal: { 
            name: 'ä¸æ´æ™šç¥·', icon: 'ğŸ“œ', 
            req: { magic: 2, life: 1 }, 
            bonus: { duration: 2, color: '#ffd700' },
            desc: 'ç¯ç»•æ—¶é—´å»¶é•¿'
        },
        shield: { 
            name: 'å®ˆæŠ¤åœ£ç»', icon: 'ğŸ›¡ï¸', 
            req: { steel: 2, life: 1 }, 
            bonus: { block: 1, color: '#c0c0c0' },
            desc: 'å¯æ ¼æŒ¡å­å¼¹'
        }
    },
    fireball: {
        inferno: { 
            name: 'åœ°ç‹±ç«', icon: 'ğŸŒ‹', 
            req: { fire: 3 }, 
            bonus: { explosion: 1.5, color: '#ff0000' },
            desc: 'çˆ†ç‚¸èŒƒå›´+50%'
        },
        meteor: { 
            name: 'é™¨çŸ³æœ¯', icon: 'â˜„ï¸', 
            req: { fire: 2, ancient: 1 }, 
            bonus: { dmg: 1.5, cd: 1.3, color: '#ff4500' },
            desc: 'ä¼¤å®³+50% å†·å´+30%'
        }
    },
    lightning: {
        chain: { 
            name: 'é›·éœ†å¾ªç¯', icon: 'â›“ï¸', 
            req: { thunder: 3 }, 
            bonus: { chain: 3, color: '#ffff00' },
            desc: 'è¿é”+3ç›®æ ‡'
        },
        storm: { 
            name: 'é›·æš´', icon: 'ğŸŒ©ï¸', 
            req: { thunder: 2, wind: 1 }, 
            bonus: { aoe: 1, color: '#9400d3' },
            desc: 'èŒƒå›´ä¼¤å®³'
        }
    },
    holy_water: {
        tracking: { 
            name: 'æ’’æ‹‰é€Šä¹‹æ°´', icon: 'ğŸ¯', 
            req: { magic: 2, water: 1 }, 
            bonus: { homing: 0.5, color: '#00ffff' },
            desc: 'è¿½è¸ªæ•Œäºº'
        },
        healing: { 
            name: 'åœ£ç–—ä¹‹æ°´', icon: 'ğŸ’š', 
            req: { life: 3 }, 
            bonus: { heal: 2, color: '#00ff00' },
            desc: 'ç«™åœ¨åŒºåŸŸå†…å›è¡€'
        }
    }
};

// é“å…·æ•°æ®åº“
const ITEMS = {
    1: { id: 1, name: 'å¤šé‡å°„å‡»', icon: 'ğŸ¯', rarity: 'common', effect: 'projCount', value: 1, desc: 'å­å¼¹+1', price: 40 },
    2: { id: 2, name: 'å·¨å¤§åŒ–', icon: 'ğŸ“', rarity: 'common', effect: 'projSize', value: 0.3, desc: 'å­å¼¹å˜å¤§', price: 35 },
    3: { id: 3, name: 'å¿«é€Ÿå°„å‡»', icon: 'âš¡', rarity: 'common', effect: 'fireRate', value: 0.15, desc: 'å°„é€Ÿ+15%', price: 45 },
    4: { id: 4, name: 'ç©¿ç”²å¼¹', icon: 'ğŸ”©', rarity: 'rare', effect: 'pierce', value: 1, desc: 'ç©¿é€+1', price: 80 },
    5: { id: 5, name: 'æš´å‡»é•œç‰‡', icon: 'ğŸ”', rarity: 'rare', effect: 'crit', value: 0.1, desc: 'æš´å‡»+10%', price: 75 },
    6: { id: 6, name: 'å¿ƒä¹‹å®¹å™¨', icon: 'â¤ï¸', rarity: 'common', effect: 'maxHp', value: 2, desc: 'ç”Ÿå‘½+2', price: 50 },
    7: { id: 7, name: 'é’¢é“æŠ¤ç”²', icon: 'ğŸ›¡ï¸', rarity: 'rare', effect: 'armor', value: 1, desc: 'æŠ¤ç”²+1', price: 85 },
    8: { id: 8, name: 'å¸è¡€ç ç‰™', icon: 'ğŸ¦·', rarity: 'rare', effect: 'lifeSteal', value: 0.05, desc: 'å¸è¡€5%', price: 90 },
    9: { id: 9, name: 'åŠ é€Ÿé´', icon: 'ğŸ‘Ÿ', rarity: 'common', effect: 'speed', value: 0.2, desc: 'ç§»é€Ÿ+20%', price: 40 },
    10: { id: 10, name: 'é£è¡Œç¿…è†€', icon: 'ğŸ¦…', rarity: 'epic', effect: 'fly', value: 1, desc: 'å¯ä»¥é£è¡Œ', price: 150 },
    11: { id: 11, name: 'ç£é“', icon: 'ğŸ§²', rarity: 'rare', effect: 'magnet', value: 50, desc: 'å¸èŒƒå›´+50', price: 70 },
    12: { id: 12, name: 'é‡‘è›‹', icon: 'ğŸ¥š', rarity: 'epic', effect: 'goldBonus', value: 0.5, desc: 'é‡‘å¸+50%', price: 120 },
    13: { id: 13, name: 'ç«ç„°é™„é­”', icon: 'ğŸ”¥', rarity: 'rare', effect: 'fireDmg', value: 5, desc: 'ç«ç„°ä¼¤å®³+5', price: 85 },
    14: { id: 14, name: 'å†°å†»æ ¸å¿ƒ', icon: 'â„ï¸', rarity: 'rare', effect: 'slow', value: 0.2, desc: 'å‡é€Ÿæ•Œäºº20%', price: 80 },
    15: { id: 15, name: 'é›·ç”µå®ç ', icon: 'âš¡', rarity: 'epic', effect: 'chain', value: 1, desc: 'è¿é”æ”»å‡»+1', price: 140 },
    // v0.8.0 æœ€ç»ˆæ•´åˆ
    16: { id: 16, name: 'ç‹‚æš´ä¹‹è¡€', icon: 'ğŸ©¸', rarity: 'rare', effect: 'crit', value: 0.1, desc: 'æš´å‡»ç‡+10%', price: 80 },
    17: { id: 17, name: 'çˆ†ç‚¸å¼¹', icon: 'ğŸ’£', rarity: 'rare', effect: 'fireDmg', value: 5, desc: 'çˆ†ç‚¸ä¼¤å®³+5', price: 90 },
    18: { id: 18, name: 'å†°å†»å¼¹', icon: 'ğŸ§Š', rarity: 'rare', effect: 'slow', value: 0.2, desc: 'å‡é€Ÿæ•ˆæœ+20%', price: 85 },
    19: { id: 19, name: 'æŠ¤ç›¾å‘ç”Ÿå™¨', icon: 'ğŸ›¡ï¸', rarity: 'rare', effect: 'armor', value: 2, desc: 'æŠ¤ç”²+2', price: 100 },
    20: { id: 20, name: 'å¤æ´»å¸', icon: 'ğŸª™', rarity: 'legendary', effect: 'maxHp', value: 2, desc: 'ç”Ÿå‘½ä¸Šé™+2', price: 300 },
    21: { id: 21, name: 'ç»éªŒä¹¦', icon: 'ğŸ“š', rarity: 'common', effect: 'speed', value: 0.1, desc: 'ç§»é€Ÿ+10%', price: 40 },
    22: { id: 22, name: 'é‡‘ç£é“', icon: 'ğŸ§²', rarity: 'rare', effect: 'magnet', value: 80, desc: 'æ‹¾å–èŒƒå›´+80', price: 75 },
    23: { id: 23, name: 'ç–¾é£é´', icon: 'ğŸ‘¢', rarity: 'epic', effect: 'speed', value: 0.3, desc: 'ç§»é€Ÿ+30%', price: 140 },
    24: { id: 24, name: 'å¤©ä½¿ç¥ç¦', icon: 'ğŸ‘¼', rarity: 'legendary', effect: 'maxHp', value: 3, desc: 'ç”Ÿå‘½+3', price: 350 },
    25: { id: 25, name: 'é»‘æ´æ ¸å¿ƒ', icon: 'ğŸ•³ï¸', rarity: 'legendary', effect: 'magnet', value: 200, desc: 'æ‹¾å–èŒƒå›´+200', price: 400 },
    26: { id: 26, name: 'é›·ç”µä¹‹åˆƒ', icon: 'âš¡', rarity: 'epic', effect: 'chain', value: 1, desc: 'è¿é”æ”»å‡»+1', price: 140 },
    // ç¬¬1æ¬¡è¿­ä»£ï¼šæ–°å¢24ä¸ªé“å…· (27-50)
    // æ”»å‡»ç±»æ‰©å±•
    27: { id: 27, name: 'éœ°å¼¹æ‰©æ•£', icon: 'ğŸ“¦', rarity: 'common', effect: 'spread', value: 15, desc: 'æ•£å°„è§’åº¦+15Â°', price: 35 },
    28: { id: 28, name: 'è¿½è¸ªèŠ¯ç‰‡', icon: 'ğŸ§¿', rarity: 'rare', effect: 'homing', value: 0.3, desc: 'è¿½è¸ªå¼ºåº¦+30%', price: 95 },
    29: { id: 29, name: 'å¼¹è·³å­å¼¹', icon: 'ğŸ±', rarity: 'rare', effect: 'bounce', value: 1, desc: 'å¼¹è·³+1æ¬¡', price: 85 },
    30: { id: 30, name: 'æ¯’æ¶²æ¶‚å±‚çš„', icon: 'ğŸ§ª', rarity: 'rare', effect: 'poisonDmg', value: 3, desc: 'æ¯’ä¼¤å®³+3/ç§’', price: 80 },
    31: { id: 31, name: 'ç‹™å‡»é•œ', icon: 'ğŸ”­', rarity: 'epic', effect: 'critDmg', value: 0.5, desc: 'æš´å‡»ä¼¤å®³+50%', price: 130 },
    32: { id: 32, name: 'è¿å‘è£…ç½®', icon: 'ğŸ”«', rarity: 'epic', effect: 'burst', value: 1, desc: 'è¿å°„+1å‘', price: 150 },
    // é˜²å¾¡ç±»æ‰©å±•
    33: { id: 33, name: 'å†ç”Ÿå› å­', icon: 'ğŸ§¬', rarity: 'rare', effect: 'regen', value: 0.5, desc: 'æ¯ç§’å›å¤0.5HP', price: 100 },
    34: { id: 34, name: 'è†æ£˜æŠ¤ç”²', icon: 'ğŸŒµ', rarity: 'rare', effect: 'thorn', value: 2, desc: 'åå¼¹2ç‚¹ä¼¤å®³', price: 90 },
    35: { id: 35, name: 'é—ªé¿é´', icon: 'ğŸ‘»', rarity: 'epic', effect: 'dodge', value: 0.1, desc: 'é—ªé¿+10%', price: 130 },
    36: { id: 36, name: 'ç¥åœ£æŠ¤ç›¾', icon: 'âœ¨', rarity: 'legendary', effect: 'shield', value: 1, desc: 'å…ä¼¤ç›¾+1å±‚', price: 300 },
    37: { id: 37, name: 'ä¸æœ½ä¹‹å¿ƒ', icon: 'ğŸ’', rarity: 'legendary', effect: 'revive', value: 1, desc: 'æ­»äº¡æ—¶å¤æ´»ä¸€æ¬¡', price: 500 },
    // ç§»åŠ¨ç±»æ‰©å±•
    38: { id: 38, name: 'ç¬ç§»è£…ç½®', icon: 'ğŸŒ€', rarity: 'epic', effect: 'dashDist', value: 0.5, desc: 'å†²åˆºè·ç¦»+50%', price: 120 },
    39: { id: 39, name: 'æ—¶é—´æ€€è¡¨', icon: 'â±ï¸', rarity: 'legendary', effect: 'slowTime', value: 0.2, desc: 'å­å¼¹æ—¶é—´20%', price: 400 },
    // èµ„æºç±»æ‰©å±•
    40: { id: 40, name: 'å¹¸è¿å¸', icon: 'ğŸ€', rarity: 'rare', effect: 'luck', value: 0.2, desc: 'å¹¸è¿+20%', price: 110 },
    41: { id: 41, name: 'è´ªå©ªä¹‹æ‰‹', icon: 'ğŸ¤²', rarity: 'rare', effect: 'goldOnKill', value: 2, desc: 'å‡»æ€é‡‘å¸+2', price: 95 },
    42: { id: 42, name: 'ç»éªŒåŠ æˆ', icon: 'ğŸ“ˆ', rarity: 'common', effect: 'expBonus', value: 0.2, desc: 'ç»éªŒ+20%', price: 45 },
    43: { id: 43, name: 'é‡‡é›†å™¨', icon: 'ğŸ“¡', rarity: 'epic', effect: 'pickupRange', value: 50, desc: 'æ‹¾å–èŒƒå›´+50', price: 125 },
    // å¬å”¤ç±»
    44: { id: 44, name: 'å°ç²¾çµ', icon: 'ğŸ§š', rarity: 'rare', effect: 'fairy', value: 1, desc: 'å°ç²¾çµè·Ÿéšå°„å‡»', price: 140 },
    45: { id: 45, name: 'å®ˆæŠ¤çƒ', icon: 'ğŸ”®', rarity: 'epic', effect: 'orbit', value: 1, desc: 'ç¯ç»•æ”»å‡»çƒ+1', price: 160 },
    46: { id: 46, name: 'å® ç‰©é¾™', icon: 'ğŸ‰', rarity: 'legendary', effect: 'dragon', value: 1, desc: 'å–·ç«å¹¼é¾™è·Ÿéš', price: 450 },
    // è¯…å’’ç±»ï¼ˆé«˜é£é™©é«˜å›æŠ¥ï¼‰
    47: { id: 47, name: 'ç‹‚æš´æ¨¡å¼', icon: 'ğŸ˜ˆ', rarity: 'cursed', effect: 'glassCannon', value: 1, desc: 'ä¼¤å®³+50% ç”Ÿå‘½-30%', price: 0 },
    48: { id: 48, name: 'çŒ®ç¥­ä¹‹å¿ƒ', icon: 'ğŸ’”', rarity: 'cursed', effect: 'bloodMoney', value: 1, desc: 'é‡‘å¸+100% æ¯ç§’æ‰£è¡€', price: 0 },
    // ç‰¹æ®Šé“å…·
    49: { id: 49, name: 'ç›²çœ¼èƒå–æ¶²', icon: 'ğŸ§´', rarity: 'legendary', effect: 'invincible', value: 3, desc: '3ç§’æ— æ•Œæ—¶é—´', price: 350 },
    50: { id: 50, name: 'å›¾è…¾éª¨ç‰‡', icon: 'ğŸ¦´', rarity: 'legendary', effect: 'upgradeAll', value: 1, desc: 'å…¨å±æ€§+10%', price: 600 }
};

function getItemPrice(itemId) {
    const item = ITEMS[itemId];
    if (!item) return 100;
    const basePrice = item.price || 50;
    const variance = basePrice * 0.2;
    return Math.floor(basePrice + rand(-variance, variance));
}

class ItemManager {
    constructor(player) {
        this.player = player;
        this.owned = {};
        this.cache = null;
        this.dirty = true;
    }

    add(id) {
        const item = ITEMS[id];
        if (!item) return false;
        this.owned[id] = (this.owned[id] || 0) + 1;
        this.dirty = true;
        
        if (item.effect === 'maxHp') {
            this.player.maxHp += item.value;
            this.player.hp += item.value;
        }
        return true;
    }

    getStats() {
        if (!this.dirty) return this.cache;
        
        const s = {
            // åŸºç¡€å±æ€§
            projCount: 1, projSize: 1, fireRate: 1, pierce: 0,
            crit: 0, critDmg: 1.5, maxHp: 0, armor: 0, lifeSteal: 0,
            speed: 1, fly: false, magnet: 100, goldBonus: 1,
            // ä¼¤å®³ç±»å‹
            fireDmg: 0, thunderDmg: 0, poisonDmg: 0, curseDmg: 0,
            // æ§åˆ¶æ•ˆæœ
            slowChance: 0, slowAmount: 0, stunChance: 0,
            // æ–°å±æ€§ï¼ˆç¬¬1æ¬¡è¿­ä»£ï¼‰
            spread: 0, homing: 0, bounce: 0, burst: 0,
            regen: 0, thorn: 0, dodge: 0, shield: 0, revive: 0,
            dashDist: 1, slowTime: 0, luck: 0, goldOnKill: 0, expBonus: 0,
            pickupRange: 0, fairy: 0, orbit: 0, dragon: 0,
            glassCannon: 0, bloodMoney: 0, invincible: 0, upgradeAll: 0,
            // æ²»ç–—
            healOnHit: 0
        };
        
        for (const [id, count] of Object.entries(this.owned)) {
            const item = ITEMS[id];
            if (!item) continue;
            const v = item.value * count;
            
            switch (item.effect) {
                // åŸºç¡€æ”»å‡»
                case 'projCount': s.projCount += v; break;
                case 'projSize': s.projSize += v; break;
                case 'fireRate': s.fireRate *= (1 + v); break;
                case 'pierce': s.pierce += v; break;
                case 'crit': s.crit = Math.min(1, s.crit + v); break;
                case 'critDmg': s.critDmg += v; break;
                // é˜²å¾¡
                case 'maxHp': s.maxHp += v; break;
                case 'armor': s.armor += v; break;
                case 'lifeSteal': s.lifeSteal += v; break;
                case 'regen': s.regen += v; break;
                case 'thorn': s.thorn += v; break;
                case 'dodge': s.dodge = Math.min(0.5, s.dodge + v); break;
                case 'shield': s.shield += v; break;
                case 'revive': s.revive += v; break;
                // ç§»åŠ¨
                case 'speed': s.speed += v; break;
                case 'fly': s.fly = true; break;
                case 'dashDist': s.dashDist += v; break;
                case 'slowTime': s.slowTime += v; break;
                // èµ„æº
                case 'magnet': s.magnet += v; break;
                case 'goldBonus': s.goldBonus += v; break;
                case 'luck': s.luck += v; break;
                case 'goldOnKill': s.goldOnKill += v; break;
                case 'expBonus': s.expBonus += v; break;
                case 'pickupRange': s.pickupRange += v; break;
                // ä¼¤å®³ç±»å‹
                case 'fireDmg': s.fireDmg += v; break;
                case 'thunderDmg': s.thunderDmg += v; break;
                case 'poisonDmg': s.poisonDmg += v; break;
                case 'curseDmg': s.curseDmg += v; break;
                case 'slow': s.slowAmount += v; break;
                case 'chain': s.chain = (s.chain || 0) + v; break;
                // ç‰¹æ®Šæ•ˆæœ
                case 'spread': s.spread += v; break;
                case 'homing': s.homing += v; break;
                case 'bounce': s.bounce += v; break;
                case 'burst': s.burst += v; break;
                // å¬å”¤
                case 'fairy': s.fairy += v; break;
                case 'orbit': s.orbit += v; break;
                case 'dragon': s.dragon += v; break;
                // è¯…å’’
                case 'glassCannon': s.glassCannon += v; break;
                case 'bloodMoney': s.bloodMoney += v; break;
                // ç‰¹æ®Š
                case 'invincible': s.invincible += v; break;
                case 'upgradeAll': s.upgradeAll += v; break;
            }
        }
        
        // è¯…å’’æ•ˆæœå¤„ç†
        if (s.glassCannon > 0) {
            s.fireRate *= 1.5;
            s.maxHp *= 0.7;
        }
        if (s.bloodMoney > 0) {
            s.goldBonus *= 2;
        }
        if (s.upgradeAll > 0) {
            s.speed *= 1.1;
            s.fireRate *= 1.1;
            s.crit = Math.min(1, s.crit * 1.1 + 0.1);
        }
        
        this.cache = s;
        this.dirty = false;
        return s;
    }

    has(id) { return (this.owned[id] || 0) > 0; }
    count(id) { return this.owned[id] || 0; }
}

// æ­¦å™¨ç³»ç»Ÿ - æ”¯æŒè¿›åŒ–
const WEAPONS = {
    // åŸæœ‰4ç§æ­¦å™¨
    whip: { key: 'whip', name: 'é­å­', icon: 'ğŸª„', dmg: 20, cd: 1.0, range: 100, type: 'melee', color: '#f60' },
    wand: { key: 'wand', name: 'é­”æ–', icon: 'ğŸ”®', dmg: 15, cd: 0.6, speed: 300, type: 'proj', color: '#48f' },
    knife: { key: 'knife', name: 'é£åˆ€', icon: 'ğŸ—¡ï¸', dmg: 12, cd: 0.4, speed: 400, pierce: 3, type: 'proj', color: '#ccc' },
    axe: { key: 'axe', name: 'æ–§å¤´', dmg: 25, cd: 1.2, speed: 250, type: 'proj', color: '#8b4513' },
    // æ–°å¢4ç§æ­¦å™¨ï¼ˆç¬¬2æ¬¡è¿­ä»£ï¼‰
    bible: { key: 'bible', name: 'åœ£ç»', icon: 'ğŸ“–', dmg: 10, cd: 0.8, range: 80, type: 'orbit', color: '#ffd700' },
    fireball: { key: 'fireball', name: 'ç«çƒ', icon: 'ğŸ”¥', dmg: 30, cd: 1.5, speed: 200, type: 'proj', color: '#ff4500' },
    lightning: { key: 'lightning', name: 'é—ªç”µ', icon: 'âš¡', dmg: 18, cd: 0.5, range: 150, type: 'instant', color: '#ffff00' },
    holy_water: { key: 'holy_water', name: 'åœ£æ°´', icon: 'ğŸ’§', dmg: 8, cd: 1.0, range: 60, type: 'area', color: '#00bfff' }
};

class Weapon {
    constructor(key, level = 1, evolution = null) {
        this.baseKey = key;
        this.cfg = { ...WEAPONS[key] };
        this.level = level;
        this.evolution = evolution;
        this.cd = 0;
        this.xp = 0;
        this.xpToNext = 100;
        
        // åº”ç”¨è¿›åŒ–å±æ€§
        if (evolution) {
            const evoData = WEAPON_EVOLUTIONS[key]?.[evolution];
            if (evoData) {
                this.cfg.name = evoData.name;
                this.cfg.icon = evoData.icon;
                this.cfg.color = evoData.bonus.color || this.cfg.color;
                // åº”ç”¨å±æ€§åŠ æˆ
                if (evoData.bonus.dmg) this.cfg.dmg *= evoData.bonus.dmg;
                if (evoData.bonus.range) this.cfg.range *= evoData.bonus.range;
                if (evoData.bonus.speed) this.cfg.speed *= evoData.bonus.speed;
                if (evoData.bonus.pierce) this.cfg.pierce = (this.cfg.pierce || 0) + evoData.bonus.pierce;
            }
        }
    }
    
    getDamage(stats) { 
        let dmg = this.cfg.dmg * (1 + (this.level - 1) * 0.15) * stats.projSize;
        return dmg;
    }
    
    update(dt) { this.cd -= dt; }
    canFire() { return this.cd <= 0; }
    
    addXp(amount) {
        this.xp += amount;
        if (this.xp >= this.xpToNext) {
            this.xp -= this.xpToNext;
            this.level++;
            this.xpToNext = Math.floor(this.xpToNext * 1.5);
            return true;
        }
        return false;
    }
    
    getLevelColor() {
        if (this.evolution) return '#f0f'; // è¿›åŒ–æ­¦å™¨ç´«è‰²
        if (this.level >= 5) return '#fa0';
        if (this.level >= 3) return '#0ff';
        if (this.level >= 2) return '#fff';
        return '#aaa';
    }
    
    fire(player, target, stats) {
        this.cd = this.cfg.cd / stats.fireRate;
        const bullets = [];
        const count = Math.floor(stats.projCount);
        
        for (let i = 0; i < count; i++) {
            let angle = 0;
            if (target) {
                angle = Math.atan2(target.y - player.y, target.x - player.x);
                if (count > 1) angle += (i - (count - 1) / 2) * 0.15;
            } else {
                angle = Math.random() * Math.PI * 2;
            }
            
            bullets.push({
                x: player.x, y: player.y,
                vx: Math.cos(angle) * (this.cfg.speed || 200),
                vy: Math.sin(angle) * (this.cfg.speed || 200),
                dmg: this.getDamage(stats),
                color: this.cfg.color,
                icon: this.cfg.icon,  // æ·»åŠ æ­¦å™¨å›¾æ ‡
                life: this.cfg.type === 'melee' ? 0.3 : 3,
                pierce: (this.cfg.pierce || 0) + stats.pierce,
                type: this.cfg.type,
                range: this.cfg.range,
                hits: new Set(),
                homing: this.cfg.type !== 'melee',
                target: target,
                weapon: this
            });
        }
        return bullets;
    }
}

// æ•Œäººé…ç½®ï¼ˆç¬¬3æ¬¡è¿­ä»£ï¼š10â†’22ç§ï¼‰
const ENEMY_TYPES = {
    // === Tier 1: å¼±å°æ•Œäºº ===
    chick: { name: 'å˜å¼‚å°é¸¡', hp: 8, speed: 160, dmg: 1, exp: 2, gold: 3, color: '#ff6', sprite: 'chick' },
    mouse: { name: 'æ„ŸæŸ“è€é¼ ', hp: 6, speed: 200, dmg: 1, exp: 2, gold: 2, color: '#888', sprite: 'mouse' },
    snail: { name: 'å¯„ç”Ÿèœ—ç‰›', hp: 15, speed: 40, dmg: 1, exp: 1, gold: 2, color: '#8a8', sprite: 'snail' },
    
    // === Tier 2: æ™®é€šæ•Œäºº ===
    rabbit: { name: 'ç‹‚æš´å…”å­', hp: 12, speed: 180, dmg: 2, exp: 3, gold: 4, color: '#f99', sprite: 'rabbit' },
    bird: { name: 'æ„ŸæŸ“å°é¸Ÿ', hp: 10, speed: 240, dmg: 1, exp: 3, gold: 4, color: '#9cf', sprite: 'bird' },
    pigeon: { name: 'å˜å¼‚é¸½å­', hp: 14, speed: 140, dmg: 2, exp: 3, gold: 5, color: '#ccc', sprite: 'pigeon' },
    
    // === Tier 3: æ ‡å‡†æ•Œäºº ===
    cat: { name: 'å˜å¼‚çŒ«', hp: 18, speed: 190, dmg: 2, exp: 4, gold: 6, color: '#fa3', sprite: 'cat' },
    duck: { name: 'æ„ŸæŸ“é¸­å­', hp: 16, speed: 120, dmg: 2, exp: 4, gold: 5, color: '#ff0', sprite: 'duck' },
    squirrel: { name: 'ç–¯ç‹‚æ¾é¼ ', hp: 14, speed: 220, dmg: 2, exp: 4, gold: 6, color: '#963', sprite: 'squirrel' },
    
    // === Tier 4: è¾ƒå¼ºæ•Œäºº ===
    dog: { name: 'ç–¯ç‹—', hp: 22, speed: 210, dmg: 3, exp: 6, gold: 8, color: '#963', sprite: 'dog' },
    pig: { name: 'å˜å¼‚å°çŒª', hp: 28, speed: 90, dmg: 3, exp: 6, gold: 9, color: '#f9c', sprite: 'pig' },
    sheep: { name: 'å˜å¼‚å°ç¾Š', hp: 24, speed: 110, dmg: 2, exp: 5, gold: 7, color: '#eee', sprite: 'sheep' },
    goose: { name: 'å®ˆå«é¹…', hp: 30, speed: 160, dmg: 3, exp: 7, gold: 10, color: '#fff', sprite: 'goose', special: 'charge' },
    
    // === Tier 5: ç²¾è‹±æ•Œäºº ===
    bear: { name: 'å·¨ç†Š', hp: 45, speed: 80, dmg: 4, exp: 10, gold: 15, color: '#630', sprite: 'bear' },
    snake: { name: 'æ¯’è›‡', hp: 20, speed: 200, dmg: 3, exp: 8, gold: 12, color: '#4a4', sprite: 'snake', special: 'poison' },
    crab: { name: 'é“ç”²èŸ¹', hp: 55, speed: 70, dmg: 3, exp: 12, gold: 18, color: '#f44', sprite: 'crab', armor: 3 },
    
    // === Tier 6: Bossçº§ ===
    turtle: { name: 'ç„é¾Ÿ', hp: 80, speed: 50, dmg: 5, exp: 20, gold: 30, color: '#2a2', sprite: 'turtle', armor: 5 },
    boss_dog: { name: 'ç‹¼ç‹', hp: 65, speed: 170, dmg: 4, exp: 18, gold: 25, color: '#444', sprite: 'dog2', special: 'howl' },
    
    // === ç‰¹æ®Šæ•Œäººï¼ˆå‰§æƒ…ç›¸å…³ï¼‰ ===
    tiaotiao: { name: 'è·³è·³', hp: 30, speed: 260, dmg: 3, exp: 15, gold: 20, color: '#c85', sprite: 'rabbit', special: 'jump' },
    tiezhua: { name: 'é“çˆª', hp: 28, speed: 320, dmg: 4, exp: 18, gold: 22, color: '#a52', sprite: 'bird', special: 'dive' },
    nibei: { name: 'æ³¥èƒŒ', hp: 70, speed: 60, dmg: 3, exp: 20, gold: 35, color: '#6a5', sprite: 'turtle', special: 'tank', armor: 4 },
    yinya: { name: 'é“¶ç‰™', hp: 45, speed: 200, dmg: 4, exp: 25, gold: 30, color: '#789', sprite: 'dog2', special: 'summon' }
};

// BOSSé…ç½®
const BOSS_TYPES = {
    mother: {
        name: 'æ¯ä½“',
        hp: 500,
        speed: 30,
        dmg: 5,
        exp: 100,
        gold: 200,
        color: '#f0f',
        sprite: 'bear',
        scale: 2,
        phases: [
            { hpPercent: 100, behavior: 'normal' },
            { hpPercent: 70, behavior: 'enrage' },
            { hpPercent: 30, behavior: 'desperate' }
        ]
    }
};

class Enemy {
    constructor(x, y, typeKey) {
        const cfg = ENEMY_TYPES[typeKey] || ENEMY_TYPES.chick;
        this.x = x; this.y = y;
        this.typeKey = typeKey;
        this.hp = cfg.hp + (cfg.armor || 0) * 10;
        this.maxHp = this.hp;
        this.speed = cfg.speed;
        this.dmg = cfg.dmg;
        this.exp = cfg.exp;
        this.gold = cfg.gold || 5;
        this.color = cfg.color;
        this.sprite = cfg.sprite;
        this.special = cfg.special;
        this.armor = cfg.armor || 0;
        this.vx = 0; this.vy = 0;
        this.hitTimer = 0;
        this.attackCd = 0;
        this.specialCd = 0;
        
        // çŠ¶æ€æ•ˆæœ
        this.slowTimer = 0;
        this.stunTimer = 0;
        this.poisonTimer = 0;
        this.poisonDmg = 0;
    }

    update(dt, player, room) {
        // çŠ¶æ€æ•ˆæœå¤„ç†
        if (this.stunTimer > 0) {
            this.stunTimer -= dt;
            return; // çœ©æ™•æ—¶æ— æ³•è¡ŒåŠ¨
        }
        
        if (this.slowTimer > 0) {
            this.slowTimer -= dt;
            dt *= 0.5; // å‡é€Ÿ50%
        }
        
        if (this.poisonTimer > 0) {
            this.poisonTimer -= dt;
            this.hp -= this.poisonDmg * dt;
        }
        
        // ç‰¹æ®Šè¡Œä¸º
        if (this.special === 'jump' && this.specialCd <= 0) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d > 0 && d < 200) {
                this.vx = (dx / d) * this.speed * 2;
                this.vy = (dy / d) * this.speed * 2;
                this.specialCd = 2;
            }
        } else if (this.special === 'dive' && this.specialCd <= 0) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d > 100 && d < 400) {
                this.vx = (dx / d) * this.speed * 3;
                this.vy = (dy / d) * this.speed * 3;
                this.specialCd = 3;
            }
        } else {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            
            if (d > 0) {
                this.vx = (dx / d) * this.speed;
                this.vy = (dy / d) * this.speed;
            }
        }
        
        if (this.special === 'tank') {
            this.vx *= 0.8;
            this.vy *= 0.8;
        }
        
        if (this.special === 'summon' && this.specialCd <= 0 && room.enemies.length < 10) {
            this.specialCd = 5;
            const angle = Math.random() * Math.PI * 2;
            const r = 30;
            room.enemies.push(new Enemy(
                this.x + Math.cos(angle) * r,
                this.y + Math.sin(angle) * r,
                'dog'
            ));
        }
        
        for (const other of room.enemies) {
            if (other === this) continue;
            const odx = this.x - other.x;
            const ody = this.y - other.y;
            const od = Math.sqrt(odx*odx + ody*ody);
            if (od < 30 && od > 0) {
                this.vx += (odx / od) * 50;
                this.vy += (ody / od) * 50;
            }
        }
        
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        this.x = clamp(this.x, 50, 850);
        this.y = clamp(this.y, 50, 550);
        
        if (this.hitTimer > 0) this.hitTimer -= dt;
        if (this.attackCd > 0) this.attackCd -= dt;
        if (this.specialCd > 0) this.specialCd -= dt;
    }

    takeDamage(dmg, stats = {}) {
        const actualDmg = Math.max(1, dmg - this.armor);
        this.hp -= actualDmg;
        this.hitTimer = 0.1;
        
        // åº”ç”¨çŠ¶æ€æ•ˆæœ
        if (stats.slowChance && Math.random() < stats.slowChance) {
            this.slowTimer = 2;
        }
        if (stats.stunChance && Math.random() < stats.stunChance) {
            this.stunTimer = 1;
        }
        
        return this.hp <= 0;
    }

    applyPoison(dmg, duration) {
        this.poisonDmg = Math.max(this.poisonDmg, dmg);
        this.poisonTimer = Math.max(this.poisonTimer, duration);
    }

    draw(ctx, sprites) {
        const size = this.isBoss ? 36 : 16;
        
        if (this.hitTimer > 0 && Math.floor(Date.now() / 50) % 2) {
            ctx.globalAlpha = 0.5;
        }
        
        // çŠ¶æ€æ•ˆæœè§†è§‰
        if (this.slowTimer > 0) {
            ctx.strokeStyle = '#48f';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size + 5, 0, Math.PI * 2);
            ctx.stroke();
        }
        if (this.poisonTimer > 0) {
            ctx.strokeStyle = '#4a4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size + 8, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        if (this.isBoss) {
            ctx.strokeStyle = `rgba(255, 0, 255, ${0.3 + Math.sin(Date.now() / 200) * 0.2})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size + 10, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        const sprite = sprites.get(this.sprite);
        if (sprite) {
            ctx.drawImage(sprite, this.x - size, this.y - size, size * 2, size * 2);
        } else {
            const emojiMap = {
                chick: 'ğŸ¤', pig: 'ğŸ·', sheep: 'ğŸ‘', dog: 'ğŸ•',
                cat: 'ğŸ±', bear: 'ğŸ»', rabbit: 'ğŸ¦˜', bird: 'ğŸ¦…',
                turtle: 'ğŸ¢', dog2: 'ğŸº'
            };
            ctx.font = this.isBoss ? '48px Arial' : '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(emojiMap[this.sprite] || 'ğŸ‘¾', this.x, this.y + 8);
        }
        
        ctx.globalAlpha = 1;
        
        if (this.hp < this.maxHp) {
            const barWidth = this.isBoss ? 100 : 24;
            ctx.fillStyle = '#000';
            ctx.fillRect(this.x - barWidth/2, this.y - size - 10, barWidth, 6);
            ctx.fillStyle = this.isBoss ? '#f0f' : '#f00';
            ctx.fillRect(this.x - barWidth/2, this.y - size - 10, barWidth * (this.hp / this.maxHp), 6);
        }
        
        if (this.isBoss) {
            ctx.fillStyle = '#f0f';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(this.name, this.x, this.y - size - 20);
        }
    }
}

// ç›²çœ¼NPCç±»
class ShopNPC {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.name = 'ç›²çœ¼';
    }
    
    draw(ctx, playerNear = false) {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(this.x - 35, this.y - 35, 70, 70);
        ctx.strokeStyle = '#4a4';
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x - 35, this.y - 35, 70, 70);
        
        ctx.font = '32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ¦¯', this.x - 8, this.y + 8);
        ctx.fillText('ğŸ‘ï¸', this.x + 8, this.y + 8);
        
        ctx.fillStyle = '#4f4';
        ctx.font = '12px Arial';
        ctx.fillText('ç›²çœ¼', this.x, this.y + 30);
        
        if (playerNear) {
            ctx.fillStyle = '#ff0';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('æŒ‰ E æ‰“å¼€å•†åº—', this.x, this.y - 45);
        }
    }
}

// å›¾è…¾ç³»ç»Ÿ
const TOTEMS = {
    1: { id: 1, name: 'å…ˆç¥–ä¹‹åŠ›', icon: 'ğŸ¦´', desc: 'æ”»å‡»åŠ›+10%', effect: 'dmg', value: 0.1 },
    2: { id: 2, name: 'åœ°è„‰å®ˆæŠ¤', icon: 'ğŸ›¡ï¸', desc: 'æœ€å¤§ç”Ÿå‘½+1', effect: 'maxHp', value: 1 },
    3: { id: 3, name: 'ç–¾é£æ­¥', icon: 'ğŸ‘Ÿ', desc: 'ç§»åŠ¨é€Ÿåº¦+10%', effect: 'speed', value: 0.1 },
    4: { id: 4, name: 'æ™ºæ…§ä¹‹çœ¼', icon: 'ğŸ‘ï¸', desc: 'ç»éªŒè·å–+20%', effect: 'exp', value: 0.2 },
    5: { id: 5, name: 'è´ªå©ªä¹‹æ‰‹', icon: 'ğŸ’°', desc: 'é‡‘å¸è·å–+25%', effect: 'gold', value: 0.25 },
    6: { id: 6, name: 'å†ç”Ÿä¹‹è¡€', icon: 'â¤ï¸', desc: 'ç”Ÿå‘½æ¢å¤+0.1/ç§’', effect: 'regen', value: 0.1 },
    7: { id: 7, name: 'å¹¸è¿æ˜Ÿ', icon: 'â­', desc: 'æš´å‡»ç‡+5%', effect: 'crit', value: 0.05 }
};

class TotemManager {
    constructor() {
        this.owned = new Set();
        this.load();
    }
    
    load() {
        try {
            const saved = localStorage.getItem('rougecow_totems');
            if (saved) this.owned = new Set(JSON.parse(saved));
        } catch (e) {}
    }
    
    save() {
        try {
            localStorage.setItem('rougecow_totems', JSON.stringify([...this.owned]));
        } catch (e) {}
    }
    
    collect(id) {
        if (this.owned.has(id)) return false;
        this.owned.add(id);
        this.save();
        return true;
    }
    
    has(id) { return this.owned.has(id); }
    getCount() { return this.owned.size; }
    
    getAllBonuses() {
        const bonuses = { dmg: 0, maxHp: 0, speed: 0, exp: 0, gold: 0, regen: 0, crit: 0 };
        for (const id of this.owned) {
            const totem = TOTEMS[id];
            if (totem) bonuses[totem.effect] += totem.value;
        }
        return bonuses;
    }
}

// æˆ¿é—´ç±»
class Room {
    constructor(gx, gy, type = 'normal', floor = 1, templateKey = null) {
        this.gx = gx; this.gy = gy;
        this.id = `${gx},${gy}`;
        this.type = type;
        this.floor = floor;
        this.doors = { up: null, down: null, left: null, right: null };
        this.enemies = [];
        this.cleared = type === 'start' || type === 'treasure' || type === 'shop';
        this.visited = false;
        this.items = [];
        this.npc = null;
        
        // å¤§æˆ¿é—´å°ºå¯¸
        this.width = SURVIVOR_CONFIG.ROOM_WIDTH;
        this.height = SURVIVOR_CONFIG.ROOM_HEIGHT;
        this.centerX = this.width / 2;
        this.centerY = this.height / 2;
        
        // é€‰æ‹©æ¨¡æ¿ï¼ˆ8ä¸ªä¹‹ä¸€ï¼‰
        const keys = Object.keys(ROOM_TEMPLATES);
        this.templateKey = templateKey || keys[Math.floor(Math.random() * keys.length)];
        this.template = ROOM_TEMPLATES[this.templateKey];
        // å°†ç›¸å¯¹åæ ‡ï¼ˆ0-1ï¼‰è½¬æ¢ä¸ºç»å¯¹åæ ‡
        this.spawnPoints = this.template.spawnPoints.map(p => ({
            x: p.x < 1 ? p.x * this.width : p.x,
            y: p.y < 1 ? p.y * this.height : p.y
        }));
        
        // æ³¢æ¬¡ç®¡ç†å™¨
        this.hordeManager = null;
        if (type === 'normal' || type === 'boss') {
            this.hordeManager = new HordeManager(this);
        }
        
        if (type === 'shop') {
            this.npc = new ShopNPC(this.width * 0.15, this.centerY);
        }
        
        this.spawnRoomItems();
    }
    
    spawnRoomItems() {
        if (this.type === 'treasure') {
            const count = randInt(2, 4);
            const r = Math.min(this.width, this.height) * 0.15; // ç›¸å¯¹åŠå¾„
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const x = this.centerX + Math.cos(angle) * r;
                const y = this.centerY + Math.sin(angle) * r;
                const itemId = randInt(1, 16);
                const item = ITEMS[itemId];
                if (item) {
                    this.items.push({ x, y, id: itemId, icon: item.icon, name: item.name });
                }
            }
        } else if (this.type === 'hidden') {
            const itemId = randInt(1, 16);
            const item = ITEMS[itemId];
            if (item) {
                this.items.push({
                    x: this.centerX, y: this.centerY,
                    id: itemId, icon: item.icon,
                    name: item.name + '(è¯…å’’)', cursed: true
                });
            }
        }
    }
    
    // è·å–å½“å‰æ´»è·ƒæ•Œäººï¼ˆä¾›å¤–éƒ¨ä½¿ç”¨ï¼‰
    getActiveEnemies() {
        if (this.hordeManager) {
            return this.hordeManager.getActiveEnemies();
        }
        return this.enemies.filter(e => e.hp > 0);
    }
    
    update(dt) {
        if (this.hordeManager) {
            this.hordeManager.update(dt);
            // æŒç»­è¡¥å……æ•Œäººç›´åˆ°è¾¾åˆ°æœ¬æ³¢ç›®æ ‡
            if (this.hordeManager.spawnedThisWave < this.hordeManager.targetCount) {
                this.hordeManager.spawnBatch();
            }
        }
    }

    spawnEnemies() {
        if (this.type === 'start' || this.type === 'treasure' || this.type === 'shop') return;
        
        if (this.type === 'hidden') {
            const eliteTypes = ['bear', 'yinya'];
            const typeKey = randChoice(eliteTypes);
            const elite = new Enemy(this.centerX, this.centerY, typeKey);
            elite.hp *= 2;
            elite.maxHp *= 2;
            elite.dmg *= 1.5;
            elite.isElite = true;
            this.enemies.push(elite);
            return;
        }
        
        if (this.type === 'boss') {
            const bossCfg = BOSS_TYPES.mother;
            const boss = new Enemy(this.centerX, this.centerY - 100, 'bear');
            boss.name = bossCfg.name;
            boss.hp = bossCfg.hp;
            boss.maxHp = bossCfg.hp;
            boss.speed = bossCfg.speed;
            boss.dmg = bossCfg.dmg;
            boss.exp = bossCfg.exp;
            boss.gold = bossCfg.gold;
            boss.color = bossCfg.color;
            boss.isBoss = true;
            boss.phase = 0;
            this.enemies.push(boss);
            return;
        }
        
        const count = randInt(3, 7);
        const types = Object.keys(ENEMY_TYPES).filter(k => !ENEMY_TYPES[k].special);
        
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const r = 150 + Math.random() * 100;
            const x = 450 + Math.cos(angle) * r;
            const y = 300 + Math.sin(angle) * r;
            
            if (Math.random() < 0.1 && (this.gx + this.gy) > 2) {
                const specialTypes = ['tiaotiao', 'tiezhua', 'nibei', 'yinya'];
                this.enemies.push(new Enemy(x, y, randChoice(specialTypes)));
            } else {
                this.enemies.push(new Enemy(x, y, randChoice(types)));
            }
        }
    }

    draw(ctx, camera) {
        const floorColors = { 
            start: '#1a1a2e', normal: '#16213e', boss: '#2d1b2e', 
            treasure: '#2d2d1b', shop: '#1b1b2d', hidden: '#2d1b2d'
        };
        
        // è®¡ç®—è§†é‡èŒƒå›´ï¼ˆä¸–ç•Œåæ ‡ï¼‰
        const viewLeft = camera.x - camera.viewWidth / 2;
        const viewTop = camera.y - camera.viewHeight / 2;
        const viewRight = viewLeft + camera.viewWidth;
        const viewBottom = viewTop + camera.viewHeight;
        
        // åœ°æ¿ä½¿ç”¨ä¸–ç•Œåæ ‡ç»˜åˆ¶ï¼Œå’Œå¢™ã€é—¨ä¿æŒä¸€è‡´
        ctx.fillStyle = floorColors[this.type] || '#16213e';
        const floorTopLeft = camera.worldToScreen(viewLeft, viewTop);
        const floorBottomRight = camera.worldToScreen(viewRight, viewBottom);
        ctx.fillRect(floorTopLeft.x, floorTopLeft.y, floorBottomRight.x - floorTopLeft.x, floorBottomRight.y - floorTopLeft.y);
        
        // ç»˜åˆ¶ç½‘æ ¼ï¼ˆè£…é¥°ï¼‰
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1;
        const gridStartX = Math.floor(viewLeft / 50) * 50;
        const gridStartY = Math.floor(viewTop / 50) * 50;
        for (let wx = gridStartX; wx < viewRight; wx += 50) {
            const top = camera.worldToScreen(wx, viewTop);
            const bottom = camera.worldToScreen(wx, viewBottom);
            ctx.beginPath(); ctx.moveTo(top.x, top.y); ctx.lineTo(bottom.x, bottom.y); ctx.stroke();
        }
        for (let wy = gridStartY; wy < viewBottom; wy += 50) {
            const left = camera.worldToScreen(viewLeft, wy);
            const right = camera.worldToScreen(viewRight, wy);
            ctx.beginPath(); ctx.moveTo(left.x, left.y); ctx.lineTo(right.x, right.y); ctx.stroke();
        }
        
        // ç»˜åˆ¶æˆ¿é—´è¾¹ç•Œï¼ˆåšå¢™ï¼‰- ä½¿ç”¨ä¸–ç•Œåæ ‡è½¬æ¢ï¼Œå’Œé—¨ä¿æŒä¸€è‡´
        ctx.fillStyle = '#0f0f1a';
        const wallThickness = 60;
        // å·¦å¢™
        if (viewLeft < wallThickness) {
            const topLeft = camera.worldToScreen(0, viewTop);
            const bottomRight = camera.worldToScreen(wallThickness, viewBottom);
            ctx.fillRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
        }
        // å³å¢™
        if (viewRight > this.width - wallThickness) {
            const topLeft = camera.worldToScreen(this.width - wallThickness, viewTop);
            const bottomRight = camera.worldToScreen(this.width, viewBottom);
            ctx.fillRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
        }
        // ä¸Šå¢™
        if (viewTop < wallThickness) {
            const topLeft = camera.worldToScreen(viewLeft, 0);
            const bottomRight = camera.worldToScreen(viewRight, wallThickness);
            ctx.fillRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
        }
        // ä¸‹å¢™
        if (viewBottom > this.height - wallThickness) {
            const topLeft = camera.worldToScreen(viewLeft, this.height - wallThickness);
            const bottomRight = camera.worldToScreen(viewRight, this.height);
            ctx.fillRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
        }
        
        // ç»˜åˆ¶é—¨ï¼ˆé—¨å‘å†…å‡¹è¿›æˆ¿é—´ï¼Œé¿å…è¢«å¢™åŒ…å›´ï¼‰
        const doorPositions = {};
        const wallT = 60; // å¢™åšåº¦
        
        for (const [dir, door] of Object.entries(this.doors)) {
            if (!door) continue;
            let doorX, doorY, doorW, doorH;
            switch(dir) {
                // é—¨å’Œå¢™å¹³é½ï¼Œä¸å‡¹é™·ä¸çªå‡º
                case 'up': doorX = this.centerX - 40; doorY = 0; doorW = 80; doorH = wallT; break;
                case 'down': doorX = this.centerX - 40; doorY = this.height - wallT; doorW = 80; doorH = wallT; break;
                case 'left': doorX = 0; doorY = this.centerY - 50; doorW = wallT; doorH = 100; break;
                case 'right': doorX = this.width - wallT; doorY = this.centerY - 50; doorW = wallT; doorH = 100; break;
            }
            doorPositions[dir] = { x: doorX, y: doorY, w: doorW, h: doorH };
            
            // åœ¨å¢™ä¸ŠæŒ–æ´ï¼ˆç”¨åœ°æ¿é¢œè‰²è¦†ç›–é—¨åŒºåŸŸï¼‰
            if (doorX < viewRight && doorX + doorW > viewLeft &&
                doorY < viewBottom && doorY + doorH > viewTop) {
                const screenPos = camera.worldToScreen(doorX, doorY);
                const screenEnd = camera.worldToScreen(doorX + doorW, doorY + doorH);
                ctx.fillStyle = floorColors[this.type] || '#16213e';
                ctx.fillRect(screenPos.x, screenPos.y, screenEnd.x - screenPos.x, screenEnd.y - screenPos.y);
            }
        }
        
        // ç»˜åˆ¶é—¨
        for (const [dir, door] of Object.entries(this.doors)) {
            if (!door) continue;
            const pos = doorPositions[dir];
            if (!pos) continue;
            
            if (pos.x < viewRight && pos.x + pos.w > viewLeft &&
                pos.y < viewBottom && pos.y + pos.h > viewTop) {
                const screenPos = camera.worldToScreen(pos.x, pos.y);
                const screenEnd = camera.worldToScreen(pos.x + pos.w, pos.y + pos.h);
                const screenW = screenEnd.x - screenPos.x;
                const screenH = screenEnd.y - screenPos.y;
                // é—¨è¾¹æ¡†
                ctx.fillStyle = '#555';
                ctx.fillRect(screenPos.x - 2, screenPos.y - 2, screenW + 4, screenH + 4);
                // é—¨æœ¬ä½“
                ctx.fillStyle = door.open ? '#4a4' : '#a44';
                ctx.fillRect(screenPos.x, screenPos.y, screenW, screenH);
                // é—¨æŠŠæ‰‹/è£…é¥°
                ctx.fillStyle = '#222';
                ctx.fillRect(screenPos.x + screenW/2 - 3, screenPos.y + screenH/2 - 3, 6, 6);
            }
        }
        
        // æ˜¾ç¤ºæˆ¿é—´ç±»å‹ï¼ˆä¸å†æ˜¾ç¤ºåœ°å½¢åç§°ï¼‰
        const roomLabels = {
            start: 'èµ·ç‚¹', normal: 'æˆ˜æ–—', boss: 'BOSS',
            treasure: 'ğŸ’ å®ç®±æˆ¿', shop: 'ğŸª å•†åº—', hidden: 'ğŸ‘ï¸ éšè—æˆ¿'
        };
        // æˆ¿é—´æ ‡ç­¾ï¼ˆæ ¹æ®è§†é‡å¤§å°è°ƒæ•´ä½ç½®ï¼‰
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        const labelX = Math.max(20, camera.viewWidth * 0.02);
        const labelY = Math.max(30, camera.viewHeight * 0.05);
        ctx.fillText(roomLabels[this.type] || 'æœªçŸ¥', labelX, labelY);
        
        // æ³¢æ¬¡ä¿¡æ¯
        if (this.hordeManager && this.type === 'normal') {
            ctx.fillStyle = '#aaa';
            ctx.font = '14px Arial';
            ctx.textAlign = 'right';
            const infoX = camera.viewWidth - labelX;
            ctx.fillText(`æ³¢æ¬¡: ${this.hordeManager.wave}`, infoX, labelY);
            ctx.fillText(`æ•Œäºº: ${this.hordeManager.getActiveEnemies().length}`, infoX, labelY + 20);
        }
    }
}

// ============================================================================
// å¸è¡€é¬¼å¹¸å­˜è€…é£æ ¼åˆ·æ€ªç³»ç»Ÿ v2.0
// ============================================================================
class HordeManager {
    constructor(room) {
        this.room = room;
        this.wave = 0;
        this.timer = 0;
        this.spawnedThisWave = 0;
        this.targetCount = 0;
        this.enemies = [];
        this.maxActiveEnemies = 80;
        
        // æ ¹æ®æˆ¿é—´ç±»å‹è®¾ç½®åˆ·æ€ªç­–ç•¥
        this.setupRoomType();
        
        // ç”Ÿæˆè¾¹ç¼˜åˆ·æ€ªç‚¹ï¼ˆé¿å…åœ¨ç©å®¶è„¸ä¸Šåˆ·æ€ªï¼‰
        this.spawnPoints = this.generateSpawnPoints();
        
        // è¿›æˆ¿é—´ç«‹å³å¼€å§‹ç¬¬ä¸€æ³¢
        if (this.totalWaves > 0) {
            this.startNewWave();
        }
    }
    
    // æ ¹æ®æˆ¿é—´ç±»å‹é…ç½®
    setupRoomType() {
        const type = this.room.type;
        
        switch(type) {
            case 'normal':
                this.waveCount = 3 + Math.floor(Math.random() * 3); // 3-5æ³¢
                this.baseEnemyCount = 10; // æ•Œäººæ•°é‡ç¿»å€
                this.bossRoom = false;
                break;
            case 'boss':
                this.waveCount = 1;
                this.baseEnemyCount = 0;
                this.bossRoom = true;
                break;
            case 'hidden':
                this.waveCount = 1;
                this.baseEnemyCount = 6; // æ•Œäººæ•°é‡ç¿»å€
                this.bossRoom = false;
                this.eliteOnly = true;
                break;
            default:
                this.waveCount = 0; // èµ·ç‚¹/å•†åº—/å®ç®±ä¸åˆ·æ€ª
                this.baseEnemyCount = 0;
        }
        
        this.totalWaves = this.waveCount;
    }
    
    // ç”Ÿæˆè¾¹ç¼˜åˆ·æ€ªç‚¹ï¼ˆæˆ¿é—´å››è¾¹ï¼Œè·ç¦»å¢™ä¸€å®šè·ç¦»ï¼‰
    generateSpawnPoints() {
        const points = [];
        const w = this.room.width;
        const h = this.room.height;
        const margin = 120; // è·ç¦»å¢™çš„è·ç¦»
        
        // ä¸Šä¸‹ä¸¤è¾¹
        for (let x = margin; x < w - margin; x += 150) {
            points.push({x, y: margin});
            points.push({x, y: h - margin});
        }
        // å·¦å³ä¸¤è¾¹
        for (let y = margin; y < h - margin; y += 150) {
            points.push({x: margin, y});
            points.push({x: w - margin, y});
        }
        
        return points;
    }
    
    update(dt) {
        // å·²å®Œæˆæ‰€æœ‰æ³¢æ¬¡
        if (this.wave >= this.totalWaves && this.enemies.filter(e => e.hp > 0).length === 0) {
            if (!this.room.cleared) {
                this.room.cleared = true;
                this.openDoors();
            }
            return;
        }
        
        // å½“å‰æ³¢æ¬¡æ•Œäººæ­»å®Œï¼Œç«‹å³å¼€å§‹ä¸‹ä¸€æ³¢
        const activeCount = this.enemies.filter(e => e.hp > 0).length;
        if (activeCount === 0 && this.spawnedThisWave >= this.targetCount && this.wave < this.totalWaves) {
            this.startNewWave();
        }
        
        // æŒç»­åˆ·æ€ªç›´åˆ°è¾¾åˆ°æœ¬æ³¢ç›®æ ‡
        if (this.spawnedThisWave < this.targetCount && activeCount < this.maxActiveEnemies) {
            this.spawnBatch();
        }
        
        this.enemies = this.enemies.filter(e => e.hp > 0);
    }
    
    startNewWave() {
        this.wave++;
        this.timer = 0;
        
        // éš¾åº¦å…¬å¼ï¼šåŸºç¡€æ•°é‡ Ã— (1 + æ³¢æ•° Ã— 0.2)
        const difficultyMultiplier = 1 + (this.wave - 1) * 0.2;
        this.targetCount = Math.floor(this.baseEnemyCount * difficultyMultiplier);
        this.spawnedThisWave = 0;
        
        console.log(`ğŸŒŠ ç¬¬ ${this.wave}/${this.totalWaves} æ³¢ï¼ç›®æ ‡ï¼š${this.targetCount} åª`);
    }
    
    spawnBatch() {
        const batchSize = Math.min(3, this.targetCount - this.spawnedThisWave);
        const activeCount = this.enemies.filter(e => e.hp > 0).length;
        if (activeCount >= this.maxActiveEnemies) return;
        
        for (let i = 0; i < batchSize; i++) {
            if (this.spawnedThisWave >= this.targetCount) break;
            
            // éšæœºé€‰æ‹©åˆ·æ€ªç‚¹
            const point = this.spawnPoints[Math.floor(Math.random() * this.spawnPoints.length)];
            // æ·»åŠ éšæœºåç§»
            const x = point.x + (Math.random() - 0.5) * 60;
            const y = point.y + (Math.random() - 0.5) * 60;
            
            const enemy = this.createEnemy(x, y);
            this.enemies.push(enemy);
            this.spawnedThisWave++;
        }
    }
    
    createEnemy(x, y) {
        // æ ¹æ®æ³¢æ•°é€‰æ‹©æ•Œäººç­‰çº§
        const typeKey = this.selectEnemyType();
        const enemy = new Enemy(x, y, typeKey);
        
        // åº”ç”¨éš¾åº¦ç¼©æ”¾
        const waveMultiplier = 1 + (this.wave - 1) * 0.15; // HPæ¯æ³¢+15%
        const dmgMultiplier = 1 + (this.wave - 1) * 0.08;  // ä¼¤å®³æ¯æ³¢+8%
        const spdMultiplier = 1 + (this.wave - 1) * 0.03;  // é€Ÿåº¦æ¯æ³¢+3%
        
        enemy.hp = Math.floor(enemy.hp * waveMultiplier);
        enemy.maxHp = enemy.hp;
        enemy.dmg = Math.floor(enemy.dmg * dmgMultiplier);
        enemy.speed = Math.floor(enemy.speed * spdMultiplier);
        
        return enemy;
    }
    
    // æ ¹æ®æ³¢æ•°é€‰æ‹©æ•Œäººç±»å‹
    selectEnemyType() {
        const tierKeys = {
            1: ['chick', 'mouse', 'snail'],
            2: ['rabbit', 'bird', 'pigeon'],
            3: ['cat', 'duck', 'squirrel'],
            4: ['dog', 'pig', 'sheep', 'goose'],
            5: ['bear', 'snake', 'crab'],
            6: ['turtle', 'boss_dog']
        };
        
        let tier;
        
        if (this.eliteOnly) {
            // éšè—æˆ¿åªå‡ºç²¾è‹±
            tier = Math.random() < 0.5 ? 4 : 5;
        } else if (this.bossRoom && this.wave === 1) {
            // Bossæˆ¿ç¬¬ä¸€æ³¢å‡ºBoss
            return Math.random() < 0.5 ? 'turtle' : 'boss_dog';
        } else {
            // æ™®é€šæˆ¿é—´æ ¹æ®æ³¢æ•°é€‰æ‹©
            const roll = Math.random();
            if (this.wave === 1) {
                tier = roll < 0.7 ? 1 : 2;
            } else if (this.wave === 2) {
                tier = roll < 0.4 ? 1 : (roll < 0.8 ? 2 : 3);
            } else {
                tier = roll < 0.2 ? 2 : (roll < 0.5 ? 3 : (roll < 0.8 ? 4 : 5));
            }
        }
        
        const types = tierKeys[tier];
        return types[Math.floor(Math.random() * types.length)];
    }
    
    openDoors() {
        Object.values(this.room.doors).forEach(door => {
            if (door) {
                door.open = true;
                door.locked = false;
            }
        });
        console.log('ğŸšª æˆ¿é—´æ¸…ç†å®Œæˆï¼Œé—¨å·²å¼€å¯');
    }
    
    getActiveEnemies() {
        return this.enemies.filter(e => e.hp > 0);
    }
}

// åœ°å›¾ç”Ÿæˆå™¨
class MapGenerator {
    generate(floor = 1) {
        const rooms = new Map();
        const start = new Room(0, 0, 'start', floor);
        rooms.set(start.id, start);
        
        const queue = [start];
        const dirs = [
            { dx: 0, dy: -1, name: 'up', opp: 'down' },
            { dx: 1, dy: 0, name: 'right', opp: 'left' },
            { dx: 0, dy: 1, name: 'down', opp: 'up' },
            { dx: -1, dy: 0, name: 'left', opp: 'right' }
        ];
        
        let count = 1;
        const maxRooms = 8 + floor * 2;
        
        while (queue.length && count < maxRooms) {
            const cur = queue.shift();
            for (const dir of dirs.sort(() => Math.random() - 0.5)) {
                const nx = cur.gx + dir.dx, ny = cur.gy + dir.dy;
                const id = `${nx},${ny}`;
                
                if (rooms.has(id)) {
                    const ex = rooms.get(id);
                    if (!cur.doors[dir.name]) {
                        cur.doors[dir.name] = { open: cur.cleared, target: ex };
                        ex.doors[dir.opp] = { open: ex.cleared, target: cur };
                    }
                    continue;
                }
                
                if (Math.random() > 0.4 || count < 5) {
                    let type = 'normal';
                    if (count === maxRooms - 1) {
                        type = 'boss';
                    } else if (count > 3) {
                        const roll = Math.random();
                        if (roll < 0.15) type = 'treasure';
                        else if (roll < 0.30) type = 'shop';
                        else if (roll < 0.35) type = 'hidden';
                    }
                    
                    const nr = new Room(nx, ny, type, floor);
                    cur.doors[dir.name] = { open: cur.cleared, target: nr };
                    nr.doors[dir.opp] = { open: nr.cleared, target: cur };
                    rooms.set(id, nr);
                    queue.push(nr);
                    count++;
                }
            }
        }
        
        return { start, rooms };
    }
}

// ============================================================================
// ä¸»æ¸¸æˆç±» v0.7.2
// ============================================================================
// ==================== å¸è¡€é¬¼å¹¸å­˜è€…é£æ ¼é‡æ„ ====================
const SURVIVOR_CONFIG = {
    VIEW_WIDTH: 900, VIEW_HEIGHT: 600,
    CAMERA_SMOOTH: 0.1,
    WAVE_INTERVAL: 30, WAVE_BASE_COUNT: 20, WAVE_INCREMENT: 5,
    GRID_CELL_SIZE: 150,
    // è‡ªé€‚åº”è§†é‡ï¼šå¦‚æœå±å¹•å¤Ÿå¤§å°±æ˜¾ç¤ºå®Œæ•´æˆ¿é—´
    ADAPTIVE_VIEW: true,
    // æˆ¿é—´å°ºå¯¸ä¼šåœ¨è¿è¡Œæ—¶æ ¹æ®canvasåŠ¨æ€è®¡ç®—
    ROOM_WIDTH: 1200,
    ROOM_HEIGHT: 800
};

class SurvivorCamera {
    constructor() {
        this.x = SURVIVOR_CONFIG.ROOM_WIDTH / 2;
        this.y = SURVIVOR_CONFIG.ROOM_HEIGHT / 2;
        this.target = null;
        this.viewWidth = SURVIVOR_CONFIG.VIEW_WIDTH;
        this.viewHeight = SURVIVOR_CONFIG.VIEW_HEIGHT;
        this.showFullRoom = false;
        this.zoom = 1;
        this.updateViewport();
    }
    
    // æ ¹æ®çª—å£å°ºå¯¸è®¾ç½®æˆ¿é—´å¤§å°ï¼Œç¡®ä¿æˆ¿é—´å®Œæ•´æ˜¾ç¤ºå¹¶å¡«æ»¡æ¸¸æˆåŒºåŸŸ
    updateViewport() {
        // ä½¿ç”¨çª—å£å°ºå¯¸å‡å»ä¸¤ä¾§è¾¹æ 
        const sidebarWidth = 260 * 2; // å·¦å³è¾¹æ 
        const canvasW = Math.max(800, window.innerWidth - sidebarWidth - 40);
        const canvasH = Math.max(600, window.innerHeight - 100);
        
        const canvas = document.getElementById('gameCanvas');
        if (canvas) {
            canvas.width = canvasW;
            canvas.height = canvasH;
        }
        
        // æˆ¿é—´å°ºå¯¸ = canvas å°ºå¯¸å‡å»å¢™è¾¹è·
        const wallMargin = 60;
        SURVIVOR_CONFIG.ROOM_WIDTH = Math.floor(canvasW - wallMargin * 2);
        SURVIVOR_CONFIG.ROOM_HEIGHT = Math.floor(canvasH - wallMargin * 2);
        
        const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
        const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
        
        // å§‹ç»ˆæ˜¾ç¤ºå®Œæ•´æˆ¿é—´
        this.showFullRoom = true;
        this.viewWidth = roomW;
        this.viewHeight = roomH;
        this.x = roomW / 2;
        this.y = roomH / 2;
        this.zoom = 1;
        
        console.log(`ğŸ“ æˆ¿é—´å°ºå¯¸: ${roomW}x${roomH}, Canvas: ${canvasW}x${canvasH}`);
    }
    
    follow(target) { this.target = target; }
    
    update() {
        if (this.showFullRoom) {
            // æ˜¾ç¤ºå®Œæ•´æˆ¿é—´æ—¶ï¼Œç›¸æœºå›ºå®šåœ¨ä¸­å¿ƒ
            this.x = SURVIVOR_CONFIG.ROOM_WIDTH / 2;
            this.y = SURVIVOR_CONFIG.ROOM_HEIGHT / 2;
            return;
        }
        
        if (!this.target) return;
        this.x += (this.target.x - this.x) * SURVIVOR_CONFIG.CAMERA_SMOOTH;
        this.y += (this.target.y - this.y) * SURVIVOR_CONFIG.CAMERA_SMOOTH;
        const minX = this.viewWidth / 2, maxX = SURVIVOR_CONFIG.ROOM_WIDTH - this.viewWidth / 2;
        const minY = this.viewHeight / 2, maxY = SURVIVOR_CONFIG.ROOM_HEIGHT - this.viewHeight / 2;
        this.x = Math.max(minX, Math.min(maxX, this.x));
        this.y = Math.max(minY, Math.min(maxY, this.y));
    }
    
    worldToScreen(wx, wy) {
        if (this.showFullRoom) {
            // å®Œæ•´æˆ¿é—´æ¨¡å¼ï¼šæˆ¿é—´å¡«æ»¡ canvasï¼Œè®¡ç®—å±…ä¸­åç§»
            const canvas = document.getElementById('gameCanvas');
            const canvasW = canvas ? canvas.clientWidth : 900;
            const canvasH = canvas ? canvas.clientHeight : 600;
            const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
            const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
            
            // è®¡ç®—å±…ä¸­åç§»ï¼ˆæˆ¿é—´å°ºå¯¸å·²ç»æ ¹æ® canvas è°ƒæ•´è¿‡ï¼‰
            const offsetX = (canvasW - roomW) / 2;
            const offsetY = (canvasH - roomH) / 2;
            
            return { 
                x: wx + offsetX, 
                y: wy + offsetY 
            };
        }
        return { x: wx - this.x + this.viewWidth / 2, y: wy - this.y + this.viewHeight / 2 };
    }
    
    isVisible(wx, wy, radius = 50) {
        if (this.showFullRoom) {
            return wx >= -radius && wx <= SURVIVOR_CONFIG.ROOM_WIDTH + radius 
                && wy >= -radius && wy <= SURVIVOR_CONFIG.ROOM_HEIGHT + radius;
        }
        return Math.abs(wx - this.x) < this.viewWidth / 2 + radius && Math.abs(wy - this.y) < this.viewHeight / 2 + radius;
    }
}

class SpatialGrid {
    constructor() {
        this.cellSize = SURVIVOR_CONFIG.GRID_CELL_SIZE;
        this.cells = new Map();
    }
    getKey(cx, cy) { return `${cx},${cy}`; }
    getCellByPos(x, y) {
        return { cx: Math.floor(x / this.cellSize), cy: Math.floor(y / this.cellSize) };
    }
    clear() { this.cells.clear(); }
    insert(entity) {
        const { cx, cy } = this.getCellByPos(entity.x, entity.y);
        const key = this.getKey(cx, cy);
        if (!this.cells.has(key)) this.cells.set(key, []);
        this.cells.get(key).push(entity);
        entity._gridCell = { cx, cy };
    }
    getNearby(x, y) {
        const { cx, cy } = this.getCellByPos(x, y);
        const result = [];
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const cell = this.cells.get(this.getKey(cx + dx, cy + dy));
                if (cell) result.push(...cell);
            }
        }
        return result;
    }
}

// 8ä¸ªæˆ¿é—´æ¨¡æ¿ - ä½¿ç”¨ç›¸å¯¹åæ ‡ (0-1)ï¼Œåœ¨ Room æ„é€ å‡½æ•°ä¸­è½¬æ¢ä¸ºç»å¯¹åæ ‡
const ROOM_TEMPLATES = {
    empty: { name: 'ç©ºæ—·å¤§å…', spawnPoints: [{x:0.5,y:0.5}] },
    pillars: { name: 'æŸ±å»Š', spawnPoints: [{x:0.5,y:0.5}] },
    corners: { name: 'å¹¿åœº', spawnPoints: [{x:0.5,y:0.5}] },
    cross: { name: 'åå­—å…', spawnPoints: [{x:0.5,y:0.5}] },
    sides: { name: 'å›å»Š', spawnPoints: [{x:0.5,y:0.5}] },
    grid: { name: 'å¤§å…', spawnPoints: [{x:0.5,y:0.5}] },
    ring: { name: 'ç«æŠ€åœº', spawnPoints: [{x:0.5,y:0.5}] },
    maze: { name: 'è¿·å®«', spawnPoints: [{x:0.5,y:0.5}] }
};

// å…¨å±é€‚é…å™¨ - 3æ å¸ƒå±€æ¨¡å¼ä¸‹ä¸å¹²é¢„canvasæ ·å¼
class FullscreenAdapter {
    constructor(canvas, gameWidth = 900, gameHeight = 600) {
        this.canvas = canvas;
        this.gameWidth = gameWidth;
        this.gameHeight = gameHeight;
        this.scale = 1;
        // 3æ å¸ƒå±€æ¨¡å¼ä¸‹ä¸è‡ªåŠ¨è°ƒæ•´canvasæ ·å¼
        // this.setup();
        // window.addEventListener('resize', () => this.resize());
    }
    setup() {
        // å·²ç¦ç”¨ - 3æ å¸ƒå±€ç”±CSSæ§åˆ¶
    }
    resize() {
        // å·²ç¦ç”¨ - 3æ å¸ƒå±€ç”±CSSæ§åˆ¶
        // åªæ›´æ–°ç›¸æœºè§†é‡
        if (window.game?.camera) {
            window.game.camera.updateViewport();
        }
    }
}

// ============================================================================
// åˆ†æ•°ç³»ç»Ÿ - ScoreManager
// ============================================================================

class ScoreManager {
    constructor() {
        this.score = 0;
        this.startTime = 0;
        this.endTime = 0;
        this.isPlaying = false;
        
        // ç»Ÿè®¡
        this.stats = {
            enemiesKilled: 0,
            elitesKilled: 0,
            bossesKilled: 0,
            roomsExplored: 0,
            itemsCollected: 0,
            goldCollected: 0,
            damageTaken: 0,
            floorsCleared: 0
        };
        
        // è¿æ€ç³»ç»Ÿ
        this.killStreak = 0;
        this.lastKillTime = 0;
        this.streakMultiplier = 1;
        
        // æœ€ä½åˆ†ä¿æŠ¤
        this.MIN_SCORE = 100;
    }
    
    start() {
        this.score = 0;
        this.startTime = Date.now();
        this.isPlaying = true;
        this.stats = {
            enemiesKilled: 0,
            elitesKilled: 0,
            bossesKilled: 0,
            roomsExplored: 0,
            itemsCollected: 0,
            goldCollected: 0,
            damageTaken: 0,
            floorsCleared: 0
        };
        this.killStreak = 0;
        this.streakMultiplier = 1;
        console.log('ğŸ† åˆ†æ•°ç³»ç»Ÿå¯åŠ¨ï¼');
    }
    
    // åŸºç¡€åŠ åˆ†
    add(points, reason = '') {
        if (!this.isPlaying) return;
        const actual = Math.floor(points * this.streakMultiplier);
        this.score += actual;
        if (reason) console.log(`ğŸ’¯ +${actual}åˆ† (${reason})`);
        return actual;
    }
    
    // æ‰£åˆ†
    deduct(points, reason = '') {
        if (!this.isPlaying) return;
        this.score = Math.max(this.MIN_SCORE - 500, this.score - points); // ä¿è¯æ­»äº¡åä¸ä½äºMIN_SCORE
        if (reason) console.log(`ğŸ’” -${points}åˆ† (${reason})`);
    }
    
    // å‡»æ€æ•Œäºº
    onKillEnemy(enemyType = 'normal') {
        this.stats.enemiesKilled++;
        
        // è¿æ€è®¡ç®—
        const now = Date.now();
        if (now - this.lastKillTime < 10000) { // 10ç§’å†…
            this.killStreak++;
            if (this.killStreak >= 3) {
                this.streakMultiplier = 1.5;
                console.log(`ğŸ”¥ è¿æ€x${this.killStreak}ï¼åˆ†æ•°åŠ æˆ50%`);
            }
        } else {
            this.killStreak = 1;
            this.streakMultiplier = 1;
        }
        this.lastKillTime = now;
        
        let points = 10;
        if (enemyType === 'elite') {
            points = 30;
            this.stats.elitesKilled++;
        } else if (enemyType === 'boss') {
            points = 500;
            this.stats.bossesKilled++;
        }
        
        this.add(points, `å‡»æ€${enemyType === 'normal' ? 'æ™®é€šæ€ª' : enemyType === 'elite' ? 'ç²¾è‹±' : 'Boss'}`);
    }
    
    // è¿›å…¥æ–°æˆ¿é—´
    onEnterRoom() {
        this.stats.roomsExplored++;
        this.add(50, 'æ¢ç´¢æ–°æˆ¿é—´');
    }
    
    // æ‹¾å–é“å…·
    onCollectItem() {
        this.stats.itemsCollected++;
        this.add(50, 'æ‹¾å–é“å…·');
    }
    
    // æ‹¾å–é‡‘å¸
    onCollectGold(amount) {
        this.stats.goldCollected += amount;
        this.add(amount, `æ‹¾å–${amount}é‡‘å¸`);
    }
    
    // å—ä¼¤
    onDamage() {
        this.stats.damageTaken++;
        this.deduct(5, 'å—ä¼¤');
    }
    
    // åˆ°è¾¾ä¸‹å±‚
    onFloorClear(floorNum) {
        this.stats.floorsCleared++;
        this.add(300, `é€šå…³ç¬¬${floorNum}å±‚`);
    }
    
    // æ¸¸æˆç»“æŸè®¡ç®—
    end(result) {
        this.isPlaying = false;
        this.endTime = Date.now();
        
        const playTime = (this.endTime - this.startTime) / 1000; // ç§’
        let finalScore = this.score;
        let multiplier = 1;
        
        // é€šå…³åŠ æˆ
        if (result === 'cleared') {
            multiplier = 1.5;
            
            // æ— ä¼¤åŠ æˆ
            if (this.stats.damageTaken === 0) {
                multiplier = 2.0;
                console.log('ğŸŒŸ æ— ä¼¤é€šå…³ï¼åˆ†æ•°Ã—2');
            }
            
            // å¿«é€Ÿé€šå…³
            if (playTime < 300) { // 5åˆ†é’Ÿ
                multiplier *= 1.5;
                console.log('âš¡ æé€Ÿé€šå…³ï¼é¢å¤–Ã—1.5');
            }
        }
        
        // æ­»äº¡æƒ©ç½š
        if (result === 'dead') {
            finalScore -= 500;
            console.log('ğŸ’€ æ­»äº¡æƒ©ç½š -500åˆ†');
        }
        
        finalScore = Math.max(this.MIN_SCORE, Math.floor(finalScore * multiplier));
        
        // ä¿å­˜åˆ°æœ¬åœ°æ’è¡Œæ¦œ
        this.saveHighScore(finalScore, result);
        
        return {
            finalScore,
            baseScore: this.score,
            multiplier,
            playTime,
            stats: {...this.stats},
            result
        };
    }
    
    // ä¿å­˜æœ€é«˜åˆ†
    saveHighScore(score, result) {
        const key = 'rougecow_highscores';
        let scores = JSON.parse(localStorage.getItem(key) || '[]');
        scores.push({
            score,
            result,
            date: new Date().toISOString(),
            stats: {...this.stats}
        });
        scores.sort((a, b) => b.score - a.score);
        scores = scores.slice(0, 10); // åªä¿ç•™å‰10
        localStorage.setItem(key, JSON.stringify(scores));
    }
    
    // è·å–æ’è¡Œæ¦œ
    getHighScores() {
        return JSON.parse(localStorage.getItem('rougecow_highscores') || '[]');
    }
    
    // æ ¼å¼åŒ–æ˜¾ç¤º
    formatScore() {
        return this.score.toLocaleString();
    }
}

// ============================================================================

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // åˆ†æ•°ç³»ç»Ÿ
        this.scoreManager = new ScoreManager();
        
        // å…¨å±é€‚é…
        this.fullscreen = new FullscreenAdapter(this.canvas, 900, 600);
        
        // ç›¸æœºç³»ç»Ÿ
        this.camera = new SurvivorCamera();
        
        // ç©ºé—´ç½‘æ ¼ï¼ˆç¢°æ’ä¼˜åŒ–ï¼‰
        this.spatialGrid = new SpatialGrid();
        
        this.sprites = new SpriteLoader();
        this.state = 'loading';
        
        // ç©å®¶åˆå§‹ä½ç½® - æ‰¾å®‰å…¨ä½ç½®ï¼ˆé¿å¼€éšœç¢ç‰©ï¼‰
        let startX = SURVIVOR_CONFIG.ROOM_WIDTH / 2;
        let startY = SURVIVOR_CONFIG.ROOM_HEIGHT / 2;
        
        // æ£€æŸ¥ä¸­å¿ƒæ˜¯å¦æœ‰éšœç¢ç‰©ï¼Œå¦‚æœæœ‰å°±å°è¯•å…¶ä»–ä½ç½®
        const wallT = 60;  // å¢™åšåº¦æ”¹å°
        const safePositions = [
            {x: startX, y: startY},                    // ä¸­å¿ƒ
            {x: startX - 100, y: startY},              // å·¦
            {x: startX + 100, y: startY},              // å³
            {x: startX, y: startY - 100},              // ä¸Š
            {x: startX, y: startY + 100},              // ä¸‹
            {x: startX - 150, y: startY - 150},        // å·¦ä¸Š
            {x: startX + 150, y: startY - 150},        // å³ä¸Š
            {x: startX - 150, y: startY + 150},        // å·¦ä¸‹
            {x: startX + 150, y: startY + 150},        // å³ä¸‹
            {x: wallT + 50, y: wallT + 50},            // å·¦ä¸Šè§’é™„è¿‘
            {x: SURVIVOR_CONFIG.ROOM_WIDTH - wallT - 50, y: wallT + 50}, // å³ä¸Šè§’
            {x: wallT + 50, y: SURVIVOR_CONFIG.ROOM_HEIGHT - wallT - 50}, // å·¦ä¸‹è§’
            {x: SURVIVOR_CONFIG.ROOM_WIDTH - wallT - 50, y: SURVIVOR_CONFIG.ROOM_HEIGHT - wallT - 50} // å³ä¸‹è§’
        ];
        
        let safePos = safePositions[0];
        
        this.player = { x: safePos.x, y: safePos.y, hp: 6, maxHp: 6, exp: 0, lv: 1, gold: 100, 
            facingRight: true, isMoving: false, walkCycle: 0,
            isDashing: false, dashTime: 0, dashCooldown: 0, dashDirection: {x:0, y:0}, dashTrail: [], jumpY: 0
        };
        
        // ç›¸æœºè·Ÿéšç©å®¶
        this.camera.follow(this.player);
        this.items = new ItemManager(this.player);
        this.totems = new TotemManager();
        this.materials = new MaterialManager(); // ææ–™ç³»ç»Ÿ
        this.weapons = [new Weapon('wand', 1)];  // é»˜è®¤æ­¦å™¨æ”¹ä¸ºé­”æ–ï¼ˆè¿œç¨‹ï¼‰
        this.bullets = [];
        this.particles = new ParticleSystem();
        this.gems = [];
        this.goldDrops = [];
        
        this.currentFloor = 1;
        this.maxFloors = 6; // 6å±‚åœ°å›¾ï¼šèŒä¸åŒºã€å­µåŒ–æ¸©å®¤ã€ç¥ç»ç´¢ã€æ¶ˆåŒ–ç†”ç‚‰ã€æ¯è™«åº­é™¢ã€åƒæ ¹ä¹‹å¿ƒ
        this.allFloors = new Map();
        
        // å…ˆåˆå§‹åŒ–ç›¸æœºè§†é‡ï¼Œç¡®ä¿æˆ¿é—´å°ºå¯¸æ­£ç¡®
        this.camera.updateViewport();
        
        // ç­‰å¾…ä¸€å¸§ç¡®ä¿ canvas å°ºå¯¸æ­£ç¡®
        setTimeout(() => {
            this.camera.updateViewport();
            // é‡æ–°ç”Ÿæˆåœ°å›¾ä»¥ä½¿ç”¨æ­£ç¡®çš„æˆ¿é—´å°ºå¯¸
            this.regenerateMap();
        }, 0);
        
        // ä¸´æ—¶åœ°å›¾ï¼ˆä¼šè¢«æ›¿æ¢ï¼‰
        const gen = new MapGenerator();
        const map = gen.generate(1);
        this.curRoom = map.start;
        this.allRooms = map.rooms;
        this.curRoom.visited = true;
        this.allFloors.set(1, { start: map.start, rooms: map.rooms });
        
        this.keys = {};
        this.transition = { active: false, timer: 0, dir: null, target: null };
        this.rafId = null;
        this.godMode = false;
        
        this.shopOpen = false;
        this.shopItems = [];
        this.shopSelected = -1;
        
        this.evolutionOpen = false; // æ­¦å™¨è¿›åŒ–ç•Œé¢
        this.evolutionSelected = -1;
        
        this.weaponSelectOpen = false; // 3é€‰1æ­¦å™¨é€‰æ‹©ç•Œé¢
        this.weaponOptions = [];
        
        this.sounds = new SoundManager();
        
        // æ—¶é—´ç¼©æ”¾ï¼ˆæ¸¸æˆé€Ÿåº¦ï¼‰
        this.timeScale = 1;
        
        this.setupInput();
        
        // æš´éœ²åˆ°å…¨å±€ä¾›æŒ‰é’®è°ƒç”¨
        window.game = this;
    }
    
    setSpeed(speed) {
        this.timeScale = speed;
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.speed) === speed);
        });
        document.getElementById('speedLabel').textContent = `æ¸¸æˆé€Ÿåº¦: ${speed}x`;
        console.log(`âš¡ æ¸¸æˆé€Ÿåº¦è®¾ç½®ä¸º ${speed}x`);
    }
    
    // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
    updateScoreDisplay() {
        const sm = this.scoreManager;
        if (!sm.isPlaying) return;
        
        // é¡¶éƒ¨ä¸­å¤®åˆ†æ•°
        const scoreValue = document.getElementById('scoreValue');
        if (scoreValue) scoreValue.textContent = sm.formatScore();
        
        // è¿æ€æ˜¾ç¤º
        const streakEl = document.getElementById('killStreak');
        if (streakEl) {
            if (sm.killStreak >= 3) {
                streakEl.style.display = 'block';
                document.getElementById('streakCount').textContent = sm.killStreak;
            } else {
                streakEl.style.display = 'none';
            }
        }
    }
    
    // ç»“æŸæ¸¸æˆå¹¶è®¡ç®—åˆ†æ•°
    endGame(result) {
        const scoreData = this.scoreManager.end(result);
        console.log('ğŸ† æ¸¸æˆç»“æŸï¼åˆ†æ•°ç»Ÿè®¡ï¼š', scoreData);
        
        // éšè—æ¸¸æˆå¸ƒå±€
        document.getElementById('mainLayout').style.display = 'none';
        document.getElementById('topScoreBar').style.display = 'none';
        document.getElementById('bottomStatusBar').style.display = 'none';
        document.getElementById('floorIndicator').style.display = 'none';
        
        // æ˜¾ç¤ºç»“æœ
        const resultText = result === 'cleared' ? 'é€šå…³ï¼' : result === 'dead' ? 'é˜µäº¡' : 'ç»“æŸ';
        alert(`æ¸¸æˆ${resultText}\næœ€ç»ˆåˆ†æ•°: ${scoreData.finalScore.toLocaleString()}\nå‡»æ€: ${scoreData.stats.enemiesKilled} | æ¢ç´¢: ${scoreData.stats.roomsExplored}é—´`);
        
        return scoreData;
    }
    
    // åˆå§‹åŒ–é“å…·æ ¼å­
    initItemGrid() {
        const grid = document.getElementById('sidebarItems');
        if (!grid) return;
        grid.innerHTML = '';
        for (let i = 0; i < 20; i++) {
            const slot = document.createElement('div');
            slot.className = 'item-cell';
            slot.id = `sidebarItem${i}`;
            grid.appendChild(slot);
        }
    }
    
    // æ›´æ–°ä¾§è¾¹é¢æ¿
    updateSidePanels() {
        // å·¦ä¾§è¾¹æ  - è§’è‰²çŠ¶æ€
        const hpEl = document.getElementById('sidebarHp');
        if (hpEl) hpEl.textContent = `${this.player.hp}/${this.player.maxHp}`;
        
        const lvEl = document.getElementById('sidebarLv');
        if (lvEl) lvEl.textContent = `Lv.${this.player.lv}`;
        
        const goldEl = document.getElementById('sidebarGold');
        if (goldEl) goldEl.textContent = this.player.gold;
        
        const floorEl = document.getElementById('sidebarFloor');
        if (floorEl) floorEl.textContent = `${this.currentFloor}/${this.maxFloors}`;
        
        // æ­¦å™¨åˆ—è¡¨
        const weaponList = document.getElementById('sidebarWeapons');
        if (weaponList) {
            weaponList.innerHTML = '';
            // å¹¸å­˜è€…æ¨¡å¼ï¼šæ˜¾ç¤ºæ‰€æœ‰å·²è£…å¤‡æ­¦å™¨
            this.weapons.forEach((w) => {
                const div = document.createElement('div');
                div.className = 'weapon-item';
                div.innerHTML = `
                    <span class="weapon-icon">${w.cfg.icon}</span>
                    <span class="weapon-name">${w.cfg.name}</span>
                    <span class="weapon-lv">Lv.${w.level}${w.evolution ? 'â˜…' : ''}</span>
                `;
                weaponList.appendChild(div);
            });
        }
        
        // ææ–™
        const matsEl = document.getElementById('sidebarMaterials');
        if (matsEl) {
            const mats = this.materials.getAll();
            if (mats.length > 0) {
                matsEl.innerHTML = mats.map(m => `${m.icon}${m.count}`).join(' ');
            } else {
                matsEl.textContent = 'æš‚æ— ';
            }
        }
        
        // æˆ˜æ–—å±æ€§
        if (this.items) {
            const stats = this.items.getStats();
            // å¹¸å­˜è€…æ¨¡å¼ï¼šæ˜¾ç¤ºæ‰€æœ‰æ­¦å™¨æ€»DPS
            const dmgEl = document.getElementById('sidebarDmg');
            if (dmgEl && this.weapons.length > 0) {
                // è®¡ç®—æ‰€æœ‰æ­¦å™¨çš„å¹³å‡ä¼¤å®³
                let totalDmg = 0;
                this.weapons.forEach(w => {
                    totalDmg += Math.floor(w.cfg.dmg * (1 + (w.level - 1) * 0.15) * stats.projSize);
                });
                dmgEl.textContent = totalDmg;
            }
            
            // ç§»é€Ÿ
            const speedEl = document.getElementById('sidebarSpeed');
            if (speedEl) {
                const speedPercent = Math.floor(stats.speed * 100);
                speedEl.textContent = speedPercent + '%';
            }
            
            // æ”»é€Ÿ
            const fireRateEl = document.getElementById('sidebarFireRate');
            if (fireRateEl) {
                const fireRatePercent = Math.floor(stats.fireRate * 100);
                fireRateEl.textContent = fireRatePercent + '%';
            }
            
            // æš´å‡»ç‡
            const critEl = document.getElementById('sidebarCrit');
            if (critEl) {
                const critPercent = Math.floor(stats.crit * 100);
                critEl.textContent = critPercent + '%';
            }
            
            // æŠ¤ç”²
            const armorEl = document.getElementById('sidebarArmor');
            if (armorEl) {
                armorEl.textContent = stats.armor;
            }
        }
        
        // å³ä¾§è¾¹æ  - æˆ¿é—´ç±»å‹å’ŒçŠ¶æ€
        const roomTypeEl = document.getElementById('sidebarRoomType');
        if (roomTypeEl) {
            const names = { start: 'èµ·ç‚¹', normal: 'æˆ˜æ–—', boss: 'BOSS', treasure: 'å®ç®±', shop: 'å•†åº—', hidden: 'éšè—' };
            roomTypeEl.textContent = names[this.curRoom.type] || 'æœªçŸ¥';
        }
        
        const roomStatusEl = document.getElementById('sidebarRoomStatus');
        if (roomStatusEl) {
            if (this.curRoom.cleared) {
                roomStatusEl.innerHTML = 'âœ“ <span style="color:#4f4">å·²æ¸…ç†</span>';
            } else {
                roomStatusEl.innerHTML = 'ğŸ”’ <span style="color:#f44">é”å®š</span>';
            }
        }
        
        // åˆ†æ•°
        const scoreEl = document.getElementById('sidebarScore');
        if (scoreEl && this.scoreManager) {
            scoreEl.textContent = this.scoreManager.score;
        }
        
        // å‡»æ€
        const killsEl = document.getElementById('sidebarKills');
        if (killsEl && this.scoreManager) {
            killsEl.textContent = this.scoreManager.stats.enemiesKilled;
        }
        
        // æ¢ç´¢
        const roomsEl = document.getElementById('sidebarRooms');
        if (roomsEl && this.scoreManager) {
            roomsEl.textContent = this.scoreManager.stats.roomsExplored;
        }
        
        // é“å…·æ ¼å­ï¼ˆ20æ ¼ï¼‰
        const items = this.items?.items || [];
        for (let i = 0; i < 20; i++) {
            const slot = document.getElementById(`sidebarItem${i}`);
            if (slot) {
                if (items[i]) {
                    slot.textContent = items[i].icon;
                    slot.classList.add('filled');
                    slot.title = items[i].name;
                } else {
                    slot.textContent = '';
                    slot.classList.remove('filled');
                    slot.title = '';
                }
            }
        }
        
        // åº•éƒ¨çŠ¶æ€æ¡
        const bottomFloor = document.getElementById('bottomFloor');
        if (bottomFloor) bottomFloor.textContent = this.currentFloor;
        
        const bottomMaxFloor = document.getElementById('bottomMaxFloor');
        if (bottomMaxFloor) bottomMaxFloor.textContent = this.maxFloors;
        
        const bottomEnemies = document.getElementById('bottomEnemies');
        if (bottomEnemies) bottomEnemies.textContent = this.curRoom.enemies.length;
        
        const bottomRoomStatus = document.getElementById('bottomRoomStatus');
        if (bottomRoomStatus) {
            if (this.curRoom.cleared) {
                bottomRoomStatus.innerHTML = 'âœ“ <span style="color:#4f4">å·²æ¸…ç†</span>';
            } else {
                bottomRoomStatus.innerHTML = 'ğŸ”’ <span style="color:#f44">é”å®š</span>';
            }
        }
        
        // æ›´æ–°å°åœ°å›¾ï¼ˆä»¥æ’’é£æ ¼ï¼šå·²è®¿é—®=å®å¿ƒï¼Œæœªè®¿é—®=è½®å»“ï¼‰
        this.updateMiniMap();
    }
    
    // å°åœ°å›¾åœ¨å³ä¾§è¾¹æ ä»¥æ’’é£æ ¼ç»˜åˆ¶ (updateMiniMap)
    // å·²è®¿é—®æˆ¿é—´=å®å¿ƒï¼Œæœªè®¿é—®æˆ¿é—´=è½®å»“
    async loadSprites() {
        const basePath = 'https://wearescientist.github.io/rouge-cow/assets/sprites/';
        await this.sprites.load('player', basePath + 'player_cow.png');
        
        const enemies = ['chick', 'pig', 'sheep', 'dog', 'cat', 'bear'];
        for (const name of enemies) {
            await this.sprites.load(name, basePath + name + '.png');
            this.updateLoadingProgress();
        }
        
        const specialEnemies = ['rabbit', 'bird', 'turtle', 'dog2'];
        for (const name of specialEnemies) {
            await this.sprites.load(name, basePath + name + '.png');
            this.updateLoadingProgress();
        }
    }
    
    updateLoadingProgress() {
        const progress = this.sprites.getProgress() * 100;
        const progressBar = document.getElementById('loadingProgress');
        const loadingText = document.getElementById('loadingText');
        if (progressBar) progressBar.style.width = `${progress}%`;
        if (loadingText) loadingText.textContent = `æ­£åœ¨åŠ è½½... ${Math.floor(progress)}%`;
    }
    
    // é‡æ–°ç”Ÿæˆåœ°å›¾ï¼ˆå½“æˆ¿é—´å°ºå¯¸æ”¹å˜æ—¶è°ƒç”¨ï¼‰
    regenerateMap() {
        const gen = new MapGenerator();
        const map = gen.generate(1);
        this.curRoom = map.start;
        this.allRooms = map.rooms;
        this.curRoom.visited = true;
        this.allFloors.set(1, { start: map.start, rooms: map.rooms });
        
        // é‡æ–°è®¾ç½®ç©å®¶ä½ç½®
        const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
        const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
        this.player.x = roomW / 2;
        this.player.y = roomH / 2;
        this.camera.follow(this.player);
        
        console.log(`ğŸ—ºï¸ åœ°å›¾é‡æ–°ç”Ÿæˆ: ${roomW}x${roomH}`);
    }

    setupInput() {
        window.addEventListener('keydown', e => {
            this.keys[e.key] = true;
            
            // æ­¦å™¨è¿›åŒ–ç•Œé¢
            if (e.key === 'v' || e.key === 'V') {
                if (this.evolutionOpen) {
                    this.closeEvolution();
                } else {
                    this.openEvolution();
                }
                return;
            }
            
            // è¿›åŒ–ç•Œé¢æ“ä½œ
            if (this.evolutionOpen) {
                if (e.key >= '1' && e.key <= '3') {
                    this.evolveWeapon(parseInt(e.key) - 1);
                }
                return;
            }
            
            // æ­¦å™¨é€‰æ‹©ç•Œé¢æ“ä½œ
            if (this.weaponSelectOpen) {
                if (e.key >= '1' && e.key <= '3') {
                    this.selectWeapon(parseInt(e.key) - 1);
                }
                return;
            }
            
            // å•†åº—äº¤äº’
            if (e.key === 'e' || e.key === 'E') {
                if (this.shopOpen) {
                    this.closeShop();
                } else if (this.curRoom.type === 'shop' && this.curRoom.npc) {
                    const d = dist(this.player.x, this.player.y, this.curRoom.npc.x, this.curRoom.npc.y);
                    if (d < 80) {
                        this.openShop();
                    }
                }
            }
            
            if (this.shopOpen) {
                if (e.key >= '1' && e.key <= '3') {
                    this.buyItem(parseInt(e.key) - 1);
                }
                return;
            }
            
            if (e.key >= '1' && e.key <= '9') {
                const id = parseInt(e.key);
                if (this.items.add(id)) {
                    this.particles.burst(this.player.x, this.player.y, '#ff0', 15);
                }
            }
            
            if (e.key === 'f' || e.key === 'F') {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }
            
            if (e.key === 'g' || e.key === 'G') {
                this.godMode = !this.godMode;
                console.log(`æ— æ•Œæ¨¡å¼: ${this.godMode ? 'å¼€å¯' : 'å…³é—­'}`);
            }
            
            // é€Ÿåº¦è°ƒæ•´å¿«æ·é”® -/+ (æˆ– =)
            if (e.key === '-' || e.key === '_') {
                const speeds = [1, 2, 5, 10];
                const currentIdx = speeds.indexOf(this.timeScale);
                const newIdx = Math.max(0, currentIdx - 1);
                this.setSpeed(speeds[newIdx]);
            }
            if (e.key === '=' || e.key === '+' || e.key === '0') {
                const speeds = [1, 2, 5, 10];
                const currentIdx = speeds.indexOf(this.timeScale);
                const newIdx = Math.min(speeds.length - 1, currentIdx + 1);
                this.setSpeed(speeds[newIdx]);
            }
            
            // å­˜æ¡£åŠŸèƒ½å¿«æ·é”®ï¼ˆç¬¬5æ¬¡è¿­ä»£ï¼‰
            if (e.key === 'l' || e.key === 'L') {
                if (this.hasSave()) {
                    this.loadGame();
                    this.particles.burst(this.player.x, this.player.y, '#48f', 20);
                    console.log('ğŸ“‚ å·²åŠ è½½å­˜æ¡£');
                } else {
                    console.log('âŒ æ— å­˜æ¡£å¯åŠ è½½');
                }
            }
            if (e.key === 'k' || e.key === 'K') {
                this.saveGame();
                this.particles.burst(this.player.x, this.player.y, '#4f4', 20);
                console.log('ğŸ’¾ å·²æ‰‹åŠ¨å­˜æ¡£');
            }
        });
        
        window.addEventListener('keyup', e => this.keys[e.key] = false);
    }
    
    openEvolution() {
        this.evolutionOpen = true;
        console.log('æ­¦å™¨è¿›åŒ–ç•Œé¢å·²æ‰“å¼€');
    }
    
    closeEvolution() {
        this.evolutionOpen = false;
        this.evolutionSelected = -1;
        console.log('æ­¦å™¨è¿›åŒ–ç•Œé¢å·²å…³é—­');
    }
    
    evolveWeapon(index, weaponIdx = 0) {
        // å¹¸å­˜è€…æ¨¡å¼ï¼šé»˜è®¤è¿›åŒ–ç¬¬ä¸€ä¸ªæ­¦å™¨ï¼ˆå¯ä»¥æ‰©å±•ä¸ºé€‰æ‹©è¿›åŒ–å“ªä¸ªæ­¦å™¨ï¼‰
        const weapon = this.weapons[weaponIdx];
        if (!weapon) return;
        
        const evolutions = WEAPON_EVOLUTIONS[weapon.baseKey];
        if (!evolutions) return;
        
        const evoKeys = Object.keys(evolutions);
        if (index >= evoKeys.length) return;
        
        const evoKey = evoKeys[index];
        const evoData = evolutions[evoKey];
        
        // æ£€æŸ¥ææ–™
        let canEvolve = true;
        for (const [mat, count] of Object.entries(evoData.req)) {
            if (!this.materials.has(mat, count)) {
                canEvolve = false;
                break;
            }
        }
        
        if (canEvolve) {
            // æ¶ˆè€—ææ–™
            for (const [mat, count] of Object.entries(evoData.req)) {
                this.materials.consume(mat, count);
            }
            
            // è¿›åŒ–æ­¦å™¨
            const oldName = weapon.cfg.name;
            this.weapons[this.activeWeapon] = new Weapon(weapon.baseKey, weapon.level, evoKey);
            
            this.particles.burst(this.player.x, this.player.y, '#f0f', 30);
            this.sounds.play('evolve');
            console.log(`æ­¦å™¨è¿›åŒ–: ${oldName} â†’ ${evoData.name}`);
            
            this.closeEvolution();
        } else {
            console.log('ææ–™ä¸è¶³ï¼Œæ— æ³•è¿›åŒ–');
        }
    }
    
    // å¹¸å­˜è€…æ¨¡å¼ï¼š3é€‰1æ­¦å™¨é€‰æ‹©ç•Œé¢
    openWeaponSelect() {
        this.weaponSelectOpen = true;
        // éšæœº3ä¸ªæ­¦å™¨é€‰é¡¹
        const allWeaponKeys = Object.keys(WEAPONS);
        this.weaponOptions = [];
        while (this.weaponOptions.length < 3 && allWeaponKeys.length > 0) {
            const idx = Math.floor(Math.random() * allWeaponKeys.length);
            const key = allWeaponKeys.splice(idx, 1)[0];
            // å¦‚æœå·²æ‹¥æœ‰è¯¥æ­¦å™¨ï¼Œåˆ™æä¾›å‡çº§ç‰ˆæœ¬
            const existing = this.weapons.find(w => w.cfg.key === key);
            this.weaponOptions.push({
                key: key,
                isNew: !existing,
                level: existing ? existing.level + 1 : 1,
                cfg: WEAPONS[key]
            });
        }
        console.log('æ­¦å™¨é€‰æ‹©ç•Œé¢å·²æ‰“å¼€', this.weaponOptions);
    }
    
    closeWeaponSelect() {
        this.weaponSelectOpen = false;
        this.weaponOptions = [];
    }
    
    selectWeapon(index) {
        if (index >= this.weaponOptions.length) return;
        const option = this.weaponOptions[index];
        
        const existingIdx = this.weapons.findIndex(w => w.cfg.key === option.key);
        if (existingIdx >= 0) {
            // å‡çº§ç°æœ‰æ­¦å™¨
            const leveledUp = this.weapons[existingIdx].addXp(100);
            if (leveledUp) {
                this.particles.burst(this.player.x, this.player.y, '#f0f', 20);
                console.log(`æ­¦å™¨å‡çº§: ${option.cfg.name} Lv.${this.weapons[existingIdx].level}`);
            }
        } else if (this.weapons.length < 6) {
            // æ·»åŠ æ–°æ­¦å™¨
            this.weapons.push(new Weapon(option.key, 1));
            console.log(`è·å¾—æ–°æ­¦å™¨: ${option.cfg.name}`);
        }
        
        this.closeWeaponSelect();
    }
    
    openShop() {
        if (this.shopItems.length === 0) {
            const itemIds = Object.keys(ITEMS).map(Number);
            const selected = [];
            while (selected.length < 3 && itemIds.length > 0) {
                const idx = Math.floor(Math.random() * itemIds.length);
                const itemId = itemIds.splice(idx, 1)[0];
                const item = ITEMS[itemId];
                if (item) {
                    selected.push({
                        id: itemId,
                        icon: item.icon,
                        name: item.name,
                        desc: item.desc,
                        price: getItemPrice(itemId),
                        rarity: item.rarity
                    });
                }
            }
            this.shopItems = selected;
        }
        this.shopOpen = true;
        console.log('å•†åº—å·²æ‰“å¼€');
    }
    
    closeShop() {
        this.shopOpen = false;
        this.shopSelected = -1;
        console.log('å•†åº—å·²å…³é—­');
    }
    
    buyItem(index) {
        if (index < 0 || index >= this.shopItems.length) return;
        const item = this.shopItems[index];
        if (this.player.gold >= item.price) {
            this.player.gold -= item.price;
            this.items.add(item.id);
            this.particles.burst(this.player.x, this.player.y, '#ff0', 20);
            this.sounds.play('buy');
            this.shopItems.splice(index, 1);
            console.log(`è´­ä¹°æˆåŠŸ: ${item.name}`);
        } else {
            console.log('é‡‘å¸ä¸è¶³');
        }
    }

    async start() {
        await this.loadSprites();
        this.sounds.init();
        document.getElementById('loading').classList.add('hidden');
        
        // çª—å£å¤§å°å˜åŒ–æ—¶æ›´æ–°ç›¸æœºè§†é‡
        window.addEventListener('resize', () => {
            if (this.camera) {
                this.camera.updateViewport();
            }
        });
        
        document.getElementById('story').style.display = 'block';
        document.getElementById('startGameBtn').addEventListener('click', () => {
            document.getElementById('story').style.display = 'none';
            this.state = 'playing';
            // æ˜¾ç¤ºæ¸¸æˆå¸ƒå±€
            document.getElementById('mainLayout').classList.add('active');
            document.getElementById('topScoreBar').style.display = 'block';
            document.getElementById('bottomStatusBar').style.display = 'flex';
            // åˆå§‹åŒ–ç›¸æœºè§†é‡
            this.camera.updateViewport();
            // åˆå§‹åŒ–é“å…·æ ¼å­
            this.initItemGrid();
            // å¯åŠ¨åˆ†æ•°ç³»ç»Ÿ
            this.scoreManager.start();
            this.updateScoreDisplay();
            this.loop(0);
        });
    }

    update(dt) {
        if (this.shopOpen || this.evolutionOpen || this.weaponSelectOpen) return;
        
        // æ›´æ–°æˆ¿é—´ï¼ˆæ³¢æ¬¡ç³»ç»Ÿï¼‰
        this.curRoom.update(dt);
        
        if (this.transition.active) {
            this.transition.timer -= dt;
            if (this.transition.timer <= 0) {
                this.curRoom = this.transition.target;
                this.curRoom.visited = true;
                // åˆ†æ•°ï¼šè¿›å…¥æ–°æˆ¿é—´
                this.scoreManager.onEnterRoom();
                const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
                const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
                const wallT = 60;
                // ä¼ é€ä½ç½®ï¼šè¿œç¦»é—¨åŒºåŸŸï¼Œå¾€æˆ¿é—´ä¸­å¿ƒç§»åŠ¨ 150px
                const spawnOffset = 150;
                if (this.transition.dir === 'left') this.player.x = roomW - wallT - spawnOffset;
                else if (this.transition.dir === 'right') this.player.x = wallT + spawnOffset;
                else this.player.x = roomW / 2;
                
                if (this.transition.dir === 'up') this.player.y = roomH - wallT - spawnOffset;
                else if (this.transition.dir === 'down') this.player.y = wallT + spawnOffset;
                else this.player.y = roomH / 2;
                
                this.transition.active = false;
                // è‡ªåŠ¨å­˜æ¡£ï¼ˆè¿›å…¥æ–°æˆ¿é—´æ—¶ï¼‰
                this.saveGame();
            }
            return;
        }

        const stats = this.items.getStats();
        const totemBonuses = this.totems.getAllBonuses();
        stats.dmg = (stats.dmg || 1) * (1 + totemBonuses.dmg);
        stats.maxHp += totemBonuses.maxHp;
        stats.speed *= (1 + totemBonuses.speed);
        stats.crit = Math.min(1, stats.crit + totemBonuses.crit);
        
        const speed = 300 * stats.speed;  // ç§»é€Ÿç¿»å€
        
        // å†²åˆºå†·å´æ›´æ–°
        if (this.player.dashCooldown > 0) this.player.dashCooldown -= dt;
        
        // å†²åˆºå¤„ç†
        if (this.player.isDashing) {
            this.player.dashTime -= dt;
            if (this.player.dashTime <= 0) {
                this.player.isDashing = false;
                this.player.jumpY = 0;
            } else {
                // å†²åˆºä¸­ - å¿«é€Ÿç§»åŠ¨
                const dashSpeed = 400;
                this.player.x += this.player.dashDirection.x * dashSpeed * dt;
                this.player.y += this.player.dashDirection.y * dashSpeed * dt;
                // è·³è·ƒå¼§çº¿
                const progress = 1 - (this.player.dashTime / 0.15);
                this.player.jumpY = -Math.sin(progress * Math.PI) * 12;
                // æ·»åŠ æ®‹å½±
                if (Math.random() < 0.5) {
                    this.player.dashTrail.push({x: this.player.x, y: this.player.y + this.player.jumpY, alpha: 0.5});
                }
            }
        }
        
        // æ™®é€šç§»åŠ¨
        let dx = 0, dy = 0;
        if (this.keys['w'] || this.keys['W'] || this.keys['ArrowUp']) dy -= 1;
        if (this.keys['s'] || this.keys['S'] || this.keys['ArrowDown']) dy += 1;
        if (this.keys['a'] || this.keys['A'] || this.keys['ArrowLeft']) { dx -= 1; this.player.facingRight = false; }
        if (this.keys['d'] || this.keys['D'] || this.keys['ArrowRight']) { dx += 1; this.player.facingRight = true; }
        
        // ç©ºæ ¼å†²åˆºè§¦å‘
        if (this.keys[' '] && this.player.dashCooldown <= 0 && !this.player.isDashing) {
            if (dx !== 0 || dy !== 0) {
                const len = Math.sqrt(dx*dx + dy*dy);
                this.player.isDashing = true;
                this.player.dashTime = 0.15;
                this.player.dashCooldown = 0.6;
                this.player.dashDirection = {x: dx/len, y: dy/len};
            }
        }
        
        this.player.isMoving = (dx !== 0 || dy !== 0);
        if (this.player.isMoving && !this.player.isDashing) {
            this.player.walkCycle += dt * 15;
        } else {
            this.player.walkCycle = 0;
        }
        
        // æ›´æ–°æ®‹å½±
        for (let i = this.player.dashTrail.length - 1; i >= 0; i--) {
            this.player.dashTrail[i].alpha -= 0.1;
            if (this.player.dashTrail[i].alpha <= 0) this.player.dashTrail.splice(i, 1);
        }
        
        if ((dx !== 0 || dy !== 0) && !this.player.isDashing) {
            const len = Math.sqrt(dx*dx + dy*dy);
            const newX = this.player.x + (dx / len) * speed * dt;
            const newY = this.player.y + (dy / len) * speed * dt;
            
            const wallThickness = 40;
            
            let canMoveX = true;
            const roomWidth = SURVIVOR_CONFIG.ROOM_WIDTH;
            const roomHeight = SURVIVOR_CONFIG.ROOM_HEIGHT;
            const centerX = roomWidth / 2;
            const centerY = roomHeight / 2;
            
            if (newX < wallThickness) {
                if (!(this.player.y > centerY - 40 && this.player.y < centerY + 40 && this.curRoom.doors.left && this.curRoom.doors.left.open)) {
                    canMoveX = false;
                }
            }
            if (newX > roomWidth - wallThickness) {
                if (!(this.player.y > centerY - 40 && this.player.y < centerY + 40 && this.curRoom.doors.right && this.curRoom.doors.right.open)) {
                    canMoveX = false;
                }
            }
            
            let canMoveY = true;
            if (newY < wallThickness) {
                if (!(this.player.x > centerX - 30 && this.player.x < centerX + 30 && this.curRoom.doors.up && this.curRoom.doors.up.open)) {
                    canMoveY = false;
                }
            }
            if (newY > roomHeight - wallThickness) {
                if (!(this.player.x > centerX - 30 && this.player.x < centerX + 30 && this.curRoom.doors.down && this.curRoom.doors.down.open)) {
                    canMoveY = false;
                }
            }
            
            if (canMoveX) this.player.x = newX;
            if (canMoveY) this.player.y = newY;
        }
        
        // ç©å®¶è¾¹ç•Œé™åˆ¶ - æœ‰é—¨çš„åœ°æ–¹å…è®¸èµ°å‡ºå»ï¼ˆèµ°è¿›é—¨è§¦å‘ä¼ é€ï¼‰
        let minX = 0, maxX = SURVIVOR_CONFIG.ROOM_WIDTH;
        let minY = 0, maxY = SURVIVOR_CONFIG.ROOM_HEIGHT;
        
        // å¦‚æœæ²¡æœ‰é—¨ï¼Œé™åˆ¶åœ¨å¢™å†…
        if (!this.curRoom.doors.left) minX = 60;
        if (!this.curRoom.doors.right) maxX = SURVIVOR_CONFIG.ROOM_WIDTH - 60;
        if (!this.curRoom.doors.up) minY = 60;
        if (!this.curRoom.doors.down) maxY = SURVIVOR_CONFIG.ROOM_HEIGHT - 60;
        
        this.player.x = clamp(this.player.x, minX, maxX);
        this.player.y = clamp(this.player.y, minY, maxY);
        
        // é—¨ä¼ é€æ£€æµ‹ - ä¸ Room.draw ä¸­çš„é—¨ä½ç½®ä¿æŒä¸€è‡´ï¼ˆé—¨å’Œå¢™å¹³é½ï¼‰
        if (this.curRoom.cleared) {
            const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
            const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
            const wallT = 60;
            const centerX = roomW / 2;
            const centerY = roomH / 2;
            for (const [dir, door] of Object.entries(this.curRoom.doors)) {
                if (!door || !door.open) continue;
                // é—¨ä½ç½®ä¸ Room.draw ä¸­ä¸€è‡´ï¼ˆå’Œå¢™å¹³é½ï¼‰
                const pos = { 
                    up: [centerX - 40, 0, 80, wallT],              // ä¸Š: y=0, h=60
                    down: [centerX - 40, roomH - wallT, 80, wallT], // ä¸‹: y=740, h=60
                    left: [0, centerY - 50, wallT, 100],           // å·¦: x=0, w=60
                    right: [roomW - wallT, centerY - 50, wallT, 100] // å³: x=1140, w=60
                }[dir];
                if (this.player.x > pos[0] && this.player.x < pos[0] + pos[2] &&
                    this.player.y > pos[1] && this.player.y < pos[1] + pos[3]) {
                    this.transition = { active: true, timer: 0.3, dir, target: door.target };
                    break;
                }
            }
        }
        
        // æ›´æ–°æ•Œäººï¼ˆä½¿ç”¨æ³¢æ¬¡ç®¡ç†å™¨çš„æ´»è·ƒæ•Œäººï¼‰
        const activeEnemies = this.curRoom.getActiveEnemies ? this.curRoom.getActiveEnemies() : this.curRoom.enemies;
        for (const e of activeEnemies) {
            if (e.hp <= 0) continue;
            e.update(dt, this.player, this.curRoom);
            const d = dist(e.x, e.y, this.player.x, this.player.y);
            if (d < 25 && e.attackCd <= 0) {
                if (!this.godMode && !this.player.isDashing) {
                    const actualDmg = Math.max(0, e.dmg - stats.armor);
                    this.player.hp -= actualDmg;
                    // åˆ†æ•°ï¼šå—ä¼¤æ‰£åˆ†
                    if (actualDmg > 0) this.scoreManager.onDamage();
                }
                e.attackCd = 0.5;
                if (this.player.hp <= 0) this.state = 'gameover';
            }
        }
        
        if (this.curRoom.enemies.length === 0 && !this.curRoom.cleared) {
            this.curRoom.cleared = true;
            for (const door of Object.values(this.curRoom.doors)) {
                if (door) door.open = true;
            }
            this.particles.burst(this.player.x, this.player.y, '#4f4', 30);
            
            if (this.curRoom.type === 'boss') {
                this.state = 'victory';
                this.spawnTotemPickup();
                return;
            }
            
            this.spawnRoomReward();
        }
        
        // å¯»æ‰¾æœ€è¿‘ç›®æ ‡ï¼ˆä»æ´»è·ƒæ•Œäººä¸­ï¼‰
        let target = null, minD = 9999;
        for (const e of activeEnemies) {
            if (e.hp <= 0) continue;
            const d = dist(e.x, e.y, this.player.x, this.player.y);
            if (d < minD) { minD = d; target = e; }
        }
        
        // å¹¸å­˜è€…æ¨¡å¼ï¼šæ‰€æœ‰æ­¦å™¨ç‹¬ç«‹æ›´æ–°å’Œå¼€ç«
        for (const w of this.weapons) {
            w.update(dt);
            if (w.canFire() && target) {
                this.bullets.push(...w.fire(this.player, target, stats));
                this.sounds.play('shoot');
            }
        }
        
        // å­å¼¹è¾¹ç•Œæ£€æŸ¥ï¼ˆå¤§æˆ¿é—´ï¼‰
        const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
        const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            const b = this.bullets[i];
            
            if (b.x < 0 || b.x > roomW || b.y < 0 || b.y > roomH) {
                this.bullets.splice(i, 1);
                continue;
            }
            
            if (b.homing && b.target && activeEnemies.includes(b.target)) {
                const dx = b.target.x - b.x;
                const dy = b.target.y - b.y;
                const d = Math.sqrt(dx*dx + dy*dy);
                if (d > 0) {
                    const targetAngle = Math.atan2(dy, dx);
                    const currentAngle = Math.atan2(b.vy, b.vx);
                    let angleDiff = targetAngle - currentAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    const turnRate = 3 * dt;
                    const newAngle = currentAngle + Math.max(-turnRate, Math.min(turnRate, angleDiff));
                    const spd = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
                    b.vx = Math.cos(newAngle) * spd;
                    b.vy = Math.sin(newAngle) * spd;
                }
            }
            
            b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
            
            if (b.life <= 0) { this.bullets.splice(i, 1); continue; }
            
            let hit = false;
            // ä½¿ç”¨ç©ºé—´ç½‘æ ¼ä¼˜åŒ–ç¢°æ’æ£€æµ‹
            const nearbyEnemies = this.spatialGrid.getNearby(b.x, b.y);
            for (const e of nearbyEnemies) {
                if (e.hp <= 0) continue;
                if (dist(b.x, b.y, e.x, e.y) < 20 && !b.hits.has(e)) {
                    b.hits.add(e);
                    
                    // è®¡ç®—æ€»ä¼¤å®³
                    let totalDmg = b.dmg;
                    if (stats.fireDmg) totalDmg += stats.fireDmg;
                    if (stats.thunderDmg && Math.random() < 0.3) totalDmg += stats.thunderDmg;
                    
                    const killed = e.takeDamage(totalDmg, stats);
                    
                    if (stats.poisonDmg) e.applyPoison(stats.poisonDmg, 3);
                    if (stats.healOnHit) {
                        this.player.hp = Math.min(this.player.maxHp, this.player.hp + stats.healOnHit);
                    }
                    
                    if (killed) {
                        e.hp = 0; // æ ‡è®°æ­»äº¡
                        this.gems.push({ x: e.x, y: e.y, v: e.exp || 10, life: 30 });
                        // é‡‘å¸ç›´æ¥åŠ ï¼Œä¸æ‰è½
                        const goldAmount = e.gold || 5;
                        this.player.gold += goldAmount;
                        // æ˜¾ç¤ºé‡‘å¸é£˜å­—æ•ˆæœ
                        this.particles.burst(e.x, e.y, '#fc0', 5);
                        
                        // ææ–™æ‰è½
                        if (Math.random() < 0.15) {
                            const matTypes = Object.keys(MATERIALS);
                            const matType = randChoice(matTypes);
                            this.materials.add(matType, 1);
                            console.log(`è·å¾—ææ–™: ${MATERIALS[matType].name}`);
                        }
                        
                        // åˆ†æ•°ï¼šå‡»æ€æ•Œäºº
                        const enemyType = e.isBoss ? 'boss' : (e.elite || e.hp > 50) ? 'elite' : 'normal';
                        this.scoreManager.onKillEnemy(enemyType);
                        
                        this.particles.burst(e.x, e.y, e.color, 8);
                        this.sounds.play('kill');
                    } else {
                        this.sounds.play('hit');
                    }
                    if (b.pierce-- <= 0) { hit = true; break; }
                }
            }
            if (hit) this.bullets.splice(i, 1);
        }
        
        for (let i = this.gems.length - 1; i >= 0; i--) {
            const g = this.gems[i];
            const d = dist(g.x, g.y, this.player.x, this.player.y);
            if (d < stats.magnet) {
                g.x += (this.player.x - g.x) * 5 * dt;
                g.y += (this.player.y - g.y) * 5 * dt;
            }
            if (d < 20) {
                this.player.exp += g.v;
                this.gems.splice(i, 1);
                if (this.player.exp >= this.player.lv * 100) {
                    this.player.exp -= this.player.lv * 100;
                    this.player.lv++;
                    this.player.maxHp++;
                    this.player.hp++;
                    this.particles.burst(this.player.x, this.player.y, '#ff0', 20);
                    this.sounds.play('levelup');
                }
            }
        }
        
        // é‡‘å¸ç›´æ¥åŠ ï¼Œæ— éœ€æ‹¾å–
        this.goldDrops = [];
        
        for (let i = this.curRoom.items.length - 1; i >= 0; i--) {
            const item = this.curRoom.items[i];
            const d = dist(item.x, item.y, this.player.x, this.player.y);
            
            if (d < 30) {
                if (item.type === 'weapon') {
                    // å¹¸å­˜è€…æ¨¡å¼ï¼šæ‰“å¼€3é€‰1æ­¦å™¨é€‰æ‹©ç•Œé¢
                    this.openWeaponSelect();
                } else if (item.type === 'totem') {
                    if (this.totems.collect(item.totemId)) {
                        this.particles.burst(item.x, item.y, '#ff0', 30);
                        const totem = TOTEMS[item.totemId];
                        if (totem.effect === 'maxHp') {
                            this.player.maxHp += totem.value;
                            this.player.hp += totem.value;
                        }
                    }
                } else {
                    this.items.add(item.id);
                }
                this.curRoom.items.splice(i, 1);
                this.particles.burst(item.x, item.y, '#ff0', 10);
                // åˆ†æ•°ï¼šæ‹¾å–é“å…·
                this.scoreManager.onCollectItem();
            }
        }
        
        this.particles.update(dt);
    }

    draw() {
        // æ›´æ–°ç›¸æœº
        this.camera.update();
        
        // ä½¿ç”¨ canvas å®é™…å°ºå¯¸
        const canvasW = this.canvas.width;
        const canvasH = this.canvas.height;
        
        // æ¸…ç©ºç”»å¸ƒ
        this.ctx.fillStyle = '#0d0d1a';
        this.ctx.fillRect(0, 0, canvasW, canvasH);
        
        // ä¿å­˜ä¸Šä¸‹æ–‡ç”¨äºç¼©æ”¾
        this.ctx.save();
        if (this.camera.showFullRoom) {
            this.ctx.scale(this.camera.zoom, this.camera.zoom);
        }
        
        // ç»˜åˆ¶æˆ¿é—´ï¼ˆä¼ å…¥ç›¸æœºï¼‰
        this.curRoom.draw(this.ctx, this.camera);
        
        // ç»˜åˆ¶æ‰è½ç‰©ï¼ˆåªç»˜åˆ¶è§†é‡å†…çš„ï¼‰
        // é‡‘å¸ç›´æ¥åŠ ï¼Œæ— éœ€ç»˜åˆ¶
        for (const g of this.gems) {
            if (!this.camera.isVisible(g.x, g.y, 20)) continue;
            const pos = this.camera.worldToScreen(g.x, g.y);
            this.ctx.fillStyle = '#48f';
            this.ctx.beginPath();
            this.ctx.moveTo(pos.x, pos.y - 5);
            this.ctx.lineTo(pos.x + 4, pos.y);
            this.ctx.lineTo(pos.x, pos.y + 5);
            this.ctx.lineTo(pos.x - 4, pos.y);
            this.ctx.fill();
        }
        
        // ç»˜åˆ¶å­å¼¹ï¼ˆä½¿ç”¨æ­¦å™¨å›¾æ ‡ï¼‰
        for (const b of this.bullets) {
            if (!this.camera.isVisible(b.x, b.y, 20)) continue;
            const pos = this.camera.worldToScreen(b.x, b.y);
            
            if (b.icon && b.type !== 'melee') {
                // ä½¿ç”¨emojiå›¾æ ‡ç»˜åˆ¶å­å¼¹
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(b.icon, pos.x, pos.y);
            } else {
                // è¿‘æˆ˜æˆ–æ²¡æœ‰å›¾æ ‡çš„ç”¨åœ†å½¢
                this.ctx.fillStyle = b.color;
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y, b.type === 'melee' ? 15 : 6, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
        
        for (const item of this.curRoom.items) {
            if (!this.camera.isVisible(item.x, item.y, 30)) continue;
            const pos = this.camera.worldToScreen(item.x, item.y);
            
            // è·å–ç‰©å“æè¿°
            let desc = '';
            if (item.type === 'weapon') {
                const w = WEAPONS[item.weaponKey];
                desc = w ? `${w.name}|ä¼¤å®³${w.dmg}|å†·å´${w.cd}s` : 'æ­¦å™¨';
            } else if (item.type === 'totem') {
                const t = TOTEMS[item.totemId];
                desc = t ? `${t.name}|${t.desc}` : 'å›¾è…¾';
            } else {
                const itemData = ITEMS[item.id];
                desc = itemData ? `${itemData.name}|${itemData.desc}` : 'é“å…·';
            }
            
            // ç»˜åˆ¶æè¿°æ–‡å­—ï¼ˆç‰©å“ä¸Šæ–¹ï¼‰
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            this.ctx.fillRect(pos.x - 60, pos.y - 35, 120, 14);
            this.ctx.fillStyle = '#fff';
            this.ctx.font = '10px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(desc.substring(0, 20), pos.x, pos.y - 25);
            
            // ç»˜åˆ¶ç‰©å“å›¾æ ‡
            this.ctx.fillStyle = '#ff0';
            this.ctx.font = '20px Arial';
            this.ctx.fillText(item.icon, pos.x, pos.y + 5);
            
            this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(pos.x, pos.y, 15 + Math.sin(Date.now() / 200) * 3, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        
        // è·å–æ´»è·ƒæ•Œäººå¹¶æ›´æ–°ç©ºé—´ç½‘æ ¼
        const activeEnemies = this.curRoom.hordeManager ? this.curRoom.hordeManager.getActiveEnemies() : this.curRoom.enemies;
        this.spatialGrid.clear();
        for (const e of activeEnemies) {
            if (e.hp > 0) this.spatialGrid.insert(e);
        }
        
        for (const e of activeEnemies) {
            if (!this.camera.isVisible(e.x, e.y, 30)) continue;
            // æ•Œäººä½¿ç”¨ç›¸æœºåæ ‡ç»˜åˆ¶ï¼ˆéœ€è¦åœ¨Enemyç±»ä¸­æ”¯æŒï¼‰
            const pos = this.camera.worldToScreen(e.x, e.y);
            this.ctx.save();
            this.ctx.translate(pos.x, pos.y);
            // ç®€åŒ–çš„æ•Œäººç»˜åˆ¶
            this.ctx.fillStyle = e.color || '#c44';
            this.ctx.beginPath();
            this.ctx.arc(0, 0, e.radius || 15, 0, Math.PI * 2);
            this.ctx.fill();
            // è¡€æ¡
            const hpPercent = e.hp / e.maxHp;
            this.ctx.fillStyle = '#300';
            this.ctx.fillRect(-15, -25, 30, 4);
            this.ctx.fillStyle = hpPercent > 0.5 ? '#4f4' : '#f44';
            this.ctx.fillRect(-15, -25, 30 * hpPercent, 4);
            this.ctx.restore();
        }
        
        if (this.curRoom.type === 'shop' && this.curRoom.npc) {
            const npc = this.curRoom.npc;
            if (this.camera.isVisible(npc.x, npc.y, 40)) {
                const pos = this.camera.worldToScreen(npc.x, npc.y);
                const d = dist(this.player.x, this.player.y, npc.x, npc.y);
                // ç®€åŒ–çš„NPCç»˜åˆ¶
                this.ctx.fillStyle = '#4a4';
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('ğŸ¦¯', pos.x, pos.y + 5);
                if (d < 80 && !this.shopOpen) {
                    this.ctx.fillStyle = '#4f4';
                    this.ctx.fillText('æŒ‰Eäº¤äº’', pos.x, pos.y - 30);
                }
            }
        }
        
        // ç©å®¶å±å¹•åæ ‡
        const playerScreen = this.camera.worldToScreen(this.player.x, this.player.y);
        
        // ç»˜åˆ¶å†²åˆºæ®‹å½±
        for (const trail of this.player.dashTrail) {
            const trailScreen = this.camera.worldToScreen(trail.x, trail.y);
            this.ctx.globalAlpha = trail.alpha * 0.4;
            this.ctx.fillStyle = '#88ccff';
            this.ctx.beginPath();
            this.ctx.arc(trailScreen.x, trailScreen.y, 12, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1;
        
        // ç»˜åˆ¶ç©å®¶ï¼ˆå¸¦åŠ¨ç”»ï¼‰
        const breathY = Math.sin(Date.now() / 300) * 1;
        const totalScreenY = playerScreen.y + (this.player.jumpY || 0) + breathY;
        
        const playerSprite = this.sprites.get('player');
        this.ctx.save();
        this.ctx.translate(playerScreen.x, totalScreenY);
        if (!this.player.facingRight) this.ctx.scale(-1, 1);
        
        if (playerSprite) {
            // ä½¿ç”¨ç²¾çµå›¾ç»˜åˆ¶è§’è‰²ï¼ˆè§’è‰²æœ¬èº«åŒ…å«è„šï¼‰
            this.ctx.drawImage(playerSprite, -16, -16, 32, 32);
        } else {
            // ç¨‹åºåŒ–ç»˜åˆ¶ç‰›ç‰›ï¼ˆç®€åŒ–ç‰ˆï¼Œä¸é¢å¤–ç»˜åˆ¶è„šï¼‰
            this.ctx.fillStyle = '#e8e8e8';
            this.ctx.beginPath();
            this.ctx.ellipse(0, breathY, 13, 10, 0, 0, Math.PI * 2);
            this.ctx.fill();
            // çœ¼ç›
            this.ctx.fillStyle = '#333';
            this.ctx.beginPath();
            this.ctx.arc(12, -6 + breathY, 1.2, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        this.ctx.restore();
        
        // å†²åˆºç‰¹æ•ˆ
        if (this.player.isDashing) {
            this.ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
            this.ctx.lineWidth = 2;
            const dir = this.player.facingRight ? 1 : -1;
            for (let i = 0; i < 3; i++) {
                const offset = (Date.now() / 30 + i * 15) % 25;
                this.ctx.beginPath();
                this.ctx.moveTo(playerScreen.x - dir * (15 + offset), totalScreenY - 10 + i * 8);
                this.ctx.lineTo(playerScreen.x - dir * (25 + offset), totalScreenY - 10 + i * 8);
                this.ctx.stroke();
            }
        }
        
        this.particles.draw(this.ctx);
        
        if (this.transition.active) {
            const alpha = Math.sin(this.transition.timer / 0.3 * Math.PI);
            this.ctx.fillStyle = `rgba(0,0,0,${alpha})`;
            this.ctx.fillRect(0, 0, 900, 600);
        }
        
        // å•†åº—UI
        if (this.shopOpen) {
            this.drawShopUI();
        }
        
        // æ­¦å™¨è¿›åŒ–UI
        if (this.evolutionOpen) {
            this.drawEvolutionUI();
        }
        
        // 3é€‰1æ­¦å™¨é€‰æ‹©UI
        if (this.weaponSelectOpen) {
            this.drawWeaponSelectUI();
        }
        
        // æ¢å¤ä¸Šä¸‹æ–‡
        this.ctx.restore();
        
        // æ›´æ–°ä¾§è¾¹é¢æ¿
        this.updateSidePanels();
        
        this.drawUI();
    }
    
    drawShopUI() {
        const ctx = this.ctx;
        const boxWidth = 500;
        const boxHeight = 350;
        const boxX = 450 - boxWidth / 2;
        const boxY = 300 - boxHeight / 2;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = '#4a4';
        ctx.lineWidth = 3;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        ctx.fillStyle = '#4f4';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ¦¯ ç›²çœ¼çš„å•†åº— ğŸ‘ï¸', 450, boxY + 40);
        
        ctx.fillStyle = '#fc0';
        ctx.font = '18px Arial';
        ctx.fillText(`ğŸ’° ${this.player.gold}`, 450, boxY + 70);
        
        const itemWidth = 130;
        const itemHeight = 160;
        const startX = 450 - (this.shopItems.length * itemWidth) / 2 + itemWidth / 2;
        
        this.shopItems.forEach((item, i) => {
            const ix = startX + i * (itemWidth + 20);
            const iy = boxY + 160;
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(ix - itemWidth/2, iy - itemHeight/2, itemWidth, itemHeight);
            ctx.strokeStyle = this.player.gold >= item.price ? '#4a4' : '#a44';
            ctx.lineWidth = 2;
            ctx.strokeRect(ix - itemWidth/2, iy - itemHeight/2, itemWidth, itemHeight);
            
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(item.icon, ix, iy - 20);
            
            ctx.fillStyle = '#fff';
            ctx.font = '14px Arial';
            ctx.fillText(item.name, ix, iy + 15);
            
            ctx.fillStyle = '#aaa';
            ctx.font = '11px Arial';
            ctx.fillText(item.desc, ix, iy + 35);
            
            ctx.fillStyle = this.player.gold >= item.price ? '#fc0' : '#f44';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`ğŸ’°${item.price}`, ix, iy + 60);
            
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.fillText(`[${i + 1}]`, ix, iy + 80);
        });
        
        ctx.fillStyle = '#888';
        ctx.font = '14px Arial';
        ctx.fillText('æŒ‰ 1-3 è´­ä¹° | æŒ‰ E å…³é—­', 450, boxY + boxHeight - 20);
    }
    
    drawEvolutionUI() {
        const ctx = this.ctx;
        const weapon = this.weapons[this.activeWeapon];
        if (!weapon) return;
        
        const boxWidth = 600;
        const boxHeight = 400;
        const boxX = 450 - boxWidth / 2;
        const boxY = 300 - boxHeight / 2;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = '#f0f';
        ctx.lineWidth = 3;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        ctx.fillStyle = '#f0f';
        ctx.font = 'bold 28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('âš”ï¸ æ­¦å™¨è¿›åŒ– âš”ï¸', 450, boxY + 40);
        
        // å½“å‰æ­¦å™¨
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.fillText(`å½“å‰: ${weapon.cfg.icon} ${weapon.cfg.name} (Lv.${weapon.level})`, 450, boxY + 80);
        
        // ææ–™æ˜¾ç¤º
        ctx.fillStyle = '#aaa';
        ctx.font = '14px Arial';
        const mats = this.materials.getAll();
        if (mats.length > 0) {
            let matText = 'ææ–™: ';
            mats.forEach((m, i) => {
                matText += `${m.icon}${m.count} `;
            });
            ctx.fillText(matText, 450, boxY + 110);
        } else {
            ctx.fillText('ææ–™: æ—  (å‡»è´¥æ•Œäººè·å¾—)', 450, boxY + 110);
        }
        
        // è¿›åŒ–é€‰é¡¹
        const evolutions = WEAPON_EVOLUTIONS[weapon.baseKey];
        if (evolutions) {
            const evoKeys = Object.keys(evolutions);
            const evoWidth = 160;
            const startX = 450 - (evoKeys.length * evoWidth) / 2 + evoWidth / 2;
            
            evoKeys.forEach((evoKey, i) => {
                const evo = evolutions[evoKey];
                const ix = startX + i * (evoWidth + 20);
                const iy = boxY + 220;
                
                // æ£€æŸ¥ææ–™æ˜¯å¦è¶³å¤Ÿ
                let canEvolve = true;
                for (const [mat, count] of Object.entries(evo.req)) {
                    if (!this.materials.has(mat, count)) {
                        canEvolve = false;
                        break;
                    }
                }
                
                ctx.fillStyle = canEvolve ? '#2a1a3a' : '#1a1a1a';
                ctx.fillRect(ix - evoWidth/2, iy - 70, evoWidth, 180);
                ctx.strokeStyle = canEvolve ? '#f0f' : '#444';
                ctx.lineWidth = 2;
                ctx.strokeRect(ix - evoWidth/2, iy - 70, evoWidth, 180);
                
                ctx.font = '40px Arial';
                ctx.fillText(evo.icon, ix, iy - 30);
                
                ctx.fillStyle = canEvolve ? '#fff' : '#666';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(evo.name, ix, iy);
                
                ctx.fillStyle = '#aaa';
                ctx.font = '12px Arial';
                ctx.fillText(evo.desc, ix, iy + 20);
                
                // ææ–™éœ€æ±‚
                ctx.fillStyle = '#888';
                ctx.font = '11px Arial';
                let reqY = iy + 45;
                for (const [mat, count] of Object.entries(evo.req)) {
                    const has = this.materials.getCount(mat);
                    const matInfo = MATERIALS[mat];
                    ctx.fillStyle = has >= count ? '#4f4' : '#f44';
                    ctx.fillText(`${matInfo.icon} ${has}/${count}`, ix, reqY);
                    reqY += 16;
                }
                
                ctx.fillStyle = '#666';
                ctx.font = '12px Arial';
                ctx.fillText(`[${i + 1}]`, ix, iy + 95);
            });
        }
        
        ctx.fillStyle = '#888';
        ctx.font = '14px Arial';
        ctx.fillText('æŒ‰ 1-3 é€‰æ‹©è¿›åŒ– | æŒ‰ V å…³é—­', 450, boxY + boxHeight - 20);
    }
    
    drawWeaponSelectUI() {
        const ctx = this.ctx;
        const boxWidth = 600;
        const boxHeight = 400;
        const boxX = (ctx.canvas.width || 900) / 2 - boxWidth / 2;
        const boxY = (ctx.canvas.height || 600) / 2 - boxHeight / 2;
        const centerX = (ctx.canvas.width || 900) / 2;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = '#48f';
        ctx.lineWidth = 3;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        ctx.fillStyle = '#48f';
        ctx.font = 'bold 28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('âš”ï¸ é€‰æ‹©æ­¦å™¨ âš”ï¸', centerX, boxY + 50);
        
        const itemWidth = 160;
        const itemHeight = 200;
        const startX = centerX - (this.weaponOptions.length * itemWidth) / 2 + itemWidth / 2;
        
        this.weaponOptions.forEach((option, i) => {
            const ix = startX + i * (itemWidth + 20);
            const iy = boxY + 180;
            
            // èƒŒæ™¯æ¡†
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(ix - itemWidth/2, iy - itemHeight/2, itemWidth, itemHeight);
            ctx.strokeStyle = '#48f';
            ctx.lineWidth = 2;
            ctx.strokeRect(ix - itemWidth/2, iy - itemHeight/2, itemWidth, itemHeight);
            
            // æ­¦å™¨å›¾æ ‡
            ctx.font = '64px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(option.cfg.icon, ix, iy - 40);
            
            // æ­¦å™¨åç§°
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(option.cfg.name, ix, iy);
            
            // æ–°æ­¦å™¨/å‡çº§æ ‡è¯†
            if (option.isNew) {
                ctx.fillStyle = '#4f4';
                ctx.font = '14px Arial';
                ctx.fillText('[æ–°æ­¦å™¨]', ix, iy + 25);
            } else {
                ctx.fillStyle = '#f0f';
                ctx.font = '14px Arial';
                ctx.fillText(`[å‡çº§ Lv.${option.level}]`, ix, iy + 25);
            }
            
            // å±æ€§
            ctx.fillStyle = '#aaa';
            ctx.font = '12px Arial';
            ctx.fillText(`ä¼¤å®³: ${option.cfg.dmg}`, ix, iy + 50);
            ctx.fillText(`å†·å´: ${option.cfg.cd}s`, ix, iy + 70);
            
            // æŒ‰é”®æç¤º
            ctx.fillStyle = '#666';
            ctx.font = '14px Arial';
            ctx.fillText(`[${i + 1}]`, ix, iy + 100);
        });
        
        ctx.fillStyle = '#888';
        ctx.font = '14px Arial';
        ctx.fillText('æŒ‰ 1-3 é€‰æ‹©æ­¦å™¨', centerX, boxY + boxHeight - 30);
    }

    drawUI() {
        // æ¸¸æˆç»“æŸ/èƒœåˆ©ç”»é¢
        const ctx = this.ctx;
        
        if (this.state === 'gameover') {
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, 900, 600);
            ctx.fillStyle = '#f44';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('æ¸¸æˆç»“æŸ', 450, 280);
            ctx.font = '24px Arial';
            ctx.fillStyle = '#fff';
            ctx.fillText(`åˆ°è¾¾å±‚æ•°: ${this.currentFloor} | é‡‘å¸: ${this.player.gold}`, 450, 340);
            if (this.scoreManager.isPlaying) {
                this.endGame('dead');
            }
        }
        
        if (this.state === 'victory') {
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, 900, 600);
            ctx.fillStyle = '#4f4';
            ctx.font = 'bold 56px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸ‰ èƒœåˆ©! ğŸ‰', 450, 260);
            if (this.scoreManager.isPlaying) {
                this.endGame('cleared');
            }
        }
    }
    
    // ä»¥æ’’é£æ ¼å°åœ°å›¾ï¼ˆåœ¨å³ä¾§è¾¹æ æ˜¾ç¤ºï¼‰
    // å·²è®¿é—®æˆ¿é—´=å®å¿ƒï¼Œæœªè®¿é—®æˆ¿é—´=è½®å»“
    updateMiniMap() {
        const canvas = document.getElementById('miniMapCanvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const size = 220;
        
        ctx.clearRect(0, 0, size, size);
        
        const rooms = Array.from(this.allRooms?.values() || []);
        if (!rooms || rooms.length === 0) return;
        
        // è®¡ç®—åœ°å›¾èŒƒå›´
        let minX = 0, maxX = 0, minY = 0, maxY = 0;
        for (const r of rooms) {
            minX = Math.min(minX, r.gridX);
            maxX = Math.max(maxX, r.gridX);
            minY = Math.min(minY, r.gridY);
            maxY = Math.max(maxY, r.gridY);
        }
        
        const width = maxX - minX + 1;
        const height = maxY - minY + 1;
        const padding = 20;
        const cellSize = Math.min((size - padding * 2) / width, (size - padding * 2) / height);
        const mapPixelW = width * cellSize;
        const mapPixelH = height * cellSize;
        const offsetX = (size - mapPixelW) / 2;
        const offsetY = (size - mapPixelH) / 2;
        
        // ç»˜åˆ¶æˆ¿é—´
        for (const r of rooms) {
            const rx = offsetX + (r.gridX - minX) * cellSize + 2;
            const ry = offsetY + (r.gridY - minY) * cellSize + 2;
            const rw = cellSize - 4;
            
            // æœªè®¿é—®çš„æˆ¿é—´åªç»˜åˆ¶è½®å»“ï¼ˆä»¥æ’’é£æ ¼ï¼‰
            if (r.visited) {
                switch(r.type) {
                    case 'start': ctx.fillStyle = '#4f4'; break;
                    case 'boss': ctx.fillStyle = '#f44'; break;
                    case 'treasure': ctx.fillStyle = '#fa0'; break;
                    case 'shop': ctx.fillStyle = '#48f'; break;
                    default: ctx.fillStyle = '#ccc';
                }
                ctx.fillRect(rx, ry, rw, rw);
            } else {
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1.5;
                ctx.strokeRect(rx, ry, rw, rw);
            }
            
            // å½“å‰æˆ¿é—´é«˜äº®
            if (r === this.curRoom) {
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 3;
                ctx.strokeRect(rx - 2, ry - 2, rw + 4, rw + 4);
            }
        }
    }
    
    spawnRoomReward() {
        const roll = Math.random();
        if (this.curRoom.type === 'boss') {
            this.spawnWeaponPickup();
        } else if (this.curRoom.type === 'treasure') {
            this.spawnItemPickup();
        } else if (roll < 0.3) {
            this.spawnItemPickup();
        } else if (roll < 0.5) {
            this.spawnWeaponPickup();
        }
    }
    
    spawnItemPickup() {
        const itemId = randInt(1, 16);
        const item = ITEMS[itemId];
        if (!item) return;
        this.curRoom.items.push({ x: this.curRoom.centerX, y: this.curRoom.centerY, id: itemId, icon: item.icon, name: item.name });
    }
    
    spawnWeaponPickup() {
        const wKeys = Object.keys(WEAPONS);
        const randKey = wKeys[Math.floor(Math.random() * wKeys.length)];
        this.curRoom.items.push({
            x: this.curRoom.centerX, y: this.curRoom.centerY,
            type: 'weapon', weaponKey: randKey,
            icon: WEAPONS[randKey].icon, name: WEAPONS[randKey].name
        });
    }
    
    spawnTotemPickup() {
        const totemId = randInt(1, 8);
        const totem = TOTEMS[totemId];
        if (!totem) return;
        this.curRoom.items.push({
            x: this.curRoom.centerX, y: this.curRoom.centerY,
            type: 'totem', totemId: totemId,
            icon: totem.icon, name: totem.name
        });
    }

    // å­˜æ¡£ç³»ç»Ÿï¼ˆç¬¬5æ¬¡è¿­ä»£ï¼‰
    saveGame() {
        try {
            const saveData = {
                player: {
                    hp: this.player.hp,
                    maxHp: this.player.maxHp,
                    exp: this.player.exp,
                    lv: this.player.lv,
                    gold: this.player.gold
                },
                items: this.items.owned,
                weapons: this.weapons.map(w => ({ key: w.baseKey, level: w.level, evolution: w.evolution })),
                currentFloor: this.currentFloor,
                timestamp: Date.now()
            };
            localStorage.setItem('rougecow_save', JSON.stringify(saveData));
            console.log('ğŸ’¾ æ¸¸æˆå·²å­˜æ¡£');
            return true;
        } catch (e) {
            console.error('å­˜æ¡£å¤±è´¥:', e);
            return false;
        }
    }
    
    loadGame() {
        try {
            const saveData = localStorage.getItem('rougecow_save');
            if (!saveData) return false;
            
            const data = JSON.parse(saveData);
            
            // æ¢å¤ç©å®¶æ•°æ®
            Object.assign(this.player, data.player);
            
            // æ¢å¤é“å…·
            this.items.owned = data.items || {};
            this.items.dirty = true;
            
            // æ¢å¤æ­¦å™¨
            if (data.weapons && data.weapons.length > 0) {
                this.weapons = data.weapons.map(w => new Weapon(w.key, w.level, w.evolution));
            }
            
            // æ¢å¤å±‚æ•°
            this.currentFloor = data.currentFloor || 1;
            
            console.log('ğŸ“‚ æ¸¸æˆå·²åŠ è½½');
            return true;
        } catch (e) {
            console.error('è¯»æ¡£å¤±è´¥:', e);
            return false;
        }
    }
    
    hasSave() {
        return !!localStorage.getItem('rougecow_save');
    }
    
    deleteSave() {
        localStorage.removeItem('rougecow_save');
        console.log('ğŸ—‘ï¸ å­˜æ¡£å·²åˆ é™¤');
    }

    loop(t) {
        const dt = Math.min((t - (this.lastT || t)) / 1000, 0.1) * this.timeScale;
        this.lastT = t;
        
        if (this.state === 'playing' || this.transition.active) {
            this.update(dt);
        }
        this.draw();
        
        // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
        if (this.state === 'playing' && this.scoreManager.isPlaying) {
            this.updateScoreDisplay();
        }
        
        this.rafId = requestAnimationFrame(t => this.loop(t));
    }
}

// å¯åŠ¨
window.onload = () => {
    const game = new Game();
    setTimeout(() => game.start(), 500);
};
</script>
</body>
</html>
