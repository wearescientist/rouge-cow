<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è‚‰é¸½ç‰›ç‰› - v0.9.5 è´´å›¾ç‰ˆæœ¬å·ä¿®å¤</title>
    <style>
        /* ========== ä¸»é¢˜ç³»ç»Ÿ CSS Variables ========== */
        :root {
            /* æš—è‰²ä¸»é¢˜ï¼ˆé»˜è®¤ï¼‰ */
            --bg-primary: #0a0a14;
            --bg-secondary: #0d0d1a;
            --bg-sidebar: rgba(10,10,20,0.95);
            --bg-card: rgba(255,255,255,0.03);
            --border-color: #222;
            --border-light: #333;
            --text-primary: #fff;
            --text-secondary: #888;
            --text-accent: #4f4;
            --accent-blue: #48f;
            --accent-gold: #fa0;
            --accent-danger: #f44;
            --shadow-glow: rgba(68,136,255,0.5);
            --font-main: Arial, sans-serif;
        }
        
        [data-theme="light"] {
            --bg-primary: #f0f0f5;
            --bg-secondary: #fff;
            --bg-sidebar: rgba(240,240,245,0.98);
            --bg-card: rgba(0,0,0,0.05);
            --border-color: #ccc;
            --border-light: #ddd;
            --text-primary: #222;
            --text-secondary: #666;
            --text-accent: #2a2;
            --accent-blue: #26c;
            --accent-gold: #c80;
            --accent-danger: #c22;
            --shadow-glow: rgba(38,102,204,0.4);
        }
        
        /* ========== å“åº”å¼æ–­ç‚¹å˜é‡ ========== */
        :root {
            --sidebar-width: 260px;
            --sidebar-width-sm: 200px;
            --topbar-height: 50px;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        html, body { 
            width: 100%; 
            height: 100%; 
            background: var(--bg-primary); 
            color: var(--text-primary);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: var(--font-main);
            transition: background 0.3s, color 0.3s;
        }
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameCanvas { 
            display: block; 
            background: var(--bg-secondary);
            max-width: 100%;
            max-height: 100%;
        }
        #loading { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: var(--bg-primary); display: flex; flex-direction: column; 
            justify-content: center; align-items: center; z-index: 1000;
            transition: opacity 0.5s;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        .cow { font-size: 100px; animation: bounce 0.6s infinite alternate; }
        @keyframes bounce { from { transform: translateY(0) scale(1); } to { transform: translateY(-30px) scale(1.1); } }
        .loading-text { color: #4488ff; margin-top: 30px; font-size: 24px; font-family: Arial; }
        .loading-bar { width: 300px; height: 10px; background: #333; border-radius: 5px; margin-top: 20px; overflow: hidden; }
        .loading-progress { width: 0%; height: 100%; background: #4488ff; transition: width 0.3s; }
        /* å·¦è¾¹æ æ“ä½œæç¤ºæ ·å¼ */
        .controls-hint-section .controls-hint {
            font-size: 13px;
            line-height: 1.8;
        }
        .controls-hint-section .controls-hint div {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        .key { 
            background: var(--text-secondary); 
            color: var(--bg-primary); 
            padding: 2px 6px; 
            border-radius: 4px; 
            font-size: 12px;
            min-width: 36px;
            text-align: center;
            display: inline-block;
            font-weight: bold;
        }
        
        /* é€Ÿåº¦æ§åˆ¶æŒ‰é’® */
        #speedControl {
            position: fixed;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 200;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 20px;
            border: 1px solid #444;
        }
        .speed-btn {
            padding: 5px 12px;
            font-size: 12px;
            background: #333;
            color: #888;
            border: 1px solid #555;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: Arial, sans-serif;
        }
        .speed-btn:hover {
            background: #444;
            color: #fff;
        }
        .speed-btn.active {
            background: #4488ff;
            color: #fff;
            border-color: #4488ff;
            box-shadow: 0 0 10px rgba(68,136,255,0.5);
        }
        /* å³ä¸‹è§’å¼€å‘æ§åˆ¶é¢æ¿ */
        #devControlPanel {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: var(--bg-sidebar);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 15px;
            z-index: 200;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 160px;
        }
        .dev-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .dev-label {
            color: var(--text-secondary);
            font-size: 11px;
            font-family: var(--font-main);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .speed-btn-group {
            display: flex;
            gap: 4px;
        }
        .dev-btn {
            padding: 6px 12px;
            font-size: 12px;
            background: var(--bg-card);
            color: var(--text-secondary);
            border: 1px solid var(--border-light);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: var(--font-main);
            text-align: center;
        }
        .dev-btn:hover {
            background: var(--border-light);
            color: var(--text-primary);
        }
        .dev-btn.active {
            background: var(--text-accent);
            color: var(--bg-primary);
            border-color: var(--text-accent);
            box-shadow: 0 0 8px rgba(68, 170, 68, 0.4);
        }
        #godModeStatus {
            font-weight: bold;
        }
        
        /* ä¸»æ¸¸æˆå¸ƒå±€ - ä¸‰æ é“ºæ»¡å±å¹• */
        #mainLayout {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
            background: var(--bg-primary);
        }
        
        #mainLayout.active {
            display: flex;
            flex-direction: row;
        }
        
        #leftSidebar {
            width: var(--sidebar-width);
            height: 100%;
            background: var(--bg-sidebar);
            border-right: 1px solid var(--border-color);
            padding: 15px 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-shrink: 0;
            transition: width 0.3s, background 0.3s;
        }
        
        #centerGame {
            flex: 1;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: var(--bg-secondary);
            position: relative;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            background: #0d0d1a;
            /* å¡«æ»¡å®¹å™¨ */
            width: 100%;
            height: 100%;
        }
        
        #rightSidebar {
            width: var(--sidebar-width);
            height: 100%;
            background: var(--bg-sidebar);
            border-left: 1px solid var(--border-color);
            padding: 15px 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-shrink: 0;
            transition: width 0.3s, background 0.3s;
        }
        
        /* ä¾§è¾¹æ åŒºå— */
        .sidebar-section {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid var(--border-color);
            transition: background 0.3s, border-color 0.3s;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border-light);
            color: var(--text-accent);
        }
        
        #rightSidebar .section-title {
            color: var(--accent-blue);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 6px 0;
            font-size: 13px;
        }
        
        .stat-label { 
            color: var(--text-secondary); 
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .stat-value { 
            color: #fff; 
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        
        .stat-value.hp { color: #f44; }
        .stat-value.lv { color: #48f; }
        .stat-value.gold { color: #fc0; }
        
        /* æ­¦å™¨åˆ—è¡¨ */
        .weapon-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .weapon-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            font-size: 12px;
            border: 1px solid transparent;
        }
        
        .weapon-item.active {
            border-color: #4f4;
            background: rgba(100,255,100,0.1);
        }
        
        .weapon-icon { font-size: 16px; }
        .weapon-name { flex: 1; }
        .weapon-lv {
            font-size: 10px;
            color: #888;
        }
        
        /* å°åœ°å›¾ */
        .mini-map-wrapper {
            width: 100%;
            aspect-ratio: 1;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #333;
        }
        
        #miniMapCanvas {
            width: 100%;
            height: 100%;
        }
        
        /* é“å…·æ ¼å­ */
        .item-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
        }
        
        .item-cell {
            aspect-ratio: 1;
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            border: 1px solid #222;
        }
        
        .item-cell.filled {
            background: rgba(100,100,100,0.2);
            border-color: #444;
        }
        
        /* é¡¶éƒ¨ä¸­å¤®åˆ†æ•° */
        #topScoreBar {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 60px;
            background: rgba(0,0,0,0.9);
            border-radius: 10px;
            border: 2px solid #fa0;
            z-index: 300;
            display: flex;
            align-items: center;
            justify-content: center;
            display: none;
        }
        
        #scoreValue {
            color: #ff0;
            font-size: 28px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px rgba(255,255,0,0.5);
        }
        
        #killStreak {
            color: #f44;
            font-size: 12px;
            margin-top: 2px;
        }
        
        /* ç©å®¶ç”Ÿå‘½å€¼ */
        #playerHearts {
            letter-spacing: 2px;
            text-shadow: 0 0 5px rgba(255,0,0,0.5);
        }
        
        /* ========== å“åº”å¼å¸ƒå±€ ========== */
        /* å¹³æ¿è®¾å¤‡ */
        @media (max-width: 1200px) {
            :root {
                --sidebar-width: 200px;
            }
            #leftSidebar, #rightSidebar {
                padding: 10px 8px;
            }
            .section-title {
                font-size: 12px;
            }
            .stat-row {
                font-size: 11px;
            }
        }
        
        /* å°å±è®¾å¤‡ - æ”¶èµ·ä¾§è¾¹æ  */
        @media (max-width: 900px) {
            #mainLayout.active {
                flex-direction: column;
            }
            #leftSidebar, #rightSidebar {
                width: 100%;
                height: auto;
                max-height: 150px;
                flex-direction: row;
                flex-wrap: wrap;
                padding: 8px;
                gap: 8px;
            }
            #leftSidebar {
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                order: 2;
            }
            #rightSidebar {
                border-left: none;
                border-top: 1px solid var(--border-color);
                order: 3;
            }
            #centerGame {
                order: 1;
                flex: 2;
            }
            .sidebar-section {
                flex: 1;
                min-width: 140px;
                padding: 8px;
            }
        }
        
        /* æ‰‹æœºè®¾å¤‡ */
        @media (max-width: 600px) {
            #speedControl {
                top: 5px;
                right: 5px;
                padding: 3px 6px;
            }
            .speed-btn {
                padding: 4px 8px;
                font-size: 10px;
            }
            #devControlPanel {
                bottom: 5px;
                right: 5px;
                padding: 8px 10px;
                min-width: 120px;
            }
            .dev-btn {
                padding: 4px 8px;
                font-size: 10px;
            }
            #leftSidebar, #rightSidebar {
                max-height: 120px;
            }
            .sidebar-section {
                min-width: 100px;
                padding: 6px;
            }
            .section-title {
                font-size: 10px;
                margin-bottom: 6px;
                padding-bottom: 4px;
            }
            .stat-row {
                font-size: 9px;
                margin: 3px 0;
            }
        }
        
        /* åŠ¨ç”»ä¼˜åŒ– */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* æ·±è‰²/æµ…è‰²æ¨¡å¼è¿‡æ¸¡ */
        *, *::before, *::after {
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="cow">ğŸ®</div>
        <div class="loading-text" id="loadingText">æ­£åœ¨åŠ è½½ç²¾çµå›¾èµ„æº...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>
    
    <div id="story" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#0a0a14; z-index:999; color:#fff; font-family:Arial; overflow-y:auto;">
        <div style="max-width:800px; margin:50px auto; padding:20px; line-height:1.8;">
            <h1 style="color:#4f4; text-align:center; margin-bottom:30px;">ğŸŒ¾ æ·±æ ¹ä¹‹ç–«</h1>
            <div id="storyContent" style="font-size:18px; color:#ccc;">
                <p style="margin-bottom:20px;">åœ¨<strong style="color:#fa0;">é’ç©—å¤§è‰åŸ</strong>çš„è…¹åœ°ï¼Œæµä¼ ç€ä¸€ä¸ªå¤è€çš„é¢„è¨€ï¼š</p>
                <p style="margin:20px 0; padding:20px; background:rgba(255,255,255,0.05); border-left:4px solid #fa0; font-style:italic;">"å½“å¤§åœ°å¼€å§‹æ¸´é¥®é²œè¡€ï¼Œæ ¹é¡»å°†åå™¬å¤©ç©ºã€‚å”¯æœ‰çŠ„è§’åˆºç ´é»‘æš—è€…ï¼Œæ–¹èƒ½å”¤é†’æ²‰ç¡çš„å¤ªé˜³ã€‚"</p>
                <p style="margin-bottom:20px;">ç‰›ç‰›å‡ºç”Ÿåœ¨<strong style="color:#48f;">è§’æ—éƒ¨è½</strong>ï¼Œä¸–ä»£å®ˆæŠ¤ç€è‰åŸçš„<strong style="color:#4f4;">çµè„‰èŠ‚ç‚¹</strong>â€”â€”åƒæ ¹åœ£æ‰€ã€‚</p>
                <p style="margin-bottom:20px;">ä½†åœ¨ä»–å¤–å‡ºä¿®è¡Œå½’æ¥æ—¶ï¼Œè‰åŸå·²å˜æˆä¸€ç‰‡æ­»å¯‚ã€‚éƒ¨è½ç©ºæ— ä¸€äººï¼Œåªæœ‰ä¸€ä¸ªé€šå¾€åœ°åº•çš„æ´ç©´ï¼Œæ•£å‘ç€è…çƒ‚çš„ç”œé¦™...</p>
                <p style="margin-bottom:20px;">ä»–å¬è§äº†åœ°åº•æ·±å¤„çš„å¿ƒè·³å£°ï¼Œè¿˜æœ‰æ¯äº²ç†Ÿæ‚‰çš„å“¼å”±ã€‚</p>
                <p style="margin-bottom:20px; color:#f44;">"ç­‰æˆ‘ï¼Œé˜¿å¦ˆã€‚"</p>
            </div>
            <div style="text-align:center; margin-top:40px;">
                <button id="startGameBtn" style="padding:15px 40px; font-size:20px; background:#4f4; color:#000; border:none; border-radius:8px; cursor:pointer;">è¸å…¥æ´ç©´</button>
            </div>
        </div>
    </div>
    
    <!-- æ­¦å™¨é€‰æ‹©ç•Œé¢ -->
    <div id="weaponSelect" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#0a0a14; z-index:1000; color:#fff; font-family:Arial;">
        <div style="max-width:900px; margin:50px auto; padding:20px; text-align:center;">
            <h1 style="color:#4f4; margin-bottom:20px;">âš”ï¸ é€‰æ‹©ä½ çš„æ­¦å™¨</h1>
            <p style="color:#888; margin-bottom:40px;">ç‰›ç‰›åœ¨æ´ç©´å…¥å£å‘ç°äº†å‡ æŠŠå‰äººç•™ä¸‹çš„æ­¦å™¨...</p>
            <div id="weaponOptions" style="display:flex; justify-content:center; gap:30px; flex-wrap:wrap;">
                <!-- æ­¦å™¨é€‰é¡¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
    </div>
    
    <!-- ä¸»æ¸¸æˆå¸ƒå±€ï¼ˆä¸‰æ ï¼‰ -->
    <div id="mainLayout">
        <!-- å·¦ä¾§è¾¹æ  -->
        <div id="leftSidebar">
            <!-- è§’è‰²çŠ¶æ€ -->
            <div class="sidebar-section">
                <div class="section-title">ğŸ® è§’è‰²çŠ¶æ€</div>
                <!-- ç”Ÿå‘½å€¼ï¼ˆå¿ƒå½¢ï¼‰ -->
                <div style="margin-bottom:8px;">
                    <div id="playerHearts" style="font-size:18px; letter-spacing:2px;">â¤ï¸â¤ï¸â¤ï¸</div>
                </div>
                <!-- ç»éªŒæ¡ -->
                <div style="margin-bottom:8px;">
                    <div style="display:flex; justify-content:space-between; font-size:11px; color:#8cf; margin-bottom:2px;">
                        <span>LV.<span id="levelDisplay">1</span></span>
                        <span id="expText">0/100</span>
                    </div>
                    <div style="width:100%; height:8px; background:rgba(0,0,0,0.5); border-radius:4px; overflow:hidden; border:1px solid #333;">
                        <div id="expBar" style="width:0%; height:100%; background:linear-gradient(90deg, #48f, #8cf); transition:width 0.3s;"></div>
                    </div>
                </div>
                <div class="stat-row">
                    <span class="stat-label">â¤ï¸ ç”Ÿå‘½</span>
                    <span class="stat-value hp" id="sidebarHp">6/6</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ğŸ’° é‡‘å¸</span>
                    <span class="stat-value gold" id="sidebarGold">100</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ğŸ“ å±‚æ•°</span>
                    <span class="stat-value" id="sidebarFloor">1/6</span>
                </div>
            </div>
            
            <!-- æˆ˜æ–—å±æ€§ -->
            <div class="sidebar-section">
                <div class="section-title">âš”ï¸ æˆ˜æ–—å±æ€§</div>
                <div class="stat-row">
                    <span class="stat-label">ğŸ—¡ï¸ æ”»å‡»åŠ›</span>
                    <span class="stat-value" id="sidebarDmg">15</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ğŸ’¨ ç§»é€Ÿ</span>
                    <span class="stat-value" id="sidebarSpeed">100%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">âš¡ æ”»é€Ÿ</span>
                    <span class="stat-value" id="sidebarFireRate">100%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ğŸ¯ æš´å‡»</span>
                    <span class="stat-value" id="sidebarCrit">0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ğŸ›¡ï¸ æŠ¤ç”²</span>
                    <span class="stat-value" id="sidebarArmor">0</span>
                </div>
            </div>
            
            <!-- æ­¦å™¨åˆ—è¡¨ -->
            <div class="sidebar-section">
                <div class="section-title">ğŸ”« æ­¦å™¨è£…å¤‡</div>
                <div class="weapon-list" id="sidebarWeapons">
                    <!-- åŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
            
            <!-- ææ–™ -->
            <div class="sidebar-section">
                <div class="section-title">ğŸ’ ææ–™</div>
                <div id="sidebarMaterials">æš‚æ— </div>
            </div>
        </div>
        
        <!-- ä¸­é—´æ¸¸æˆåŒºåŸŸ -->
        <div id="centerGame">
            <canvas id="gameCanvas"></canvas>
        </div>
        
        <!-- å³ä¾§è¾¹æ  -->
        <div id="rightSidebar">
            <!-- ä»¥æ’’é£æ ¼å°åœ°å›¾ -->
            <div class="sidebar-section">
                <div class="section-title">ğŸ—ºï¸ åœ°å›¾</div>
                <div class="mini-map-wrapper">
                    <canvas id="miniMapCanvas" width="220" height="220"></canvas>
                </div>
                <div class="stat-row" style="margin-top:8px;">
                    <span class="stat-label">å½“å‰æˆ¿é—´</span>
                    <span class="stat-value" id="sidebarRoomType">èµ·ç‚¹</span>
                </div>
            </div>
            
            <!-- é“å…·èƒŒåŒ… -->
            <div class="sidebar-section">
                <div class="section-title">ğŸ’ é“å…·</div>
                <div class="item-grid" id="sidebarItems">
                    <!-- åŠ¨æ€ç”Ÿæˆ20æ ¼ -->
                </div>
            </div>
            
            <!-- æœ¬å±€ç»Ÿè®¡ -->
            <div class="sidebar-section">
                <div class="section-title">ğŸ“Š æœ¬å±€ç»Ÿè®¡</div>
                <div class="stat-row">
                    <span class="stat-label">ğŸ’¯ åˆ†æ•°</span>
                    <span class="stat-value gold" id="sidebarScore">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">âš”ï¸ å‡»æ€</span>
                    <span class="stat-value" id="sidebarKills">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ğŸšª æ¢ç´¢</span>
                    <span class="stat-value" id="sidebarRooms">0</span>
                </div>
            </div>
            
            <!-- æ“ä½œæç¤º -->
            <div class="sidebar-section controls-hint-section">
                <div class="section-title">âŒ¨ï¸ æ“ä½œ</div>
                <div class="controls-hint">
                    <div><span class="key">WASD</span> ç§»åŠ¨</div>
                    <div><span class="key">ç©ºæ ¼</span> å†²åˆº</div>
                    <div><span class="key">1-3</span> é€‰æ‹©</div>
                    <div><span class="key">E</span> å•†åº—</div>
                    <div><span class="key">V</span> è¿›åŒ–</div>
                    <div><span class="key">F</span> å…¨å±</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- é¡¶éƒ¨ä¿¡æ¯æ  -->
    <div id="topScoreBar">
        <!-- å±‚æ•°â€”â€”åœ°å½¢åç§° -->
        <div id="floorInfo" style="text-align:center;">
            <div style="font-size:18px; font-weight:bold; color:#fff;">ç¬¬ <span id="currentFloorDisplay">1</span> å±‚</div>
            <div style="font-size:14px; color:#aaa;" id="floorName">èŒä¸åŒº</div>
        </div>
        
        <!-- æ³¢æ¬¡ | æ•Œäºº | è¿æ€ -->
        <div style="position:absolute; right:15px; top:50%; transform:translateY(-50%); text-align:right;">
            <div id="waveInfo" style="font-size:13px; color:#aaa;">æ³¢æ¬¡: <span id="waveNum">0</span> | æ•Œäºº: <span id="enemyNum">0</span></div>
            <div id="killStreak" style="display:none; font-size:13px; color:#f80;">ğŸ”¥ è¿æ€ x<span id="streakCount">0</span></div>
        </div>
    </div>
    
    <!-- å³ä¸‹è§’æ§åˆ¶é¢æ¿ -->
    <div id="devControlPanel">
        <div class="dev-section">
            <div class="dev-label">âš¡ æ¸¸æˆé€Ÿåº¦</div>
            <div class="speed-btn-group">
                <button class="speed-btn" data-speed="1" onclick="window.game.setSpeed(1)">1x</button>
                <button class="speed-btn" data-speed="2" onclick="window.game.setSpeed(2)">2x</button>
                <button class="speed-btn" data-speed="5" onclick="window.game.setSpeed(5)">5x</button>
                <button class="speed-btn" data-speed="10" onclick="window.game.setSpeed(10)">10x</button>
            </div>
        </div>
        <div class="dev-section">
            <div class="dev-label">ğŸ›¡ï¸ æµ‹è¯•æ¨¡å¼</div>
            <button id="godModeBtn" class="dev-btn" onclick="window.game.toggleGodMode()">
                æ— æ•Œæ¨¡å¼: <span id="godModeStatus">OFF</span>
            </button>
        </div>
        <div class="dev-section">
            <div class="dev-label">ğŸ¨ å¤–è§‚</div>
            <button id="themeBtn" class="dev-btn" onclick="window.game.toggleTheme()">
                åˆ‡æ¢ä¸»é¢˜
            </button>
        </div>
        <div class="dev-section">
            <div class="dev-label">ğŸ“Š æ€§èƒ½</div>
            <button id="perfBtn" class="dev-btn" onclick="window.game.perfMonitor.toggle()">
                æ€§èƒ½ç›‘æ§
            </button>
        </div>
    </div>
    

        <div class="stat-row">
            <span class="stat-label">å‡»æ€</span>
            <span class="stat-value" id="panelKills">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">æ¢ç´¢</span>
            <span class="stat-value" id="panelRooms">0</span>
        </div>
    </div>
    
    <!-- å±‚æ•°æŒ‡ç¤ºå™¨ -->
    <div class="floor-indicator" id="floorIndicator" style="display:none;">
        ç¬¬ <span id="currentFloor">1</span> / <span id="maxFloors">6</span> å±‚
    </div>

<script>
// ============================================================================
// è‚‰é¸½ç‰›ç‰› v0.9.5 - è¿œç¨‹è´´å›¾+ç‰ˆæœ¬å·å¼ºåˆ¶åˆ·æ–°
// ============================================================================

const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
const dist = (x1, y1, x2, y2) => Math.sqrt((x2-x1)**2 + (y2-y1)**2);
const rand = (min, max) => Math.random() * (max - min) + min;
const randInt = (min, max) => Math.floor(rand(min, max));
const randChoice = (arr) => arr[Math.floor(Math.random() * arr.length)];

// ç²¾çµå›¾åŠ è½½å™¨
class SpriteLoader {
    constructor() {
        this.sprites = {};
        this.loaded = 0;
        this.total = 0;
        this.errors = [];
    }
    
    load(name, src) {
        this.total++;
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                this.sprites[name] = img;
                this.loaded++;
                console.log(`âœ“ Loaded: ${name}`);
                resolve(img);
            };
            
            img.onerror = () => {
                console.warn(`âœ— Failed to load: ${src}`);
                this.errors.push({ name, src });
                this.loaded++;
                resolve(null);
            };
            
            setTimeout(() => {
                if (!img.complete) {
                    console.warn(`â± Timeout: ${src}`);
                    this.errors.push({ name, src, timeout: true });
                    resolve(null);
                }
            }, 5000);
            
            img.src = src;  // ç‰ˆæœ¬å·ç”±è°ƒç”¨æ–¹æ·»åŠ 
        });
    }
    
    get(name) { return this.sprites[name]; }
    has(name) { return name in this.sprites; }
    isReady() { return this.loaded >= this.total; }
    getProgress() { return this.total > 0 ? this.loaded / this.total : 1; }
    getErrorCount() { return this.errors.length; }
}

// ç²’å­ç³»ç»Ÿ
class ParticleSystem {
    constructor(max = 500) {
        this.pool = Array(max).fill(null).map(() => ({
            x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 1,
            color: '#fff', size: 4, active: false, type: 'rect',
            gravity: 0, rotation: 0, rotSpeed: 0, glow: 0
        }));
        this.active = [];
    }

    emit(x, y, color, opts = {}) {
        const p = this.pool.find(p => !p.active) || this.pool[0];
        p.x = x; p.y = y; p.color = color; p.active = true;
        p.life = opts.life || 1; p.maxLife = p.life;
        p.size = opts.size || 4;
        p.type = opts.type || 'rect';
        p.gravity = opts.gravity || 0;
        p.rotation = opts.rotation || 0;
        p.rotSpeed = opts.rotSpeed || 0;
        p.glow = opts.glow || 0;
        const speed = opts.speed || 100;
        const angle = opts.angle != null ? opts.angle : Math.random() * Math.PI * 2;
        p.vx = Math.cos(angle) * speed;
        p.vy = Math.sin(angle) * speed;
        if (!this.active.includes(p)) this.active.push(p);
    }

    burst(x, y, color, count = 10, opts = {}) {
        for (let i = 0; i < count; i++) {
            this.emit(x, y, color, { 
                speed: opts.speed || rand(50, 200), 
                life: opts.life || rand(0.3, 1.0),
                size: opts.size || rand(2, 6),
                type: opts.type || 'rect',
                gravity: opts.gravity || 0,
                rotSpeed: rand(-5, 5),
                glow: opts.glow || 0
            });
        }
    }

    explosion(x, y, color, count = 30) {
        // æ ¸å¿ƒçˆ†ç‚¸ - åœ†å½¢ç²’å­
        for (let i = 0; i < count; i++) {
            this.emit(x, y, color, {
                speed: rand(80, 250),
                life: rand(0.4, 0.9),
                size: rand(3, 8),
                type: 'circle',
                glow: rand(10, 20)
            });
        }
        // ç«èŠ± - å°çŸ©å½¢
        for (let i = 0; i < count / 2; i++) {
            this.emit(x, y, '#ff0', {
                speed: rand(100, 300),
                life: rand(0.2, 0.5),
                size: rand(1, 3),
                type: 'rect'
            });
        }
    }

    trail(x, y, color, count = 3) {
        for (let i = 0; i < count; i++) {
            this.emit(x + rand(-3, 3), y + rand(-3, 3), color, {
                speed: rand(10, 30),
                life: rand(0.15, 0.35),
                size: rand(2, 4),
                type: 'circle',
                glow: 5
            });
        }
    }

    sparkle(x, y, color, count = 5) {
        for (let i = 0; i < count; i++) {
            this.emit(x, y, color, {
                speed: rand(20, 60),
                life: rand(0.5, 1.2),
                size: rand(2, 5),
                type: 'star',
                rotSpeed: rand(-3, 3)
            });
        }
    }

    update(dt) {
        for (let i = this.active.length - 1; i >= 0; i--) {
            const p = this.active[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy += p.gravity * dt * 60;
            p.rotation += p.rotSpeed * dt;
            p.life -= dt;
            if (p.life <= 0) {
                p.active = false;
                this.active.splice(i, 1);
            }
        }
    }

    draw(ctx) {
        for (const p of this.active) {
            const alpha = p.life / p.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            
            // å‘å…‰æ•ˆæœ
            if (p.glow > 0) {
                ctx.shadowBlur = p.glow;
                ctx.shadowColor = p.color;
            }
            
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation);
            
            if (p.type === 'rect') {
                ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
            } else if (p.type === 'circle') {
                ctx.beginPath();
                ctx.arc(0, 0, p.size/2, 0, Math.PI * 2);
                ctx.fill();
            } else if (p.type === 'star') {
                this.drawStar(ctx, 0, 0, 5, p.size, p.size/2);
            }
            
            ctx.restore();
            ctx.shadowBlur = 0;
        }
        ctx.globalAlpha = 1;
    }
    
    drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        let x = cx;
        let y = cy;
        let step = Math.PI / spikes;
        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius;
            y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y);
            rot += step;
            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y);
            rot += step;
        }
        ctx.lineTo(cx, cy - outerRadius);
        ctx.closePath();
        ctx.fill();
    }
}

// ä¼¤å®³æ•°å­—ç³»ç»Ÿ
class DamageNumberSystem {
    constructor(max = 100) {
        this.pool = Array(max).fill(null).map(() => ({
            x: 0, y: 0, value: 0, life: 0, maxLife: 1,
            color: '#fff', size: 14, active: false,
            vx: 0, vy: 0, critical: false
        }));
        this.active = [];
    }
    
    spawn(x, y, value, opts = {}) {
        const dn = this.pool.find(d => !d.active) || this.pool[0];
        dn.x = x; dn.y = y; dn.value = value; dn.active = true;
        dn.life = opts.life || 0.8; dn.maxLife = dn.life;
        dn.size = opts.size || (opts.critical ? 22 : 14);
        dn.color = opts.color || (opts.critical ? '#ff0' : '#fff');
        dn.critical = opts.critical || false;
        dn.vx = rand(-30, 30);
        dn.vy = opts.critical ? -120 : -80;
        if (!this.active.includes(dn)) this.active.push(dn);
    }
    
    spawnHeal(x, y, value) {
        this.spawn(x, y, '+' + value, { color: '#4f4', life: 1.0, size: 16 });
    }
    
    update(dt) {
        for (let i = this.active.length - 1; i >= 0; i--) {
            const dn = this.active[i];
            dn.x += dn.vx * dt;
            dn.y += dn.vy * dt;
            dn.vy += 200 * dt; // é‡åŠ›
            dn.life -= dt;
            if (dn.life <= 0) {
                dn.active = false;
                this.active.splice(i, 1);
            }
        }
    }
    
    draw(ctx) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        for (const dn of this.active) {
            const alpha = Math.min(1, dn.life / dn.maxLife * 2);
            ctx.globalAlpha = alpha;
            ctx.font = `bold ${dn.size}px Arial`;
            
            // æš´å‡»æ•ˆæœ - å‘å…‰æè¾¹
            if (dn.critical) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#f80';
                ctx.strokeStyle = '#800';
                ctx.lineWidth = 2;
                ctx.strokeText(dn.value, dn.x, dn.y);
            }
            
            ctx.fillStyle = dn.color;
            ctx.fillText(dn.value, dn.x, dn.y);
            ctx.shadowBlur = 0;
        }
        ctx.globalAlpha = 1;
    }
}

// éŸ³æ•ˆç³»ç»Ÿ
class SoundManager {
    constructor() {
        this.ctx = null;
        this.enabled = true;
    }
    
    init() {
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn('Web Audio API not supported');
            this.enabled = false;
        }
    }
    
    play(type) {
        if (!this.enabled || !this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        switch(type) {
            case 'shoot':
                osc.frequency.value = 800;
                gain.gain.value = 0.1;
                osc.start();
                osc.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.stop(this.ctx.currentTime + 0.1);
                break;
            case 'hit':
                osc.frequency.value = 200;
                osc.type = 'square';
                gain.gain.value = 0.15;
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.stop(this.ctx.currentTime + 0.15);
                break;
            case 'kill':
                osc.frequency.value = 600;
                gain.gain.value = 0.2;
                osc.start();
                osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                osc.frequency.setValueAtTime(800, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.stop(this.ctx.currentTime + 0.3);
                break;
            case 'levelup':
                osc.frequency.value = 400;
                gain.gain.value = 0.25;
                osc.start();
                for (let i = 0; i < 5; i++) {
                    osc.frequency.setValueAtTime(400 + i * 100, this.ctx.currentTime + i * 0.05);
                }
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.stop(this.ctx.currentTime + 0.5);
                break;
            case 'evolve':
                osc.frequency.value = 300;
                gain.gain.value = 0.3;
                osc.start();
                for (let i = 0; i < 8; i++) {
                    osc.frequency.setValueAtTime(300 + i * 100, this.ctx.currentTime + i * 0.05);
                }
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.8);
                osc.stop(this.ctx.currentTime + 0.8);
                break;
            case 'buy':
                osc.frequency.value = 500;
                gain.gain.value = 0.2;
                osc.start();
                osc.frequency.setValueAtTime(500, this.ctx.currentTime);
                osc.frequency.setValueAtTime(700, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.stop(this.ctx.currentTime + 0.3);
                break;
            case 'gem':
                osc.frequency.value = 1200;
                gain.gain.value = 0.08;
                osc.type = 'sine';
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.08);
                osc.stop(this.ctx.currentTime + 0.08);
                break;
            case 'hurt':
                osc.frequency.value = 150;
                osc.type = 'sawtooth';
                gain.gain.value = 0.25;
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.stop(this.ctx.currentTime + 0.2);
                break;
            case 'portal':
                osc.frequency.value = 800;
                gain.gain.value = 0.15;
                osc.type = 'sine';
                osc.start();
                for (let i = 0; i < 6; i++) {
                    osc.frequency.setValueAtTime(800 + i * 150, this.ctx.currentTime + i * 0.08);
                }
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.6);
                osc.stop(this.ctx.currentTime + 0.6);
                break;
            case 'boss':
                osc.frequency.value = 200;
                gain.gain.value = 0.4;
                osc.type = 'sawtooth';
                osc.start();
                for (let i = 0; i < 10; i++) {
                    osc.frequency.setValueAtTime(200 - i * 15, this.ctx.currentTime + i * 0.1);
                }
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 1.2);
                osc.stop(this.ctx.currentTime + 1.2);
                break;
            case 'victory':
                osc.frequency.value = 440;
                gain.gain.value = 0.25;
                osc.type = 'sine';
                osc.start();
                [440, 554, 659, 880, 1109, 1319].forEach((freq, i) => {
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime + i * 0.12);
                });
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 1.2);
                osc.stop(this.ctx.currentTime + 1.2);
                break;
            case 'gameover':
                osc.frequency.value = 880;
                gain.gain.value = 0.2;
                osc.type = 'triangle';
                osc.start();
                [880, 830, 783, 740, 698, 659, 622, 587, 554, 523, 494, 466].forEach((freq, i) => {
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime + i * 0.08);
                });
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 1.2);
                osc.stop(this.ctx.currentTime + 1.2);
                break;
            case 'wave':
                osc.frequency.value = 300;
                gain.gain.value = 0.15;
                osc.type = 'square';
                osc.start();
                for (let i = 0; i < 5; i++) {
                    osc.frequency.setValueAtTime(300 + i * 50, this.ctx.currentTime + i * 0.05);
                }
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
                osc.stop(this.ctx.currentTime + 0.4);
                break;
            case 'elite':
                osc.frequency.value = 150;
                gain.gain.value = 0.3;
                osc.type = 'sawtooth';
                osc.start();
                for (let i = 0; i < 8; i++) {
                    osc.frequency.setValueAtTime(150 + Math.random() * 200, this.ctx.currentTime + i * 0.06);
                }
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.6);
                osc.stop(this.ctx.currentTime + 0.6);
                break;
            case 'chest':
                osc.frequency.value = 600;
                gain.gain.value = 0.2;
                osc.type = 'triangle';
                osc.start();
                [600, 800, 600, 800, 1000].forEach((freq, i) => {
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime + i * 0.06);
                });
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.stop(this.ctx.currentTime + 0.5);
                break;
        }
    }
}

// ææ–™ç³»ç»Ÿ
const MATERIALS = {
    fire: { name: 'ç«ç„°ç²¾å', icon: 'ğŸ”¥', color: '#f44' },
    ice: { name: 'å†°éœœç»“æ™¶', icon: 'â„ï¸', color: '#48f' },
    thunder: { name: 'é›·ç”µæ ¸å¿ƒ', icon: 'âš¡', color: '#fc0' },
    shadow: { name: 'æš—å½±ç¢ç‰‡', icon: 'ğŸŒ‘', color: '#848' },
    life: { name: 'ç”Ÿå‘½ç²¾å', icon: 'ğŸŒ¿', color: '#4f4' },
    steel: { name: 'é’¢é“ç¢ç‰‡', icon: 'ğŸ”©', color: '#888' },
    magic: { name: 'é­”æ³•ç²‰å°˜', icon: 'âœ¨', color: '#f8f' },
    ancient: { name: 'è¿œå¤é—ç‰©', icon: 'ğŸº', color: '#fa0' }
};

class MaterialManager {
    constructor() {
        this.materials = {};
        for (const key in MATERIALS) {
            this.materials[key] = 0;
        }
    }
    
    add(type, amount = 1) {
        if (this.materials[type] !== undefined) {
            this.materials[type] += amount;
            return true;
        }
        return false;
    }
    
    has(type, amount = 1) {
        return (this.materials[type] || 0) >= amount;
    }
    
    consume(type, amount = 1) {
        if (this.has(type, amount)) {
            this.materials[type] -= amount;
            return true;
        }
        return false;
    }
    
    getCount(type) {
        return this.materials[type] || 0;
    }
    
    getAll() {
        return Object.entries(this.materials)
            .filter(([_, count]) => count > 0)
            .map(([type, count]) => ({ ...MATERIALS[type], type, count }));
    }
}

// é“å…·æ•°æ®åº“
const ITEMS = {
    1: { id: 1, name: 'å¤šé‡å°„å‡»', icon: 'ğŸ¯', rarity: 'common', effect: 'projCount', value: 1, desc: 'å­å¼¹+1', price: 40 },
    2: { id: 2, name: 'å·¨å¤§åŒ–', icon: 'ğŸ“', rarity: 'common', effect: 'projSize', value: 0.3, desc: 'å­å¼¹å˜å¤§', price: 35 },
    3: { id: 3, name: 'å¿«é€Ÿå°„å‡»', icon: 'âš¡', rarity: 'common', effect: 'fireRate', value: 0.15, desc: 'å°„é€Ÿ+15%', price: 45 },
    4: { id: 4, name: 'ç©¿ç”²å¼¹', icon: 'ğŸ”©', rarity: 'rare', effect: 'pierce', value: 1, desc: 'ç©¿é€+1', price: 80 },
    5: { id: 5, name: 'æš´å‡»é•œç‰‡', icon: 'ğŸ”', rarity: 'rare', effect: 'crit', value: 0.1, desc: 'æš´å‡»+10%', price: 75 },
    6: { id: 6, name: 'å¿ƒä¹‹å®¹å™¨', icon: 'â¤ï¸', rarity: 'common', effect: 'maxHp', value: 2, desc: 'ç”Ÿå‘½+2', price: 50 },
    7: { id: 7, name: 'é’¢é“æŠ¤ç”²', icon: 'ğŸ›¡ï¸', rarity: 'rare', effect: 'armor', value: 1, desc: 'æŠ¤ç”²+1', price: 85 },
    8: { id: 8, name: 'å¸è¡€ç ç‰™', icon: 'ğŸ¦·', rarity: 'rare', effect: 'lifeSteal', value: 0.05, desc: 'å¸è¡€5%', price: 90 },
    9: { id: 9, name: 'åŠ é€Ÿé´', icon: 'ğŸ‘Ÿ', rarity: 'common', effect: 'speed', value: 0.2, desc: 'ç§»é€Ÿ+20%', price: 40 },
    10: { id: 10, name: 'é£è¡Œç¿…è†€', icon: 'ğŸ¦…', rarity: 'epic', effect: 'fly', value: 1, desc: 'å¯ä»¥é£è¡Œ', price: 150 },
    11: { id: 11, name: 'ç£é“', icon: 'ğŸ§²', rarity: 'rare', effect: 'magnet', value: 50, desc: 'å¸èŒƒå›´+50', price: 70 },
    12: { id: 12, name: 'é‡‘è›‹', icon: 'ğŸ¥š', rarity: 'epic', effect: 'goldBonus', value: 0.5, desc: 'é‡‘å¸+50%', price: 120 },
    13: { id: 13, name: 'ç«ç„°é™„é­”', icon: 'ğŸ”¥', rarity: 'rare', effect: 'fireDmg', value: 5, desc: 'ç«ç„°ä¼¤å®³+5', price: 85 },
    14: { id: 14, name: 'å†°å†»æ ¸å¿ƒ', icon: 'â„ï¸', rarity: 'rare', effect: 'slow', value: 0.2, desc: 'å‡é€Ÿæ•Œäºº20%', price: 80 },
    15: { id: 15, name: 'é›·ç”µå®ç ', icon: 'âš¡', rarity: 'epic', effect: 'chain', value: 1, desc: 'è¿é”æ”»å‡»+1', price: 140 },
    // v0.8.0 æœ€ç»ˆæ•´åˆ
    16: { id: 16, name: 'ç‹‚æš´ä¹‹è¡€', icon: 'ğŸ©¸', rarity: 'rare', effect: 'crit', value: 0.1, desc: 'æš´å‡»ç‡+10%', price: 80 },
    17: { id: 17, name: 'çˆ†ç‚¸å¼¹', icon: 'ğŸ’£', rarity: 'rare', effect: 'fireDmg', value: 5, desc: 'çˆ†ç‚¸ä¼¤å®³+5', price: 90 },
    18: { id: 18, name: 'å†°å†»å¼¹', icon: 'ğŸ§Š', rarity: 'rare', effect: 'slow', value: 0.2, desc: 'å‡é€Ÿæ•ˆæœ+20%', price: 85 },
    19: { id: 19, name: 'æŠ¤ç›¾å‘ç”Ÿå™¨', icon: 'ğŸ›¡ï¸', rarity: 'rare', effect: 'armor', value: 2, desc: 'æŠ¤ç”²+2', price: 100 },
    20: { id: 20, name: 'å¤æ´»å¸', icon: 'ğŸª™', rarity: 'legendary', effect: 'maxHp', value: 2, desc: 'ç”Ÿå‘½ä¸Šé™+2', price: 300 },
    21: { id: 21, name: 'ç»éªŒä¹¦', icon: 'ğŸ“š', rarity: 'common', effect: 'speed', value: 0.1, desc: 'ç§»é€Ÿ+10%', price: 40 },
    22: { id: 22, name: 'é‡‘ç£é“', icon: 'ğŸ§²', rarity: 'rare', effect: 'magnet', value: 80, desc: 'æ‹¾å–èŒƒå›´+80', price: 75 },
    23: { id: 23, name: 'ç–¾é£é´', icon: 'ğŸ‘¢', rarity: 'epic', effect: 'speed', value: 0.3, desc: 'ç§»é€Ÿ+30%', price: 140 },
    24: { id: 24, name: 'å¤©ä½¿ç¥ç¦', icon: 'ğŸ‘¼', rarity: 'legendary', effect: 'maxHp', value: 3, desc: 'ç”Ÿå‘½+3', price: 350 },
    25: { id: 25, name: 'é»‘æ´æ ¸å¿ƒ', icon: 'ğŸ•³ï¸', rarity: 'legendary', effect: 'magnet', value: 200, desc: 'æ‹¾å–èŒƒå›´+200', price: 400 },
    26: { id: 26, name: 'é›·ç”µä¹‹åˆƒ', icon: 'âš¡', rarity: 'epic', effect: 'chain', value: 1, desc: 'è¿é”æ”»å‡»+1', price: 140 },
    // ç¬¬1æ¬¡è¿­ä»£ï¼šæ–°å¢24ä¸ªé“å…· (27-50)
    // æ”»å‡»ç±»æ‰©å±•
    27: { id: 27, name: 'éœ°å¼¹æ‰©æ•£', icon: 'ğŸ“¦', rarity: 'common', effect: 'spread', value: 15, desc: 'æ•£å°„è§’åº¦+15Â°', price: 35 },
    28: { id: 28, name: 'è¿½è¸ªèŠ¯ç‰‡', icon: 'ğŸ§¿', rarity: 'rare', effect: 'homing', value: 0.3, desc: 'è¿½è¸ªå¼ºåº¦+30%', price: 95 },
    29: { id: 29, name: 'å¼¹è·³å­å¼¹', icon: 'ğŸ±', rarity: 'rare', effect: 'bounce', value: 1, desc: 'å¼¹è·³+1æ¬¡', price: 85 },
    30: { id: 30, name: 'æ¯’æ¶²æ¶‚å±‚çš„', icon: 'ğŸ§ª', rarity: 'rare', effect: 'poisonDmg', value: 3, desc: 'æ¯’ä¼¤å®³+3/ç§’', price: 80 },
    31: { id: 31, name: 'ç‹™å‡»é•œ', icon: 'ğŸ”­', rarity: 'epic', effect: 'critDmg', value: 0.5, desc: 'æš´å‡»ä¼¤å®³+50%', price: 130 },
    32: { id: 32, name: 'è¿å‘è£…ç½®', icon: 'ğŸ”«', rarity: 'epic', effect: 'burst', value: 1, desc: 'è¿å°„+1å‘', price: 150 },
    // é˜²å¾¡ç±»æ‰©å±•
    33: { id: 33, name: 'å†ç”Ÿå› å­', icon: 'ğŸ§¬', rarity: 'rare', effect: 'regen', value: 0.5, desc: 'æ¯ç§’å›å¤0.5HP', price: 100 },
    34: { id: 34, name: 'è†æ£˜æŠ¤ç”²', icon: 'ğŸŒµ', rarity: 'rare', effect: 'thorn', value: 2, desc: 'åå¼¹2ç‚¹ä¼¤å®³', price: 90 },
    35: { id: 35, name: 'é—ªé¿é´', icon: 'ğŸ‘»', rarity: 'epic', effect: 'dodge', value: 0.1, desc: 'é—ªé¿+10%', price: 130 },
    36: { id: 36, name: 'ç¥åœ£æŠ¤ç›¾', icon: 'âœ¨', rarity: 'legendary', effect: 'shield', value: 1, desc: 'å…ä¼¤ç›¾+1å±‚', price: 300 },
    37: { id: 37, name: 'ä¸æœ½ä¹‹å¿ƒ', icon: 'ğŸ’', rarity: 'legendary', effect: 'revive', value: 1, desc: 'æ­»äº¡æ—¶å¤æ´»ä¸€æ¬¡', price: 500 },
    // ç§»åŠ¨ç±»æ‰©å±•
    38: { id: 38, name: 'ç¬ç§»è£…ç½®', icon: 'ğŸŒ€', rarity: 'epic', effect: 'dashDist', value: 0.5, desc: 'å†²åˆºè·ç¦»+50%', price: 120 },
    39: { id: 39, name: 'æ—¶é—´æ€€è¡¨', icon: 'â±ï¸', rarity: 'legendary', effect: 'slowTime', value: 0.2, desc: 'å­å¼¹æ—¶é—´20%', price: 400 },
    // èµ„æºç±»æ‰©å±•
    40: { id: 40, name: 'å¹¸è¿å¸', icon: 'ğŸ€', rarity: 'rare', effect: 'luck', value: 0.2, desc: 'å¹¸è¿+20%', price: 110 },
    41: { id: 41, name: 'è´ªå©ªä¹‹æ‰‹', icon: 'ğŸ¤²', rarity: 'rare', effect: 'goldOnKill', value: 2, desc: 'å‡»æ€é‡‘å¸+2', price: 95 },
    42: { id: 42, name: 'ç»éªŒåŠ æˆ', icon: 'ğŸ“ˆ', rarity: 'common', effect: 'expBonus', value: 0.2, desc: 'ç»éªŒ+20%', price: 45 },
    43: { id: 43, name: 'é‡‡é›†å™¨', icon: 'ğŸ“¡', rarity: 'epic', effect: 'pickupRange', value: 50, desc: 'æ‹¾å–èŒƒå›´+50', price: 125 },
    // å¬å”¤ç±»
    44: { id: 44, name: 'å°ç²¾çµ', icon: 'ğŸ§š', rarity: 'rare', effect: 'fairy', value: 1, desc: 'å°ç²¾çµè·Ÿéšå°„å‡»', price: 140 },
    45: { id: 45, name: 'å®ˆæŠ¤çƒ', icon: 'ğŸ”®', rarity: 'epic', effect: 'orbit', value: 1, desc: 'ç¯ç»•æ”»å‡»çƒ+1', price: 160 },
    46: { id: 46, name: 'å® ç‰©é¾™', icon: 'ğŸ‰', rarity: 'legendary', effect: 'dragon', value: 1, desc: 'å–·ç«å¹¼é¾™è·Ÿéš', price: 450 },
    // è¯…å’’ç±»ï¼ˆé«˜é£é™©é«˜å›æŠ¥ï¼‰
    47: { id: 47, name: 'ç‹‚æš´æ¨¡å¼', icon: 'ğŸ˜ˆ', rarity: 'cursed', effect: 'glassCannon', value: 1, desc: 'ä¼¤å®³+50% ç”Ÿå‘½-30%', price: 0 },
    48: { id: 48, name: 'çŒ®ç¥­ä¹‹å¿ƒ', icon: 'ğŸ’”', rarity: 'cursed', effect: 'bloodMoney', value: 1, desc: 'é‡‘å¸+100% æ¯ç§’æ‰£è¡€', price: 0 },
    // ç‰¹æ®Šé“å…·
    49: { id: 49, name: 'ç›²çœ¼èƒå–æ¶²', icon: 'ğŸ§´', rarity: 'legendary', effect: 'invincible', value: 3, desc: '3ç§’æ— æ•Œæ—¶é—´', price: 350 },
    50: { id: 50, name: 'å›¾è…¾éª¨ç‰‡', icon: 'ğŸ¦´', rarity: 'legendary', effect: 'upgradeAll', value: 1, desc: 'å…¨å±æ€§+10%', price: 600 }
};

function getItemPrice(itemId) {
    const item = ITEMS[itemId];
    if (!item) return 100;
    const basePrice = item.price || 50;
    const variance = basePrice * 0.2;
    return Math.floor(basePrice + rand(-variance, variance));
}

class ItemManager {
    constructor(player) {
        this.player = player;
        this.owned = {};
        this.cache = null;
        this.dirty = true;
    }

    add(id) {
        const item = ITEMS[id];
        if (!item) return false;
        this.owned[id] = (this.owned[id] || 0) + 1;
        this.dirty = true;
        
        if (item.effect === 'maxHp') {
            this.player.maxHp += item.value;
            this.player.hp += item.value;
        }
        return true;
    }

    getStats() {
        if (!this.dirty) return this.cache;
        
        const s = {
            // åŸºç¡€å±æ€§
            projCount: 1, projSize: 1, fireRate: 1, pierce: 0,
            crit: 0, critDmg: 1.5, maxHp: 0, armor: 0, lifeSteal: 0,
            speed: 1, fly: false, magnet: 100, goldBonus: 1,
            // ä¼¤å®³ç±»å‹
            fireDmg: 0, thunderDmg: 0, poisonDmg: 0, curseDmg: 0,
            // æ§åˆ¶æ•ˆæœ
            slowChance: 0, slowAmount: 0, stunChance: 0,
            // æ–°å±æ€§ï¼ˆç¬¬1æ¬¡è¿­ä»£ï¼‰
            spread: 0, homing: 0, bounce: 0, burst: 0,
            regen: 0, thorn: 0, dodge: 0, shield: 0, revive: 0,
            dashDist: 1, slowTime: 0, luck: 0, goldOnKill: 0, expBonus: 0,
            pickupRange: 0, fairy: 0, orbit: 0, dragon: 0,
            glassCannon: 0, bloodMoney: 0, invincible: 0, upgradeAll: 0,
            // æ²»ç–—
            healOnHit: 0
        };
        
        for (const [id, count] of Object.entries(this.owned)) {
            const item = ITEMS[id];
            if (!item) continue;
            const v = item.value * count;
            
            switch (item.effect) {
                // åŸºç¡€æ”»å‡»
                case 'projCount': s.projCount += v; break;
                case 'projSize': s.projSize += v; break;
                case 'fireRate': s.fireRate *= (1 + v); break;
                case 'pierce': s.pierce += v; break;
                case 'crit': s.crit = Math.min(1, s.crit + v); break;
                case 'critDmg': s.critDmg += v; break;
                // é˜²å¾¡
                case 'maxHp': s.maxHp += v; break;
                case 'armor': s.armor += v; break;
                case 'lifeSteal': s.lifeSteal += v; break;
                case 'regen': s.regen += v; break;
                case 'thorn': s.thorn += v; break;
                case 'dodge': s.dodge = Math.min(0.5, s.dodge + v); break;
                case 'shield': s.shield += v; break;
                case 'revive': s.revive += v; break;
                // ç§»åŠ¨
                case 'speed': s.speed += v; break;
                case 'fly': s.fly = true; break;
                case 'dashDist': s.dashDist += v; break;
                case 'slowTime': s.slowTime += v; break;
                // èµ„æº
                case 'magnet': s.magnet += v; break;
                case 'goldBonus': s.goldBonus += v; break;
                case 'luck': s.luck += v; break;
                case 'goldOnKill': s.goldOnKill += v; break;
                case 'expBonus': s.expBonus += v; break;
                case 'pickupRange': s.pickupRange += v; break;
                // ä¼¤å®³ç±»å‹
                case 'fireDmg': s.fireDmg += v; break;
                case 'thunderDmg': s.thunderDmg += v; break;
                case 'poisonDmg': s.poisonDmg += v; break;
                case 'curseDmg': s.curseDmg += v; break;
                case 'slow': s.slowAmount += v; break;
                case 'chain': s.chain = (s.chain || 0) + v; break;
                // ç‰¹æ®Šæ•ˆæœ
                case 'spread': s.spread += v; break;
                case 'homing': s.homing += v; break;
                case 'bounce': s.bounce += v; break;
                case 'burst': s.burst += v; break;
                // å¬å”¤
                case 'fairy': s.fairy += v; break;
                case 'orbit': s.orbit += v; break;
                case 'dragon': s.dragon += v; break;
                // è¯…å’’
                case 'glassCannon': s.glassCannon += v; break;
                case 'bloodMoney': s.bloodMoney += v; break;
                // ç‰¹æ®Š
                case 'invincible': s.invincible += v; break;
                case 'upgradeAll': s.upgradeAll += v; break;
            }
        }
        
        // è¯…å’’æ•ˆæœå¤„ç†
        if (s.glassCannon > 0) {
            s.fireRate *= 1.5;
            s.maxHp *= 0.7;
        }
        if (s.bloodMoney > 0) {
            s.goldBonus *= 2;
        }
        if (s.upgradeAll > 0) {
            s.speed *= 1.1;
            s.fireRate *= 1.1;
            s.crit = Math.min(1, s.crit * 1.1 + 0.1);
        }
        
        this.cache = s;
        this.dirty = false;
        return s;
    }

    has(id) { return (this.owned[id] || 0) > 0; }
    count(id) { return this.owned[id] || 0; }
    
    // è·å–æ‹¥æœ‰çš„é“å…·åˆ—è¡¨ï¼ˆç”¨äºUIæ˜¾ç¤ºï¼‰
    getOwnedItems() {
        const items = [];
        for (const [id, count] of Object.entries(this.owned)) {
            const item = ITEMS[id];
            if (item && count > 0) {
                items.push({
                    id: id,
                    name: item.name,
                    icon: item.icon,
                    count: count,
                    desc: item.desc
                });
            }
        }
        return items;
    }
}

// è¢«åŠ¨é“å…·ç®¡ç†å™¨ï¼ˆå¸è¡€é¬¼å¹¸å­˜è€…é£æ ¼ï¼‰
class PassiveManager {
    constructor(player) {
        this.player = player;
        this.passives = {}; // { key: level }
    }
    
    // æ·»åŠ æˆ–å‡çº§è¢«åŠ¨
    add(key) {
        const passive = PASSIVES[key];
        if (!passive) return false;
        
        const currentLevel = this.passives[key] || 0;
        if (currentLevel >= passive.maxLevel) return false; // å·²æ»¡çº§
        
        this.passives[key] = currentLevel + 1;
        
        // ç«‹å³åº”ç”¨è¢«åŠ¨æ•ˆæœ
        this.applyEffect(passive);
        
        return true;
    }
    
    // åº”ç”¨è¢«åŠ¨æ•ˆæœ
    applyEffect(passive) {
        switch(passive.effect) {
            case 'maxHpPct':
                // ç©ºå¿ƒä¹‹å¿ƒï¼šå¢åŠ æœ€å¤§ç”Ÿå‘½å€¼ç™¾åˆ†æ¯”
                const hpBonus = Math.floor(this.player.maxHp * passive.value);
                this.player.maxHp += hpBonus;
                this.player.hp += hpBonus;
                break;
        }
    }
    
    // è·å–è¢«åŠ¨æ•ˆæœç»Ÿè®¡
    getStats() {
        const stats = {
            dmg: 1,           // è èœ
            armor: 0,         // æŠ¤ç”²
            maxHpPct: 0,      // ç©ºå¿ƒä¹‹å¿ƒ
            cooldown: 1,      // ç©ºç™½ä¹‹ä¹¦ï¼ˆå†·å´å€ç‡ï¼Œè¶Šå°è¶Šå¥½ï¼‰
            range: 1,         // çƒ›å°
            projSpeed: 1,     // æŠ¤è…•
            duration: 1,      // é­”æ³•æ‹¼å†™å™¨
            projCount: 0,     // å¤åˆ¶å™¨
            speed: 1,         // ç¿…è†€
            magnet: 0,        // å¸å¼•å™¨
            luck: 0,          // å››å¶è‰
            expBonus: 0       // ç‹å† 
        };
        
        for (const [key, level] of Object.entries(this.passives)) {
            const passive = PASSIVES[key];
            if (!passive || level <= 0) continue;
            
            const totalValue = passive.value * level;
            
            switch(passive.effect) {
                case 'dmg':
                    stats.dmg += totalValue;
                    break;
                case 'armor':
                    stats.armor += totalValue;
                    break;
                case 'maxHpPct':
                    stats.maxHpPct += totalValue;
                    break;
                case 'cooldown':
                    stats.cooldown *= Math.pow(1 - passive.value, level);
                    break;
                case 'range':
                    stats.range += totalValue;
                    break;
                case 'projSpeed':
                    stats.projSpeed += totalValue;
                    break;
                case 'duration':
                    stats.duration += totalValue;
                    break;
                case 'projCount':
                    stats.projCount += totalValue;
                    break;
                case 'speed':
                    stats.speed += totalValue;
                    break;
                case 'magnet':
                    stats.magnet += totalValue;
                    break;
                case 'luck':
                    stats.luck += totalValue;
                    break;
                case 'expBonus':
                    stats.expBonus += totalValue;
                    break;
            }
        }
        
        return stats;
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰æŸä¸ªè¢«åŠ¨
    has(key) {
        return (this.passives[key] || 0) > 0;
    }
    
    // è·å–è¢«åŠ¨ç­‰çº§
    getLevel(key) {
        return this.passives[key] || 0;
    }
    
    // è·å–æ‰€æœ‰è¢«åŠ¨åˆ—è¡¨ï¼ˆç”¨äºUIæ˜¾ç¤ºï¼‰
    getOwnedPassives() {
        const list = [];
        for (const [key, level] of Object.entries(this.passives)) {
            const passive = PASSIVES[key];
            if (passive && level > 0) {
                list.push({
                    key: key,
                    name: passive.name,
                    icon: passive.icon,
                    level: level,
                    maxLevel: passive.maxLevel,
                    desc: passive.desc
                });
            }
        }
        return list;
    }
    
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆæˆè¶…æ­¦
    checkEvolution(weaponKey) {
        const evo = WEAPON_EVOLUTIONS[weaponKey];
        if (!evo) return null;
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å¯¹åº”è¢«åŠ¨
        if (!this.has(evo.requires)) return null;
        
        return evo;
    }
    
    // åºåˆ—åŒ–ï¼ˆç”¨äºå­˜æ¡£ï¼‰
    serialize() {
        return this.passives;
    }
    
    // ååºåˆ—åŒ–ï¼ˆç”¨äºè¯»æ¡£ï¼‰
    deserialize(data) {
        this.passives = data || {};
    }
}

// æ­¦å™¨ç³»ç»Ÿ - æ”¯æŒè¿›åŒ–
const WEAPONS = {
    // åŸºç¡€æ­¦å™¨ï¼ˆå¸è¡€é¬¼å¹¸å­˜è€…é£æ ¼ï¼‰
    whip: { key: 'whip', name: 'é­å­', icon: 'ğŸª„', dmg: 20, cd: 1.0, range: 100, type: 'melee', color: '#f60', maxLevel: 8 },
    wand: { key: 'wand', name: 'é­”æ–', icon: 'ğŸ”®', dmg: 15, cd: 0.6, speed: 300, type: 'proj', color: '#48f', maxLevel: 8 },
    knife: { key: 'knife', name: 'é£åˆ€', icon: 'ğŸ—¡ï¸', dmg: 12, cd: 0.4, speed: 400, pierce: 3, type: 'proj', color: '#ccc', maxLevel: 8 },
    axe: { key: 'axe', name: 'æ–§å¤´', icon: 'ğŸª“', dmg: 25, cd: 1.2, speed: 250, type: 'proj', color: '#8b4513', maxLevel: 8 },
    bible: { key: 'bible', name: 'åœ£ç»', icon: 'ğŸ“–', dmg: 10, cd: 0.8, range: 80, type: 'orbit', color: '#ffd700', maxLevel: 8 },
    fireball: { key: 'fireball', name: 'ç«çƒ', icon: 'ğŸ”¥', dmg: 30, cd: 1.5, speed: 200, type: 'proj', color: '#ff4500', maxLevel: 8 },
    lightning: { key: 'lightning', name: 'é—ªç”µ', icon: 'âš¡', dmg: 18, cd: 0.5, range: 150, type: 'instant', color: '#ffff00', maxLevel: 8 },
    holy_water: { key: 'holy_water', name: 'åœ£æ°´', icon: 'ğŸ’§', dmg: 8, cd: 1.0, range: 60, type: 'area', color: '#00bfff', maxLevel: 8 },
    cross: { key: 'cross', name: 'åå­—æ¶', icon: 'âœï¸', dmg: 22, cd: 1.0, speed: 250, type: 'proj', color: '#ddd', maxLevel: 8 },
    garlic: { key: 'garlic', name: 'å¤§è’œ', icon: 'ğŸ§„', dmg: 5, cd: 0.3, range: 50, type: 'aura', color: '#4a4', maxLevel: 8 },
    // æ–°å¢æ­¦å™¨
    shuriken: { key: 'shuriken', name: 'æ‰‹é‡Œå‰‘', icon: 'ğŸ¯', dmg: 18, cd: 0.7, speed: 350, pierce: 2, type: 'proj', color: '#888', maxLevel: 8 },
    icicle: { key: 'icicle', name: 'å†°é”¥', icon: 'â„ï¸', dmg: 22, cd: 0.9, speed: 280, type: 'proj', color: '#aff', maxLevel: 8 },
    scythe: { key: 'scythe', name: 'é•°åˆ€', icon: 'âš°ï¸', dmg: 35, cd: 1.3, range: 90, type: 'melee', color: '#848', maxLevel: 8 },
    chakram: { key: 'chakram', name: 'ç¯åˆƒ', icon: 'â­•', dmg: 16, cd: 0.6, speed: 320, pierce: 4, type: 'proj', color: '#f80', maxLevel: 8 },
    poison_dart: { key: 'poison_dart', name: 'æ¯’é•–', icon: 'ğŸ“', dmg: 12, cd: 0.5, speed: 380, type: 'proj', color: '#4a4', maxLevel: 8 }
};

// è¢«åŠ¨é“å…·ç³»ç»Ÿï¼ˆå¸è¡€é¬¼å¹¸å­˜è€…é£æ ¼ï¼‰
const PASSIVES = {
    spinach: { key: 'spinach', name: 'è èœ', icon: 'ğŸ¥¬', desc: 'ä¼¤å®³+10%', effect: 'dmg', value: 0.1, maxLevel: 5 },
    armor: { key: 'armor', name: 'æŠ¤ç”²', icon: 'ğŸ›¡ï¸', desc: 'å‡ä¼¤+1', effect: 'armor', value: 1, maxLevel: 5 },
    hollow_heart: { key: 'hollow_heart', name: 'ç©ºå¿ƒä¹‹å¿ƒ', icon: 'ğŸ’', desc: 'æœ€å¤§ç”Ÿå‘½+20%', effect: 'maxHpPct', value: 0.2, maxLevel: 5 },
    empty_tome: { key: 'empty_tome', name: 'ç©ºç™½ä¹‹ä¹¦', icon: 'ğŸ“š', desc: 'å†·å´-8%', effect: 'cooldown', value: 0.08, maxLevel: 5 },
    candelabrador: { key: 'candelabrador', name: 'çƒ›å°', icon: 'ğŸ•¯ï¸', desc: 'æ”»å‡»èŒƒå›´+10%', effect: 'range', value: 0.1, maxLevel: 5 },
    bracer: { key: 'bracer', name: 'æŠ¤è…•', icon: 'ğŸ’ª', desc: 'å¼¹å°„é€Ÿåº¦+10%', effect: 'projSpeed', value: 0.1, maxLevel: 5 },
    spellbinder: { key: 'spellbinder', name: 'é­”æ³•æ‹¼å†™å™¨', icon: 'âœ¨', desc: 'æŒç»­æ—¶é—´+10%', effect: 'duration', value: 0.1, maxLevel: 5 },
    duplicator: { key: 'duplicator', name: 'å¤åˆ¶å™¨', icon: 'ğŸ”„', desc: 'æŠ•å°„ç‰©æ•°é‡+1', effect: 'projCount', value: 1, maxLevel: 5 },
    wings: { key: 'wings', name: 'ç¿…è†€', icon: 'ğŸª¶', desc: 'ç§»é€Ÿ+10%', effect: 'speed', value: 0.1, maxLevel: 5 },
    attractorb: { key: 'attractorb', name: 'å¸å¼•å™¨', icon: 'ğŸ§²', desc: 'æ‹¾å–èŒƒå›´+25%', effect: 'magnet', value: 25, maxLevel: 5 },
    clover: { key: 'clover', name: 'å››å¶è‰', icon: 'ğŸ€', desc: 'å¹¸è¿+10%', effect: 'luck', value: 0.1, maxLevel: 5 },
    crown: { key: 'crown', name: 'ç‹å† ', icon: 'ğŸ‘‘', desc: 'ç»éªŒè·å–+8%', effect: 'expBonus', value: 0.08, maxLevel: 5 }
};

// è¶…æ­¦åˆæˆé…æ–¹ï¼ˆæ­¦å™¨æ»¡çº§+å¯¹åº”è¢«åŠ¨=è¶…æ­¦ï¼‰
const WEAPON_EVOLUTIONS = {
    whip: { 
        requires: 'hollow_heart', 
        result: 'blood_whip',
        name: 'è¡€é­',
        icon: 'ğŸ©¸',
        desc: 'å¯æš´å‡»å¹¶å¸è¡€',
        bonus: { dmg: 1.5, lifeSteal: 0.1, crit: 0.15 }
    },
    wand: { 
        requires: 'empty_tome', 
        result: 'holy_wand',
        name: 'åœ£é­”æ–',
        icon: 'ğŸ”¯',
        desc: 'æ— CDè‡ªåŠ¨è¿½è¸ª',
        bonus: { cd: 0.3, homing: true }
    },
    knife: { 
        requires: 'bracer', 
        result: 'thousand_edge',
        name: 'åƒåˆƒ',
        icon: 'ğŸ’ ',
        desc: 'æé€Ÿè¿å°„',
        bonus: { cd: 0.2, projCount: 2 }
    },
    axe: { 
        requires: 'candelabrador', 
        result: 'death_spiral',
        name: 'æ­»äº¡èºæ—‹',
        icon: 'ğŸŒ€',
        desc: 'ç©¿é€é«˜ä¼¤',
        bonus: { dmg: 1.8, pierce: 5 }
    },
    cross: { 
        requires: 'clover', 
        result: 'heaven_sword',
        name: 'å¤©å ‚ä¹‹å‰‘',
        icon: 'âš”ï¸',
        desc: 'é«˜æš´å‡»',
        bonus: { dmg: 2, crit: 0.25 }
    },
    bible: { 
        requires: 'spellbinder', 
        result: 'unholy_vespers',
        name: 'é‚ªæ¶æ™šç¥·',
        icon: 'ğŸ“¿',
        desc: 'æ°¸ä¸æ¶ˆå¤±',
        bonus: { duration: 3 }
    },
    fireball: { 
        requires: 'spinach', 
        result: 'hellfire',
        name: 'åœ°ç‹±ç«',
        icon: 'ğŸ”¥',
        desc: 'ç©¿é€ç«ç„°',
        bonus: { dmg: 1.5, pierce: 3 }
    },
    holy_water: { 
        requires: 'attractorb', 
        result: 'la_borra',
        name: 'æ‹‰åšæ‹‰',
        icon: 'ğŸ’¦',
        desc: 'è¿½è¸ªåŒºåŸŸ',
        bonus: { homing: true, range: 1.3 }
    },
    // æ–°å¢è¶…æ­¦åˆæˆ
    shuriken: { 
        requires: 'duplicator', 
        result: 'ninja_storm',
        name: 'å¿è€…é£æš´',
        icon: 'ğŸŒ€',
        desc: 'å¼¹å¹•é½å°„',
        bonus: { projCount: 3, cd: 0.5 }
    },
    icicle: { 
        requires: 'spellbinder', 
        result: 'blizzard',
        name: 'æš´é£é›ª',
        icon: 'ğŸŒ¨ï¸',
        desc: 'èŒƒå›´å†°å†»',
        bonus: { range: 2, slow: true }
    },
    scythe: { 
        requires: 'candelabrador', 
        result: 'grim_reaper',
        name: 'æ­»ç¥é•°åˆ€',
        icon: 'ğŸ’€',
        desc: 'å³æ­»åˆ¤å®š',
        bonus: { dmg: 2, execute: 0.1 }
    },
    chakram: { 
        requires: 'bracer', 
        result: 'buzzsaw',
        name: 'ç”µé”¯',
        icon: 'ğŸªš',
        desc: 'æé€Ÿç©¿é€',
        bonus: { cd: 0.3, pierce: 8 }
    },
    poison_dart: { 
        requires: 'attractorb', 
        result: 'venom_strike',
        name: 'å‰§æ¯’æ‰“å‡»',
        icon: 'â˜ ï¸',
        desc: 'å‰§æ¯’è”“å»¶',
        bonus: { poison: true, poisonDmg: 5 }
    }
};

// è¶…æ­¦å®šä¹‰
const SUPER_WEAPONS = {
    blood_whip: { name: 'è¡€é­', icon: 'ğŸ©¸', dmg: 35, cd: 0.8, range: 120, type: 'melee', color: '#c00' },
    holy_wand: { name: 'åœ£é­”æ–', icon: 'ğŸ”¯', dmg: 20, cd: 0.2, speed: 350, type: 'proj', color: '#88f' },
    thousand_edge: { name: 'åƒåˆƒ', icon: 'ğŸ’ ', dmg: 15, cd: 0.1, speed: 500, pierce: 5, type: 'proj', color: '#0ff' },
    death_spiral: { name: 'æ­»äº¡èºæ—‹', icon: 'ğŸŒ€', dmg: 45, cd: 1.0, speed: 200, pierce: 10, type: 'proj', color: '#800' },
    heaven_sword: { name: 'å¤©å ‚ä¹‹å‰‘', icon: 'âš”ï¸', dmg: 50, cd: 1.2, speed: 300, type: 'proj', color: '#fe0' },
    unholy_vespers: { name: 'é‚ªæ¶æ™šç¥·', icon: 'ğŸ“¿', dmg: 18, cd: 0.5, range: 100, type: 'orbit', color: '#4a0' },
    hellfire: { name: 'åœ°ç‹±ç«', icon: 'ğŸ”¥', dmg: 50, cd: 1.2, speed: 250, pierce: 5, type: 'proj', color: '#f40' },
    la_borra: { name: 'æ‹‰åšæ‹‰', icon: 'ğŸ’¦', dmg: 12, cd: 0.8, range: 80, type: 'area', color: '#48f' },
    // æ–°å¢è¶…æ­¦
    ninja_storm: { name: 'å¿è€…é£æš´', icon: 'ğŸŒ€', dmg: 25, cd: 0.4, speed: 400, pierce: 3, type: 'proj', color: '#888' },
    blizzard: { name: 'æš´é£é›ª', icon: 'ğŸŒ¨ï¸', dmg: 30, cd: 1.0, speed: 200, range: 200, type: 'area', color: '#aff' },
    grim_reaper: { name: 'æ­»ç¥é•°åˆ€', icon: 'ğŸ’€', dmg: 60, cd: 1.0, range: 120, type: 'melee', color: '#848' },
    buzzsaw: { name: 'ç”µé”¯', icon: 'ğŸªš', dmg: 20, cd: 0.2, speed: 400, pierce: 10, type: 'proj', color: '#f80' },
    venom_strike: { name: 'å‰§æ¯’æ‰“å‡»', icon: 'â˜ ï¸', dmg: 15, cd: 0.4, speed: 400, type: 'proj', color: '#4a4' }
};

class Weapon {
    constructor(key, level = 1, isSuper = false) {
        this.baseKey = key;
        this.isSuper = isSuper; // æ˜¯å¦ä¸ºè¶…æ­¦
        
        // æ ¹æ®æ˜¯å¦æ˜¯è¶…æ­¦é€‰æ‹©é…ç½®
        if (isSuper && SUPER_WEAPONS[key]) {
            this.cfg = { ...SUPER_WEAPONS[key] };
            this.level = 1; // è¶…æ­¦å›ºå®š1çº§
            this.maxLevel = 1;
        } else {
            this.cfg = { ...WEAPONS[key] };
            this.level = level;
            this.maxLevel = WEAPONS[key]?.maxLevel || 8;
        }
        
        this.cd = 0;
        this.xp = 0;
        this.xpToNext = 100;
    }
    
    // è¿›åŒ–æˆè¶…æ­¦
    evolveToSuper(evoKey) {
        if (!SUPER_WEAPONS[evoKey]) return false;
        
        this.isSuper = true;
        this.baseKey = evoKey;
        this.cfg = { ...SUPER_WEAPONS[evoKey] };
        this.level = 1;
        this.maxLevel = 1;
        
        return true;
    }
    
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥å‡çº§
    canLevelUp() {
        if (this.isSuper) return false; // è¶…æ­¦ä¸èƒ½å‡çº§
        return this.level < this.maxLevel;
    }
    
    getDamage(stats) { 
        if (this.isSuper) return this.cfg.dmg; // è¶…æ­¦å›ºå®šä¼¤å®³
        let dmg = this.cfg.dmg * (1 + (this.level - 1) * 0.15);
        return dmg;
    }
    
    update(dt) { 
        this.cd -= dt;
        // é™åˆ¶CDæœ€å°å€¼ï¼Œé¿å…æ— é™å‡å°‘
        if (this.cd < -0.5) this.cd = -0.5;
    }
    canFire() { return this.cd <= 0; }
    
    addXp(amount) {
        if (this.isSuper) return false; // è¶…æ­¦ä¸èƒ½å‡çº§
        if (this.level >= this.maxLevel) return false; // æ»¡çº§
        
        this.xp += amount;
        if (this.xp >= this.xpToNext) {
            this.xp -= this.xpToNext;
            this.level++;
            this.xpToNext = Math.floor(this.xpToNext * 1.5);
            return true;
        }
        return false;
    }
    
    getLevelColor() {
        if (this.isSuper) return '#f0f'; // è¶…æ­¦ç´«è‰²
        if (this.level >= this.maxLevel) return '#fa0'; // æ»¡çº§é‡‘è‰²
        if (this.level >= 5) return '#0ff';
        if (this.level >= 3) return '#4f4';
        if (this.level >= 2) return '#fff';
        return '#aaa';
    }
    
    fire(player, target, stats) {
        // é˜²æ­¢é™¤ä»¥é›¶æˆ–æ— æ•ˆå€¼ï¼Œæœ€å°fireRateä¸º0.5é˜²æ­¢CDè¿‡å¤§
        let fireRate = (stats && stats.fireRate > 0) ? stats.fireRate : 1;
        if (fireRate < 0.5) fireRate = 0.5;  // å¼ºåˆ¶é™åˆ¶æœ€å°å€¼
        this.cd = this.cfg.cd / fireRate;
        if (this.cd > 1.0) {  // åŒé‡ä¿é™©ï¼šCDä¸èƒ½è¶…è¿‡1ç§’
            console.warn(`[Weapon] CDå¼‚å¸¸: ${this.cd.toFixed(2)}, å·²é‡ç½®ä¸º0.7`);
            this.cd = 0.7;
        }
        const bullets = [];
        const count = Math.max(1, Math.floor(stats.projCount || 1));
        
        for (let i = 0; i < count; i++) {
            let angle = 0;
            if (target) {
                angle = Math.atan2(target.y - player.y, target.x - player.x);
                if (count > 1) angle += (i - (count - 1) / 2) * 0.15;
            } else {
                angle = Math.random() * Math.PI * 2;
            }
            
            bullets.push({
                x: player.x, y: player.y,
                vx: Math.cos(angle) * (this.cfg.speed || 200),
                vy: Math.sin(angle) * (this.cfg.speed || 200),
                dmg: this.getDamage(stats),
                color: this.cfg.color,
                icon: this.cfg.icon,  // æ·»åŠ æ­¦å™¨å›¾æ ‡
                life: this.cfg.type === 'melee' ? 0.3 : 3,
                pierce: (this.cfg.pierce || 0) + stats.pierce,
                type: this.cfg.type,
                range: this.cfg.range,
                hits: new Set(),
                homing: this.cfg.type !== 'melee',
                target: target,
                weapon: this
            });
        }
        return bullets;
    }
}

// æ•Œäººé…ç½®ï¼ˆç¬¬4æ¬¡è¿­ä»£ï¼šä½¿ç”¨å…¨éƒ¨22ç§æ¨¡å‹ï¼‰
const ENEMY_TYPES = {
    // === Tier 1: å¼±å°æ•Œäºº ===
    chick: { name: 'å˜å¼‚å°é¸¡', hp: 8, speed: 160, dmg: 1, exp: 2, gold: 3, color: '#ff6', sprite: 'chick', anim: 'hop' },
    mouse: { name: 'æ„ŸæŸ“è€é¼ ', hp: 6, speed: 200, dmg: 1, exp: 2, gold: 2, color: '#888', sprite: 'mouse', anim: 'scurry' },
    snail: { name: 'å¯„ç”Ÿèœ—ç‰›', hp: 15, speed: 40, dmg: 1, exp: 1, gold: 2, color: '#8a8', sprite: 'snail', anim: 'slide' },
    pigeon: { name: 'å˜å¼‚é¸½å­', hp: 10, speed: 180, dmg: 1, exp: 2, gold: 3, color: '#ccc', sprite: 'pigeon', anim: 'flutter' },
    duck3: { name: 'å°é‡é¸­', hp: 8, speed: 140, dmg: 1, exp: 2, gold: 2, color: '#ff6', sprite: 'duck3', anim: 'waddle' },
    
    // === Tier 2: æ™®é€šæ•Œäºº ===
    rabbit: { name: 'ç‹‚æš´å…”å­', hp: 12, speed: 180, dmg: 2, exp: 3, gold: 4, color: '#f99', sprite: 'rabbit', anim: 'hop' },
    rabbit2: { name: 'æš´èµ°å…”', hp: 10, speed: 220, dmg: 2, exp: 3, gold: 4, color: '#f66', sprite: 'rabbit2', anim: 'hopfast' },
    bird: { name: 'æ„ŸæŸ“å°é¸Ÿ', hp: 10, speed: 240, dmg: 1, exp: 3, gold: 4, color: '#9cf', sprite: 'bird', anim: 'fly' },
    duck2: { name: 'é¸­é¸­', hp: 12, speed: 130, dmg: 2, exp: 3, gold: 4, color: '#fc6', sprite: 'duck2', anim: 'waddle' },
    pig2: { name: 'å°çŒªå´½', hp: 18, speed: 80, dmg: 2, exp: 3, gold: 5, color: '#fcc', sprite: 'pig2', anim: 'waddle' },
    
    // === Tier 3: æ ‡å‡†æ•Œäºº ===
    cat: { name: 'å˜å¼‚çŒ«', hp: 18, speed: 190, dmg: 2, exp: 4, gold: 6, color: '#fa3', sprite: 'cat', anim: 'prowl' },
    duck: { name: 'æ„ŸæŸ“é¸­å­', hp: 16, speed: 120, dmg: 2, exp: 4, gold: 5, color: '#ff0', sprite: 'duck', anim: 'waddle' },
    squirrel: { name: 'ç–¯ç‹‚æ¾é¼ ', hp: 14, speed: 220, dmg: 2, exp: 4, gold: 6, color: '#963', sprite: 'squirrel', anim: 'scurry' },
    goose: { name: 'å®ˆå«é¹…', hp: 20, speed: 150, dmg: 2, exp: 4, gold: 6, color: '#fff', sprite: 'goose', anim: 'charge', special: 'charge' },
    
    // === Tier 4: è¾ƒå¼ºæ•Œäºº ===
    dog: { name: 'ç–¯ç‹—', hp: 22, speed: 210, dmg: 3, exp: 6, gold: 8, color: '#963', sprite: 'dog', anim: 'run' },
    pig: { name: 'å˜å¼‚å°çŒª', hp: 28, speed: 90, dmg: 3, exp: 6, gold: 9, color: '#f9c', sprite: 'pig', anim: 'waddle' },
    sheep: { name: 'å˜å¼‚å°ç¾Š', hp: 24, speed: 110, dmg: 2, exp: 5, gold: 7, color: '#eee', sprite: 'sheep', anim: 'trot' },
    snake: { name: 'æ¯’è›‡', hp: 16, speed: 190, dmg: 3, exp: 5, gold: 8, color: '#4a4', sprite: 'snake', anim: 'slither', special: 'poison' },
    
    // === Tier 5: ç²¾è‹±æ•Œäºº ===
    bear: { name: 'å·¨ç†Š', hp: 45, speed: 80, dmg: 4, exp: 10, gold: 15, color: '#630', sprite: 'bear', anim: 'heavy' },
    crab: { name: 'é“ç”²èŸ¹', hp: 55, speed: 70, dmg: 3, exp: 12, gold: 18, color: '#f44', sprite: 'crab', anim: 'sidle', armor: 3 },
    dog2: { name: 'æ¶çŠ¬', hp: 30, speed: 200, dmg: 3, exp: 8, gold: 12, color: '#844', sprite: 'dog2', anim: 'run' },
    
    // === Tier 6: Bossçº§ ===
    turtle: { name: 'ç„é¾Ÿ', hp: 80, speed: 50, dmg: 5, exp: 20, gold: 30, color: '#2a2', sprite: 'turtle', anim: 'crawl', armor: 5 },
    
    // === ç‰¹æ®Šæ•Œäººï¼ˆå‰§æƒ…ç›¸å…³ï¼‰ ===
    tiaotiao: { name: 'è·³è·³', hp: 30, speed: 260, dmg: 3, exp: 15, gold: 20, color: '#c85', sprite: 'rabbit', anim: 'hop', special: 'jump' },
    tiezhua: { name: 'é“çˆª', hp: 28, speed: 320, dmg: 4, exp: 18, gold: 22, color: '#a52', sprite: 'bird', anim: 'dive', special: 'dive' },
    nibei: { name: 'æ³¥èƒŒ', hp: 70, speed: 60, dmg: 3, exp: 20, gold: 35, color: '#6a5', sprite: 'turtle', anim: 'crawl', special: 'tank', armor: 4 },
    yinya: { name: 'é“¶ç‰™', hp: 45, speed: 200, dmg: 4, exp: 25, gold: 30, color: '#789', sprite: 'dog2', anim: 'run', special: 'summon' },
    boss_dog: { name: 'ç‹¼ç‹', hp: 65, speed: 170, dmg: 4, exp: 18, gold: 25, color: '#444', sprite: 'dog2', anim: 'run', special: 'howl' },
    
    // æ–°å¢æ•Œäºº
    // Tier 1 æ–°æ•Œäºº
    bat: { name: 'è™è ', hp: 7, speed: 220, dmg: 1, exp: 2, gold: 3, color: '#668', sprite: 'bird', anim: 'fly' },
    
    // Tier 2 æ–°æ•Œäºº
    fox: { name: 'ç‹¡çŒ¾ç‹ç‹¸', hp: 14, speed: 200, dmg: 2, exp: 3, gold: 5, color: '#d82', sprite: 'dog', anim: 'run' },
    bee: { name: 'æ¯’èœ‚', hp: 8, speed: 260, dmg: 2, exp: 3, gold: 4, color: '#fc0', sprite: 'bird', anim: 'fly' },
    
    // Tier 3 æ–°æ•Œäºº
    wolf: { name: 'é‡ç‹¼', hp: 20, speed: 180, dmg: 2, exp: 5, gold: 7, color: '#aaa', sprite: 'dog2', anim: 'run' },
    owl: { name: 'å¤œæ­', hp: 18, speed: 160, dmg: 2, exp: 5, gold: 6, color: '#864', sprite: 'bird', anim: 'fly' },
    
    // Tier 4 æ–°æ•Œäºº
    boar: { name: 'é‡çŒª', hp: 32, speed: 120, dmg: 3, exp: 7, gold: 10, color: '#654', sprite: 'pig', anim: 'charge' },
    spider: { name: 'å·¨è››', hp: 22, speed: 150, dmg: 3, exp: 6, gold: 8, color: '#422', sprite: 'snake', anim: 'crawl' },
    
    // Tier 5 æ–°æ•Œäºº
    panther: { name: 'é»‘è±¹', hp: 40, speed: 240, dmg: 4, exp: 12, gold: 20, color: '#222', sprite: 'cat', anim: 'prowl' },
    scorpion: { name: 'æ¯’è', hp: 35, speed: 140, dmg: 4, exp: 10, gold: 16, color: '#a40', sprite: 'crab', anim: 'sidle' },
    
    // ç‰¹æ®Šæ•Œäºº
    mimic: { name: 'å®ç®±æ€ª', hp: 50, speed: 100, dmg: 5, exp: 30, gold: 50, color: '#a44', sprite: 'bear', anim: 'heavy', special: 'mimic' },
    ghost: { name: 'å¹½çµ', hp: 25, speed: 180, dmg: 3, exp: 15, gold: 25, color: '#8ff', sprite: 'pigeon', anim: 'flutter', special: 'ethereal' }
};

// BOSSé…ç½®
const BOSS_TYPES = {
    mother: {
        name: 'æ¯ä½“',
        hp: 500,
        speed: 30,
        dmg: 5,
        exp: 100,
        gold: 200,
        color: '#f0f',
        sprite: 'bear',
        scale: 2,
        phases: [
            { hpPercent: 100, behavior: 'normal' },
            { hpPercent: 70, behavior: 'enrage' },
            { hpPercent: 30, behavior: 'desperate' }
        ]
    }
};

class Enemy {
    constructor(x, y, typeKey) {
        const cfg = ENEMY_TYPES[typeKey] || ENEMY_TYPES.chick;
        this.x = x; this.y = y;
        this.typeKey = typeKey;
        this.hp = cfg.hp + (cfg.armor || 0) * 10;
        this.maxHp = this.hp;
        this.speed = cfg.speed;
        this.dmg = cfg.dmg;
        this.exp = cfg.exp;
        this.gold = cfg.gold || 5;
        this.color = cfg.color;
        this.sprite = cfg.sprite;
        this.special = cfg.special;
        this.armor = cfg.armor || 0;
        this.vx = 0; this.vy = 0;
        this.hitTimer = 0;
        this.attackCd = 0;
        this.specialCd = 0;
        
        // çŠ¶æ€æ•ˆæœ
        this.slowTimer = 0;
        this.stunTimer = 0;
        this.poisonTimer = 0;
        this.poisonDmg = 0;
        
        // åŠ¨ç”»ç³»ç»Ÿ
        this.animType = cfg.anim || 'walk';
        this.animTimer = 0;
        this.facingRight = true;
        this.walkCycle = 0;
    }

    update(dt, player, room) {
        // çŠ¶æ€æ•ˆæœå¤„ç†
        if (this.stunTimer > 0) {
            this.stunTimer -= dt;
            return; // çœ©æ™•æ—¶æ— æ³•è¡ŒåŠ¨
        }
        
        if (this.slowTimer > 0) {
            this.slowTimer -= dt;
            dt *= 0.5; // å‡é€Ÿ50%
        }
        
        if (this.poisonTimer > 0) {
            this.poisonTimer -= dt;
            this.hp -= this.poisonDmg * dt;
        }
        
        // ç‰¹æ®Šè¡Œä¸º
        if (this.special === 'jump' && this.specialCd <= 0) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d > 0 && d < 200) {
                this.vx = (dx / d) * this.speed * 2;
                this.vy = (dy / d) * this.speed * 2;
                this.specialCd = 2;
            }
        } else if (this.special === 'dive' && this.specialCd <= 0) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d > 100 && d < 400) {
                this.vx = (dx / d) * this.speed * 3;
                this.vy = (dy / d) * this.speed * 3;
                this.specialCd = 3;
            }
        } else {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            
            if (d > 0) {
                this.vx = (dx / d) * this.speed;
                this.vy = (dy / d) * this.speed;
            }
        }
        
        if (this.special === 'tank') {
            this.vx *= 0.8;
            this.vy *= 0.8;
        }
        
        if (this.special === 'summon' && this.specialCd <= 0 && room.enemies.length < 10) {
            this.specialCd = 5;
            const angle = Math.random() * Math.PI * 2;
            const r = 30;
            room.enemies.push(new Enemy(
                this.x + Math.cos(angle) * r,
                this.y + Math.sin(angle) * r,
                'dog'
            ));
        }
        
        for (const other of room.enemies) {
            if (other === this) continue;
            const odx = this.x - other.x;
            const ody = this.y - other.y;
            const od = Math.sqrt(odx*odx + ody*ody);
            if (od < 30 && od > 0) {
                this.vx += (odx / od) * 50;
                this.vy += (ody / od) * 50;
            }
        }
        
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        // ä½¿ç”¨æˆ¿é—´å®é™…å°ºå¯¸é™åˆ¶æ•Œäººç§»åŠ¨
        const wallT = 60;
        const maxX = room ? room.width - wallT : 1140;
        const maxY = room ? room.height - wallT : 740;
        this.x = clamp(this.x, wallT, maxX);
        this.y = clamp(this.y, wallT, maxY);
        
        // æ›´æ–°åŠ¨ç”»çŠ¶æ€
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        if (speed > 10) {
            // æ ¹æ®é€Ÿåº¦æ–¹å‘å†³å®šæœå‘
            if (Math.abs(this.vx) > Math.abs(this.vy)) {
                this.facingRight = this.vx > 0;
            }
            // æ›´æ–°è¡Œèµ°å‘¨æœŸ
            this.walkCycle += speed * dt * 0.02;
        } else {
            this.walkCycle = 0;
        }
        this.animTimer += dt;
        
        if (this.hitTimer > 0) this.hitTimer -= dt;
        if (this.attackCd > 0) this.attackCd -= dt;
        if (this.specialCd > 0) this.specialCd -= dt;
    }

    takeDamage(dmg, stats = {}) {
        const actualDmg = Math.max(1, dmg - this.armor);
        this.hp -= actualDmg;
        this.hitTimer = 0.15;
        
        // æ˜¾ç¤ºä¼¤å®³æ•°å­—
        if (window.game && window.game.damageNumbers) {
            const isCrit = stats.crit && Math.random() < stats.crit;
            window.game.damageNumbers.spawn(this.x, this.y - 20, Math.floor(actualDmg), {
                critical: isCrit
            });
        }
        
        // å—å‡»ç²’å­æ•ˆæœ
        if (window.game && window.game.particles) {
            window.game.particles.burst(this.x, this.y, '#fff', 5, { type: 'circle', life: 0.3 });
            // å‡ºè¡€æ•ˆæœ
            window.game.particles.burst(this.x, this.y, '#f44', 3, { type: 'circle', size: 3 });
        }
        
        // å‡»é€€æ•ˆæœ
        if (stats.knockback && window.game && window.game.player) {
            const angle = Math.atan2(this.y - window.game.player.y, this.x - window.game.player.x);
            this.x += Math.cos(angle) * stats.knockback;
            this.y += Math.sin(angle) * stats.knockback;
        }
        
        // åº”ç”¨çŠ¶æ€æ•ˆæœ
        if (stats.slowChance && Math.random() < stats.slowChance) {
            this.slowTimer = 2;
        }
        if (stats.stunChance && Math.random() < stats.stunChance) {
            this.stunTimer = 1;
        }
        
        return this.hp <= 0;
    }

    applyPoison(dmg, duration) {
        this.poisonDmg = Math.max(this.poisonDmg, dmg);
        this.poisonTimer = Math.max(this.poisonTimer, duration);
    }

    // ä½¿ç”¨ä¸–ç•Œåæ ‡ç»˜åˆ¶ï¼ˆåœ¨Room.drawä¸­ä½¿ç”¨ï¼‰
    draw(ctx, sprites) {
        const size = this.isBoss ? 36 : 16;
        
        if (this.hitTimer > 0 && Math.floor(Date.now() / 50) % 2) {
            ctx.globalAlpha = 0.5;
        }
        
        // çŠ¶æ€æ•ˆæœè§†è§‰
        if (this.slowTimer > 0) {
            ctx.strokeStyle = '#48f';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size + 5, 0, Math.PI * 2);
            ctx.stroke();
        }
        if (this.poisonTimer > 0) {
            ctx.strokeStyle = '#4a4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size + 8, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        if (this.isBoss) {
            ctx.strokeStyle = `rgba(255, 0, 255, ${0.3 + Math.sin(Date.now() / 200) * 0.2})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size + 10, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // ç»˜åˆ¶æ•Œäººç²¾çµï¼ˆå¸¦åŠ¨ç”»æ•ˆæœï¼‰
        const sprite = sprites.get(this.sprite);
        if (sprite) {
            ctx.save();
            
            // è®¡ç®—åŠ¨ç”»åç§»å’Œæ—‹è½¬
            let offsetY = 0;
            let rotate = 0;
            let scaleX = this.facingRight ? 1 : -1;
            let scaleY = 1;
            
            const walkPhase = Math.sin(this.walkCycle);
            const walkPhase2 = Math.cos(this.walkCycle);
            
            switch (this.animType) {
                case 'hop': // è·³è·ƒ - å¤§å¹…ä¸Šä¸‹å¼¹è·³
                    offsetY = Math.abs(Math.sin(this.walkCycle * 0.5)) * -8;
                    rotate = this.vx * 0.01;
                    break;
                case 'hopfast': // å¿«é€Ÿè·³è·ƒ
                    offsetY = Math.abs(Math.sin(this.walkCycle * 0.8)) * -6;
                    rotate = this.vx * 0.015;
                    break;
                case 'scurry': // ç–¾èµ° - é«˜é¢‘å°å¹…
                    offsetY = walkPhase * 2;
                    rotate = walkPhase * 0.1;
                    break;
                case 'slide': // æ»‘åŠ¨ - å¹³æ»‘
                    offsetY = 0;
                    rotate = 0;
                    break;
                case 'flutter': // æŒ¯ç¿… - å¿«é€ŸæŒ¯åŠ¨
                    offsetY = Math.sin(this.animTimer * 15) * 3;
                    rotate = Math.sin(this.animTimer * 10) * 0.1;
                    break;
                case 'waddle': // æ‘‡æ‘† - å·¦å³æ‘‡æ‘†
                    offsetY = Math.abs(walkPhase) * -2;
                    rotate = walkPhase * 0.2;
                    break;
                case 'fly': // é£è¡Œ - ä¸Šä¸‹æµ®åŠ¨
                    offsetY = Math.sin(this.animTimer * 3) * 4;
                    rotate = this.vx * 0.005;
                    break;
                case 'prowl': // æ½œè¡Œ - ç¼“æ…¢æ¥è¿‘
                    offsetY = walkPhase2 * 1;
                    rotate = walkPhase * 0.05;
                    break;
                case 'run': // å¥”è·‘
                    offsetY = Math.abs(walkPhase) * -3;
                    rotate = this.vx * 0.008;
                    break;
                case 'trot': // å°è·‘
                    offsetY = walkPhase * 2;
                    rotate = walkPhase * 0.08;
                    break;
                case 'slither': // æ»‘è¡Œ - Så½¢
                    offsetY = Math.sin(this.x * 0.1 + this.animTimer * 5) * 2;
                    rotate = Math.cos(this.x * 0.1 + this.animTimer * 5) * 0.15;
                    break;
                case 'heavy': // æ²‰é‡ - æ…¢é€Ÿå¤§å¹…
                    offsetY = Math.abs(walkPhase) * -4;
                    rotate = walkPhase * 0.15;
                    break;
                case 'sidle': // æ¨ªç§»
                    offsetY = 0;
                    rotate = walkPhase * 0.1;
                    break;
                case 'crawl': // çˆ¬è¡Œ
                    offsetY = 4;
                    scaleY = 0.7;
                    rotate = walkPhase * 0.05;
                    break;
                case 'charge': // å†²é”‹
                    offsetY = Math.abs(walkPhase) * -2;
                    rotate = this.facingRight ? 0.1 : -0.1;
                    break;
                case 'dive': // ä¿¯å†²
                    offsetY = Math.sin(this.animTimer * 8) * 6;
                    rotate = this.vy * 0.02;
                    break;
                default: // é»˜è®¤è¡Œèµ°
                    offsetY = walkPhase * 1.5;
                    rotate = this.vx * 0.003;
            }
            
            // åº”ç”¨å˜æ¢
            ctx.translate(this.x, this.y + offsetY);
            ctx.rotate(rotate);
            ctx.scale(scaleX, scaleY);
            
            // ç²¾è‹±æ•Œäººï¼šç»˜åˆ¶é¢œè‰²å åŠ æ•ˆæœï¼ˆæ¢è‰²ï¼‰
            if (this.isElite) {
                // ä½¿ç”¨æ··åˆæ¨¡å¼ç»™ç²¾è‹±æ•Œäººæ·»åŠ é¢œè‰²è‰²è°ƒ
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = 'rgba(255, 100, 100, 0.4)'; // çº¢è‰²ç²¾è‹±è‰²è°ƒ
                ctx.fillRect(-size, -size, size * 2, size * 2);
                ctx.restore();
            }
            
            // ç»˜åˆ¶ç²¾çµ
            ctx.drawImage(sprite, -size, -size, size * 2, size * 2);
            
            // ç²¾è‹±æ•Œäººï¼šæ·»åŠ å‘å…‰è¾¹æ¡†æ•ˆæœ
            if (this.isElite) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 80, 80, 0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(-size - 2, -size - 2, size * 2 + 4, size * 2 + 4);
                ctx.restore();
            }
            
            ctx.restore();
        } else {
            // ä½¿ç”¨emojiä½œä¸ºåå¤‡
            const emojiMap = {
                chick: 'ğŸ¤', pig: 'ğŸ·', sheep: 'ğŸ‘', dog: 'ğŸ•', cat: 'ğŸ±',
                bear: 'ğŸ»', rabbit: 'ğŸ°', bird: 'ğŸ¦', turtle: 'ğŸ¢', dog2: 'ğŸº',
                mouse: 'ğŸ­', snail: 'ğŸŒ', squirrel: 'ğŸ¿ï¸', goose: 'ğŸª¿',
                duck: 'ğŸ¦†', duck2: 'ğŸ¦†', duck3: 'ğŸ¥', snake: 'ğŸ',
                crab: 'ğŸ¦€', pigeon: 'ğŸ•Šï¸', pig2: 'ğŸ–', rabbit2: 'ğŸ‡'
            };
            ctx.fillStyle = '#fff';  // é‡ç½®ä¸ºç™½è‰²ï¼Œé¿å…ç»§æ‰¿é»‘è‰²èƒŒæ™¯
            ctx.font = this.isBoss ? '48px Arial' : '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(emojiMap[this.sprite] || 'ğŸ‘¾', this.x, this.y + 8);
        }
        
        ctx.globalAlpha = 1;
        
        if (this.hp < this.maxHp) {
            const barWidth = this.isBoss ? 100 : 24;
            ctx.fillStyle = '#000';
            ctx.fillRect(this.x - barWidth/2, this.y - size - 10, barWidth, 6);
            ctx.fillStyle = this.isBoss ? '#f0f' : '#f00';
            ctx.fillRect(this.x - barWidth/2, this.y - size - 10, barWidth * (this.hp / this.maxHp), 6);
        }
        
        if (this.isBoss) {
            ctx.fillStyle = '#f0f';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(this.name, this.x, this.y - size - 20);
        }
    }
    
    // ä½¿ç”¨åç§»åæ ‡ç»˜åˆ¶ï¼ˆåœ¨å·²ç»translateåˆ°å±å¹•åæ ‡åè°ƒç”¨ï¼‰
    drawWithOffset(ctx, sprites) {
        const size = this.isBoss ? 36 : 16;
        
        if (this.hitTimer > 0 && Math.floor(Date.now() / 50) % 2) {
            ctx.globalAlpha = 0.5;
        }
        
        // çŠ¶æ€æ•ˆæœè§†è§‰
        if (this.slowTimer > 0) {
            ctx.strokeStyle = '#48f';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, size + 5, 0, Math.PI * 2);
            ctx.stroke();
        }
        if (this.poisonTimer > 0) {
            ctx.strokeStyle = '#4a4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, size + 8, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        if (this.isBoss) {
            ctx.strokeStyle = `rgba(255, 0, 255, ${0.3 + Math.sin(Date.now() / 200) * 0.2})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, size + 10, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // ç»˜åˆ¶æ•Œäººç²¾çµï¼ˆå¸¦åŠ¨ç”»æ•ˆæœï¼‰- å·²ç»åœ¨(0,0)ä½ç½®
        const sprite = sprites.get(this.sprite);
        if (sprite) {
            ctx.save();
            
            // è®¡ç®—åŠ¨ç”»åç§»å’Œæ—‹è½¬
            let offsetY = 0;
            let rotate = 0;
            let scaleX = this.facingRight ? 1 : -1;
            let scaleY = 1;
            
            const walkPhase = Math.sin(this.walkCycle);
            const walkPhase2 = Math.cos(this.walkCycle);
            
            switch (this.animType) {
                case 'hop':
                    offsetY = Math.abs(Math.sin(this.walkCycle * 0.5)) * -8;
                    rotate = this.vx * 0.01;
                    break;
                case 'hopfast':
                    offsetY = Math.abs(Math.sin(this.walkCycle * 0.8)) * -6;
                    rotate = this.vx * 0.015;
                    break;
                case 'scurry':
                    offsetY = walkPhase * 2;
                    rotate = walkPhase * 0.1;
                    break;
                case 'slide':
                    offsetY = 0;
                    rotate = 0;
                    break;
                case 'flutter':
                    offsetY = Math.sin(this.animTimer * 15) * 3;
                    rotate = Math.sin(this.animTimer * 10) * 0.1;
                    break;
                case 'waddle':
                    offsetY = Math.abs(walkPhase) * -2;
                    rotate = walkPhase * 0.2;
                    break;
                case 'fly':
                    offsetY = Math.sin(this.animTimer * 3) * 4;
                    rotate = this.vx * 0.005;
                    break;
                case 'prowl':
                    offsetY = walkPhase2 * 1;
                    rotate = walkPhase * 0.05;
                    break;
                case 'run':
                    offsetY = Math.abs(walkPhase) * -3;
                    rotate = this.vx * 0.008;
                    break;
                case 'trot':
                    offsetY = walkPhase * 2;
                    rotate = walkPhase * 0.08;
                    break;
                case 'slither':
                    offsetY = Math.sin(this.x * 0.1 + this.animTimer * 5) * 2;
                    rotate = Math.cos(this.x * 0.1 + this.animTimer * 5) * 0.15;
                    break;
                case 'heavy':
                    offsetY = Math.abs(walkPhase) * -4;
                    rotate = walkPhase * 0.15;
                    break;
                case 'sidle':
                    offsetY = 0;
                    rotate = walkPhase * 0.1;
                    break;
                case 'crawl':
                    offsetY = 4;
                    scaleY = 0.7;
                    rotate = walkPhase * 0.05;
                    break;
                case 'charge':
                    offsetY = Math.abs(walkPhase) * -2;
                    rotate = this.facingRight ? 0.1 : -0.1;
                    break;
                case 'dive':
                    offsetY = Math.sin(this.animTimer * 8) * 6;
                    rotate = this.vy * 0.02;
                    break;
                default:
                    offsetY = walkPhase * 1.5;
                    rotate = this.vx * 0.003;
            }
            
            // åº”ç”¨å˜æ¢
            ctx.translate(0, offsetY);
            ctx.rotate(rotate);
            ctx.scale(scaleX, scaleY);
            
            // ç»˜åˆ¶ç²¾çµ
            ctx.drawImage(sprite, -size, -size, size * 2, size * 2);
            
            ctx.restore();
        } else {
            // ä½¿ç”¨emojiä½œä¸ºåå¤‡
            const emojiMap = {
                chick: 'ğŸ¤', pig: 'ğŸ·', sheep: 'ğŸ‘', dog: 'ğŸ•', cat: 'ğŸ±',
                bear: 'ğŸ»', rabbit: 'ğŸ°', bird: 'ğŸ¦', turtle: 'ğŸ¢', dog2: 'ğŸº',
                mouse: 'ğŸ­', snail: 'ğŸŒ', squirrel: 'ğŸ¿ï¸', goose: 'ğŸª¿',
                duck: 'ğŸ¦†', duck2: 'ğŸ¦†', duck3: 'ğŸ¥', snake: 'ğŸ',
                crab: 'ğŸ¦€', pigeon: 'ğŸ•Šï¸', pig2: 'ğŸ–', rabbit2: 'ğŸ‡'
            };
            ctx.fillStyle = '#fff';  // é‡ç½®ä¸ºç™½è‰²ï¼Œé¿å…ç»§æ‰¿é»‘è‰²èƒŒæ™¯
            ctx.font = this.isBoss ? '48px Arial' : '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(emojiMap[this.sprite] || 'ğŸ‘¾', 0, 8);
        }
        
        ctx.globalAlpha = 1;
        
        // è¡€æ¡
        if (this.hp < this.maxHp) {
            const barWidth = this.isBoss ? 100 : 24;
            ctx.fillStyle = '#000';
            ctx.fillRect(-barWidth/2, -size - 10, barWidth, 6);
            ctx.fillStyle = this.isBoss ? '#f0f' : '#f00';
            ctx.fillRect(-barWidth/2, -size - 10, barWidth * (this.hp / this.maxHp), 6);
        }
        
        if (this.isBoss) {
            ctx.fillStyle = '#f0f';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(this.name, 0, -size - 20);
        }
    }
}

// ç›²çœ¼NPCç±»
class ShopNPC {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.name = 'ç›²çœ¼';
    }
    
    draw(ctx, playerNear = false) {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(this.x - 35, this.y - 35, 70, 70);
        ctx.strokeStyle = '#4a4';
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x - 35, this.y - 35, 70, 70);
        
        ctx.font = '32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ¦¯', this.x - 8, this.y + 8);
        ctx.fillText('ğŸ‘ï¸', this.x + 8, this.y + 8);
        
        ctx.fillStyle = '#4f4';
        ctx.font = '12px Arial';
        ctx.fillText('ç›²çœ¼', this.x, this.y + 30);
        
        if (playerNear) {
            ctx.fillStyle = '#ff0';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('æŒ‰ E æ‰“å¼€å•†åº—', this.x, this.y - 45);
        }
    }
}

// å›¾è…¾ç³»ç»Ÿ
const TOTEMS = {
    1: { id: 1, name: 'å…ˆç¥–ä¹‹åŠ›', icon: 'ğŸ¦´', desc: 'æ”»å‡»åŠ›+10%', effect: 'dmg', value: 0.1 },
    2: { id: 2, name: 'åœ°è„‰å®ˆæŠ¤', icon: 'ğŸ›¡ï¸', desc: 'æœ€å¤§ç”Ÿå‘½+1', effect: 'maxHp', value: 1 },
    3: { id: 3, name: 'ç–¾é£æ­¥', icon: 'ğŸ‘Ÿ', desc: 'ç§»åŠ¨é€Ÿåº¦+10%', effect: 'speed', value: 0.1 },
    4: { id: 4, name: 'æ™ºæ…§ä¹‹çœ¼', icon: 'ğŸ‘ï¸', desc: 'ç»éªŒè·å–+20%', effect: 'exp', value: 0.2 },
    5: { id: 5, name: 'è´ªå©ªä¹‹æ‰‹', icon: 'ğŸ’°', desc: 'é‡‘å¸è·å–+25%', effect: 'gold', value: 0.25 },
    6: { id: 6, name: 'å†ç”Ÿä¹‹è¡€', icon: 'â¤ï¸', desc: 'ç”Ÿå‘½æ¢å¤+0.1/ç§’', effect: 'regen', value: 0.1 },
    7: { id: 7, name: 'å¹¸è¿æ˜Ÿ', icon: 'â­', desc: 'æš´å‡»ç‡+5%', effect: 'crit', value: 0.05 }
};

class TotemManager {
    constructor() {
        this.owned = new Set();
        this.load();
    }
    
    load() {
        try {
            const saved = localStorage.getItem('rougecow_totems');
            if (saved) this.owned = new Set(JSON.parse(saved));
        } catch (e) {}
    }
    
    save() {
        try {
            localStorage.setItem('rougecow_totems', JSON.stringify([...this.owned]));
        } catch (e) {}
    }
    
    collect(id) {
        if (this.owned.has(id)) return false;
        this.owned.add(id);
        this.save();
        return true;
    }
    
    has(id) { return this.owned.has(id); }
    getCount() { return this.owned.size; }
    
    getAllBonuses() {
        const bonuses = { dmg: 0, maxHp: 0, speed: 0, exp: 0, gold: 0, regen: 0, crit: 0 };
        for (const id of this.owned) {
            const totem = TOTEMS[id];
            if (totem) bonuses[totem.effect] += totem.value;
        }
        return bonuses;
    }
}

// æˆ¿é—´ç±»
class Room {
    constructor(gx, gy, type = 'normal', floor = 1, templateKey = null) {
        this.gx = gx; this.gy = gy;
        this.id = `${gx},${gy}`;
        this.type = type;
        this.floor = floor;
        this.doors = { up: null, down: null, left: null, right: null };
        this.enemies = [];
        this.cleared = type === 'start' || type === 'treasure' || type === 'shop';
        this.visited = false;
        this.items = [];
        this.npc = null;
        
        // å¤§æˆ¿é—´å°ºå¯¸
        this.width = SURVIVOR_CONFIG.ROOM_WIDTH;
        this.height = SURVIVOR_CONFIG.ROOM_HEIGHT;
        this.centerX = this.width / 2;
        this.centerY = this.height / 2;
        
        // é€‰æ‹©æ¨¡æ¿ï¼ˆ8ä¸ªä¹‹ä¸€ï¼‰
        const keys = Object.keys(ROOM_TEMPLATES);
        this.templateKey = templateKey || keys[Math.floor(Math.random() * keys.length)];
        this.template = ROOM_TEMPLATES[this.templateKey];
        // å°†ç›¸å¯¹åæ ‡ï¼ˆ0-1ï¼‰è½¬æ¢ä¸ºç»å¯¹åæ ‡
        this.spawnPoints = this.template.spawnPoints.map(p => ({
            x: p.x < 1 ? p.x * this.width : p.x,
            y: p.y < 1 ? p.y * this.height : p.y
        }));
        
        // æ³¢æ¬¡ç®¡ç†å™¨
        this.hordeManager = null;
        if (type === 'normal' || type === 'boss') {
            this.hordeManager = new HordeManager(this);
        }
        
        if (type === 'shop') {
            this.npc = new ShopNPC(this.centerX, this.centerY);
        }
        
        this.spawnRoomItems();
    }
    
    spawnRoomItems() {
        if (this.type === 'treasure') {
            const count = randInt(2, 4);
            const r = Math.min(this.width, this.height) * 0.15; // ç›¸å¯¹åŠå¾„
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const x = this.centerX + Math.cos(angle) * r;
                const y = this.centerY + Math.sin(angle) * r;
                const itemId = randInt(1, 16);
                const item = ITEMS[itemId];
                if (item) {
                    this.items.push({ x, y, id: itemId, icon: item.icon, name: item.name });
                }
            }
        } else if (this.type === 'hidden') {
            const itemId = randInt(1, 16);
            const item = ITEMS[itemId];
            if (item) {
                this.items.push({
                    x: this.centerX, y: this.centerY,
                    id: itemId, icon: item.icon,
                    name: item.name + '(è¯…å’’)', cursed: true
                });
            }
        }
    }
    
    // è·å–å½“å‰æ´»è·ƒæ•Œäººï¼ˆä¾›å¤–éƒ¨ä½¿ç”¨ï¼‰
    getActiveEnemies() {
        if (this.hordeManager) {
            return this.hordeManager.getActiveEnemies();
        }
        return this.enemies.filter(e => e.hp > 0);
    }
    
    update(dt) {
        if (this.hordeManager) {
            this.hordeManager.update(dt);
            // æŒç»­è¡¥å……æ•Œäººç›´åˆ°è¾¾åˆ°æœ¬æ³¢ç›®æ ‡
            if (this.hordeManager.spawnedThisWave < this.hordeManager.targetCount) {
                this.hordeManager.spawnBatch();
            }
        }
    }

    spawnEnemies() {
        if (this.type === 'start' || this.type === 'treasure' || this.type === 'shop') return;
        
        if (this.type === 'hidden') {
            const eliteTypes = ['bear', 'yinya'];
            const typeKey = randChoice(eliteTypes);
            const elite = new Enemy(this.centerX, this.centerY, typeKey);
            elite.hp *= 2;
            elite.maxHp *= 2;
            elite.dmg *= 1.5;
            elite.isElite = true;
            // å¦‚æœæœ‰HordeManagerï¼Œæ·»åŠ åˆ°å®ƒçš„enemiesæ•°ç»„
            if (this.hordeManager) {
                this.hordeManager.enemies.push(elite);
            } else {
                this.enemies.push(elite);
            }
            return;
        }
        
        if (this.type === 'boss') {
            const bossCfg = BOSS_TYPES.mother;
            const boss = new Enemy(this.centerX, this.centerY - 100, 'bear');
            boss.name = bossCfg.name;
            boss.hp = bossCfg.hp;
            boss.maxHp = bossCfg.hp;
            boss.speed = bossCfg.speed;
            boss.dmg = bossCfg.dmg;
            boss.exp = bossCfg.exp;
            boss.gold = bossCfg.gold;
            boss.color = bossCfg.color;
            boss.isBoss = true;
            boss.phase = 0;
            // å¦‚æœæœ‰HordeManagerï¼Œæ·»åŠ åˆ°å®ƒçš„enemiesæ•°ç»„ï¼Œå¦åˆ™æ·»åŠ åˆ°Room.enemies
            if (this.hordeManager) {
                this.hordeManager.enemies.push(boss);
            } else {
                this.enemies.push(boss);
            }
            return;
        }
        
        // æ™®é€šæˆ¿é—´çš„æ•Œäººç”±HordeManageråŠ¨æ€ç”Ÿæˆï¼Œè¿™é‡Œåªå¤„ç†æ²¡æœ‰HordeManagerçš„æƒ…å†µ
        if (this.hordeManager) return;
        
        const count = randInt(3, 7);
        const types = Object.keys(ENEMY_TYPES).filter(k => !ENEMY_TYPES[k].special);
        
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const r = 150 + Math.random() * 100;
            const x = 450 + Math.cos(angle) * r;
            const y = 300 + Math.sin(angle) * r;
            
            if (Math.random() < 0.1 && (this.gx + this.gy) > 2) {
                const specialTypes = ['tiaotiao', 'tiezhua', 'nibei', 'yinya'];
                this.enemies.push(new Enemy(x, y, randChoice(specialTypes)));
            } else {
                this.enemies.push(new Enemy(x, y, randChoice(types)));
            }
        }
    }

    draw(ctx, camera) {
        const floorColors = { 
            start: '#1a1a2e', normal: '#16213e', boss: '#2d1b2e', 
            treasure: '#2d2d1b', shop: '#1b1b2d', hidden: '#2d1b2d'
        };
        
        // è®¡ç®—è§†é‡èŒƒå›´ï¼ˆä¸–ç•Œåæ ‡ï¼‰
        const viewLeft = camera.x - camera.viewWidth / 2;
        const viewTop = camera.y - camera.viewHeight / 2;
        const viewRight = viewLeft + camera.viewWidth;
        const viewBottom = viewTop + camera.viewHeight;
        
        // åœ°æ¿ä½¿ç”¨ä¸–ç•Œåæ ‡ç»˜åˆ¶ï¼Œå’Œå¢™ã€é—¨ä¿æŒä¸€è‡´
        ctx.fillStyle = floorColors[this.type] || '#16213e';
        const floorTopLeft = camera.worldToScreen(viewLeft, viewTop);
        const floorBottomRight = camera.worldToScreen(viewRight, viewBottom);
        ctx.fillRect(floorTopLeft.x, floorTopLeft.y, floorBottomRight.x - floorTopLeft.x, floorBottomRight.y - floorTopLeft.y);
        
        // æˆ¿é—´ç¯å¢ƒå…‰æ•ˆ
        this.drawAmbientEffects(ctx, camera, viewLeft, viewTop, viewRight, viewBottom);
        
        // ç»˜åˆ¶ç½‘æ ¼ï¼ˆè£…é¥°ï¼‰
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1;
        const gridStartX = Math.floor(viewLeft / 50) * 50;
        const gridStartY = Math.floor(viewTop / 50) * 50;
        for (let wx = gridStartX; wx < viewRight; wx += 50) {
            const top = camera.worldToScreen(wx, viewTop);
            const bottom = camera.worldToScreen(wx, viewBottom);
            ctx.beginPath(); ctx.moveTo(top.x, top.y); ctx.lineTo(bottom.x, bottom.y); ctx.stroke();
        }
        for (let wy = gridStartY; wy < viewBottom; wy += 50) {
            const left = camera.worldToScreen(viewLeft, wy);
            const right = camera.worldToScreen(viewRight, wy);
            ctx.beginPath(); ctx.moveTo(left.x, left.y); ctx.lineTo(right.x, right.y); ctx.stroke();
        }
        
        // ç»˜åˆ¶æˆ¿é—´è¾¹ç•Œï¼ˆåšå¢™ï¼‰- ä½¿ç”¨ä¸–ç•Œåæ ‡è½¬æ¢ï¼Œå’Œé—¨ä¿æŒä¸€è‡´
        ctx.fillStyle = '#0f0f1a';
        const wallThickness = 60;
        // å·¦å¢™
        if (viewLeft < wallThickness) {
            const topLeft = camera.worldToScreen(0, viewTop);
            const bottomRight = camera.worldToScreen(wallThickness, viewBottom);
            ctx.fillRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
        }
        // å³å¢™
        if (viewRight > this.width - wallThickness) {
            const topLeft = camera.worldToScreen(this.width - wallThickness, viewTop);
            const bottomRight = camera.worldToScreen(this.width, viewBottom);
            ctx.fillRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
        }
        // ä¸Šå¢™
        if (viewTop < wallThickness) {
            const topLeft = camera.worldToScreen(viewLeft, 0);
            const bottomRight = camera.worldToScreen(viewRight, wallThickness);
            ctx.fillRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
        }
        // ä¸‹å¢™
        if (viewBottom > this.height - wallThickness) {
            const topLeft = camera.worldToScreen(viewLeft, this.height - wallThickness);
            const bottomRight = camera.worldToScreen(viewRight, this.height);
            ctx.fillRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
        }
        
        // ç»˜åˆ¶é—¨ï¼ˆé—¨å‘å†…å‡¹è¿›æˆ¿é—´ï¼Œé¿å…è¢«å¢™åŒ…å›´ï¼‰
        const doorPositions = {};
        const wallT = 60; // å¢™åšåº¦
        
        for (const [dir, door] of Object.entries(this.doors)) {
            if (!door) continue;
            let doorX, doorY, doorW, doorH;
            switch(dir) {
                // é—¨å’Œå¢™å¹³é½ï¼Œä¸å‡¹é™·ä¸çªå‡º
                case 'up': doorX = this.centerX - 40; doorY = 0; doorW = 80; doorH = wallT; break;
                case 'down': doorX = this.centerX - 40; doorY = this.height - wallT; doorW = 80; doorH = wallT; break;
                case 'left': doorX = 0; doorY = this.centerY - 50; doorW = wallT; doorH = 100; break;
                case 'right': doorX = this.width - wallT; doorY = this.centerY - 50; doorW = wallT; doorH = 100; break;
            }
            doorPositions[dir] = { x: doorX, y: doorY, w: doorW, h: doorH };
            
            // åœ¨å¢™ä¸ŠæŒ–æ´ï¼ˆç”¨åœ°æ¿é¢œè‰²è¦†ç›–é—¨åŒºåŸŸï¼‰
            if (doorX < viewRight && doorX + doorW > viewLeft &&
                doorY < viewBottom && doorY + doorH > viewTop) {
                const screenPos = camera.worldToScreen(doorX, doorY);
                const screenEnd = camera.worldToScreen(doorX + doorW, doorY + doorH);
                ctx.fillStyle = floorColors[this.type] || '#16213e';
                ctx.fillRect(screenPos.x, screenPos.y, screenEnd.x - screenPos.x, screenEnd.y - screenPos.y);
            }
        }
        
        // ç»˜åˆ¶é—¨
        for (const [dir, door] of Object.entries(this.doors)) {
            if (!door) continue;
            const pos = doorPositions[dir];
            if (!pos) continue;
            
            if (pos.x < viewRight && pos.x + pos.w > viewLeft &&
                pos.y < viewBottom && pos.y + pos.h > viewTop) {
                const screenPos = camera.worldToScreen(pos.x, pos.y);
                const screenEnd = camera.worldToScreen(pos.x + pos.w, pos.y + pos.h);
                const screenW = screenEnd.x - screenPos.x;
                const screenH = screenEnd.y - screenPos.y;
                // é—¨è¾¹æ¡†
                ctx.fillStyle = '#555';
                ctx.fillRect(screenPos.x - 2, screenPos.y - 2, screenW + 4, screenH + 4);
                // é—¨æœ¬ä½“
                ctx.fillStyle = door.open ? '#4a4' : '#a44';
                ctx.fillRect(screenPos.x, screenPos.y, screenW, screenH);
                // é—¨æŠŠæ‰‹/è£…é¥°
                ctx.fillStyle = '#222';
                ctx.fillRect(screenPos.x + screenW/2 - 3, screenPos.y + screenH/2 - 3, 6, 6);
            }
        }
        
        // æˆ¿é—´ä¿¡æ¯ç°åœ¨æ˜¾ç¤ºåœ¨é¡¶éƒ¨æ ï¼Œä¸å†åœ¨æˆ¿é—´å†…ç»˜åˆ¶
    }
    
    drawAmbientEffects(ctx, camera, viewLeft, viewTop, viewRight, viewBottom) {
        const center = camera.worldToScreen(this.centerX, this.centerY);
        const time = Date.now() / 1000;
        let grad, pulse, sparkle, hiddenPulse, x, y, pos, flicker;
        
        // æ ¹æ®æˆ¿é—´ç±»å‹æ·»åŠ ä¸åŒæ°›å›´æ•ˆæœ
        switch(this.type) {
            case 'boss':
                // Bossæˆ¿é—´ - è„‰åŠ¨çº¢å…‰
                pulse = 0.3 + Math.sin(time * 2) * 0.1;
                grad = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, 400);
                grad.addColorStop(0, `rgba(255, 0, 0, ${pulse})`);
                grad.addColorStop(0.5, `rgba(100, 0, 0, ${pulse * 0.5})`);
                grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, camera.viewWidth, camera.viewHeight);
                break;
                
            case 'treasure':
                // å®ç®±æˆ¿ - é‡‘è‰²å¾®å…‰
                sparkle = 0.15 + Math.sin(time * 3) * 0.05;
                grad = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, 300);
                grad.addColorStop(0, `rgba(255, 215, 0, ${sparkle})`);
                grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, camera.viewWidth, camera.viewHeight);
                break;
                
            case 'shop':
                // å•†åº— - è“è‰²é­”æ³•å…‰
                grad = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, 250);
                grad.addColorStop(0, 'rgba(100, 150, 255, 0.1)');
                grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, camera.viewWidth, camera.viewHeight);
                break;
                
            case 'hidden':
                // éšè—æˆ¿ - ç´«è‰²è¯¡å¼‚å…‰èŠ’
                hiddenPulse = 0.2 + Math.sin(time * 1.5) * 0.08;
                grad = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, 350);
                grad.addColorStop(0, `rgba(148, 0, 211, ${hiddenPulse})`);
                grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, camera.viewWidth, camera.viewHeight);
                break;
                
            default:
                // æ™®é€šæˆ¿é—´ - å¾®å¼±ç¯å¢ƒå…‰
                if (Math.random() < 0.02) {
                    // å¶å°”é—ªçƒçš„å¾®å…‰
                    x = viewLeft + Math.random() * (viewRight - viewLeft);
                    y = viewTop + Math.random() * (viewBottom - viewTop);
                    pos = camera.worldToScreen(x, y);
                    flicker = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 30);
                    flicker.addColorStop(0, 'rgba(100, 200, 255, 0.1)');
                    flicker.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = flicker;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 30, 0, Math.PI * 2);
                    ctx.fill();
                }
        }
    }
}

// ============================================================================
// å¸è¡€é¬¼å¹¸å­˜è€…é£æ ¼åˆ·æ€ªç³»ç»Ÿ v2.0
// ============================================================================
class HordeManager {
    constructor(room) {
        this.room = room;
        this.wave = 0;
        this.timer = 0;
        this.spawnedThisWave = 0;
        this.targetCount = 0;
        this.enemies = [];
        this.maxActiveEnemies = 80;
        
        // æ ¹æ®æˆ¿é—´ç±»å‹è®¾ç½®åˆ·æ€ªç­–ç•¥
        this.setupRoomType();
        
        // ç”Ÿæˆè¾¹ç¼˜åˆ·æ€ªç‚¹ï¼ˆé¿å…åœ¨ç©å®¶è„¸ä¸Šåˆ·æ€ªï¼‰
        this.spawnPoints = this.generateSpawnPoints();
        
        // è¿›æˆ¿é—´ç«‹å³å¼€å§‹ç¬¬ä¸€æ³¢
        if (this.totalWaves > 0) {
            this.startNewWave();
        }
    }
    
    // æ ¹æ®æˆ¿é—´ç±»å‹é…ç½®
    setupRoomType() {
        const type = this.room.type;
        
        switch(type) {
            case 'normal':
                this.waveCount = 3 + Math.floor(Math.random() * 3); // 3-5æ³¢
                this.baseEnemyCount = 10; // æ•Œäººæ•°é‡ç¿»å€
                this.bossRoom = false;
                break;
            case 'boss':
                this.waveCount = 1;
                this.baseEnemyCount = 0;
                this.bossRoom = true;
                break;
            case 'hidden':
                this.waveCount = 1;
                this.baseEnemyCount = 6; // æ•Œäººæ•°é‡ç¿»å€
                this.bossRoom = false;
                this.eliteOnly = true;
                break;
            default:
                this.waveCount = 0; // èµ·ç‚¹/å•†åº—/å®ç®±ä¸åˆ·æ€ª
                this.baseEnemyCount = 0;
        }
        
        this.totalWaves = this.waveCount;
    }
    
    // ç”Ÿæˆè¾¹ç¼˜åˆ·æ€ªç‚¹ï¼ˆæˆ¿é—´å››è¾¹ï¼Œè·ç¦»å¢™ä¸€å®šè·ç¦»ï¼‰
    generateSpawnPoints() {
        const points = [];
        const w = this.room.width;
        const h = this.room.height;
        const margin = 120; // è·ç¦»å¢™çš„è·ç¦»
        
        // ä¸Šä¸‹ä¸¤è¾¹
        for (let x = margin; x < w - margin; x += 150) {
            points.push({x, y: margin});
            points.push({x, y: h - margin});
        }
        // å·¦å³ä¸¤è¾¹
        for (let y = margin; y < h - margin; y += 150) {
            points.push({x: margin, y});
            points.push({x: w - margin, y});
        }
        
        return points;
    }
    
    update(dt) {
        // å·²å®Œæˆæ‰€æœ‰æ³¢æ¬¡
        if (this.wave >= this.totalWaves && this.enemies.filter(e => e.hp > 0).length === 0) {
            // æ³¨æ„ï¼šä¸å†åœ¨è¿™é‡Œè®¾ç½® clearedï¼Œè®© Game.update() ç»Ÿä¸€å¤„ç†
            // åŒ…æ‹¬è‡ªåŠ¨æ‹¾å–ç»éªŒçƒç­‰é€»è¾‘
            this.openDoors();
            return;
        }
        
        // å½“å‰æ³¢æ¬¡æ•Œäººæ­»å®Œï¼Œç«‹å³å¼€å§‹ä¸‹ä¸€æ³¢
        const activeCount = this.enemies.filter(e => e.hp > 0).length;
        if (activeCount === 0 && this.spawnedThisWave >= this.targetCount && this.wave < this.totalWaves) {
            this.startNewWave();
        }
        
        // æŒç»­åˆ·æ€ªç›´åˆ°è¾¾åˆ°æœ¬æ³¢ç›®æ ‡
        if (this.spawnedThisWave < this.targetCount && activeCount < this.maxActiveEnemies) {
            this.spawnBatch();
        }
        
        this.enemies = this.enemies.filter(e => e.hp > 0);
    }
    
    startNewWave() {
        this.wave++;
        this.timer = 0;
        
        // éš¾åº¦å…¬å¼ï¼šåŸºç¡€æ•°é‡ Ã— (1 + æ³¢æ•° Ã— 0.2)
        const difficultyMultiplier = 1 + (this.wave - 1) * 0.2;
        this.targetCount = Math.floor(this.baseEnemyCount * difficultyMultiplier);
        this.spawnedThisWave = 0;
        
        // æ’­æ”¾æ³¢æ¬¡å¼€å§‹éŸ³æ•ˆï¼ˆæ™®é€šæˆ¿é—´ä¸”éç¬¬ä¸€æ³¢ï¼‰
        if (this.room.type === 'normal' && this.wave > 1 && window.game && window.game.sounds) {
            window.game.sounds.play('wave');
        }
        
        console.log(`ğŸŒŠ ç¬¬ ${this.wave}/${this.totalWaves} æ³¢ï¼ç›®æ ‡ï¼š${this.targetCount} åª`);
    }
    
    spawnBatch() {
        const batchSize = Math.min(3, this.targetCount - this.spawnedThisWave);
        const activeCount = this.enemies.filter(e => e.hp > 0).length;
        if (activeCount >= this.maxActiveEnemies) return;
        
        for (let i = 0; i < batchSize; i++) {
            if (this.spawnedThisWave >= this.targetCount) break;
            
            // éšæœºé€‰æ‹©åˆ·æ€ªç‚¹
            const point = this.spawnPoints[Math.floor(Math.random() * this.spawnPoints.length)];
            // æ·»åŠ éšæœºåç§»
            const x = point.x + (Math.random() - 0.5) * 60;
            const y = point.y + (Math.random() - 0.5) * 60;
            
            const enemy = this.createEnemy(x, y);
            this.enemies.push(enemy);
            this.spawnedThisWave++;
        }
    }
    
    createEnemy(x, y) {
        // æ ¹æ®æ³¢æ•°é€‰æ‹©æ•Œäººç­‰çº§
        const typeKey = this.selectEnemyType();
        const enemy = new Enemy(x, y, typeKey);
        
        // åº”ç”¨éš¾åº¦ç¼©æ”¾
        const waveMultiplier = 1 + (this.wave - 1) * 0.15; // HPæ¯æ³¢+15%
        const dmgMultiplier = 1 + (this.wave - 1) * 0.08;  // ä¼¤å®³æ¯æ³¢+8%
        const spdMultiplier = 1 + (this.wave - 1) * 0.03;  // é€Ÿåº¦æ¯æ³¢+3%
        
        enemy.hp = Math.floor(enemy.hp * waveMultiplier);
        enemy.maxHp = enemy.hp;
        enemy.dmg = Math.floor(enemy.dmg * dmgMultiplier);
        enemy.speed = Math.floor(enemy.speed * spdMultiplier);
        
        return enemy;
    }
    
    // æ ¹æ®æ³¢æ•°é€‰æ‹©æ•Œäººç±»å‹
    selectEnemyType() {
        const tierKeys = {
            1: ['chick', 'mouse', 'snail'],
            2: ['rabbit', 'bird', 'pigeon'],
            3: ['cat', 'duck', 'squirrel'],
            4: ['dog', 'pig', 'sheep', 'goose'],
            5: ['bear', 'snake', 'crab'],
            6: ['turtle', 'boss_dog']
        };
        
        let tier;
        
        if (this.eliteOnly) {
            // éšè—æˆ¿åªå‡ºç²¾è‹±
            tier = Math.random() < 0.5 ? 4 : 5;
        } else if (this.bossRoom && this.wave === 1) {
            // Bossæˆ¿ç¬¬ä¸€æ³¢å‡ºBoss
            return Math.random() < 0.5 ? 'turtle' : 'boss_dog';
        } else {
            // æ™®é€šæˆ¿é—´æ ¹æ®æ³¢æ•°é€‰æ‹©
            const roll = Math.random();
            if (this.wave === 1) {
                tier = roll < 0.7 ? 1 : 2;
            } else if (this.wave === 2) {
                tier = roll < 0.4 ? 1 : (roll < 0.8 ? 2 : 3);
            } else {
                tier = roll < 0.2 ? 2 : (roll < 0.5 ? 3 : (roll < 0.8 ? 4 : 5));
            }
        }
        
        const types = tierKeys[tier];
        return types[Math.floor(Math.random() * types.length)];
    }
    
    openDoors() {
        Object.values(this.room.doors).forEach(door => {
            if (door) {
                door.open = true;
                door.locked = false;
            }
        });
        console.log('ğŸšª æˆ¿é—´æ¸…ç†å®Œæˆï¼Œé—¨å·²å¼€å¯');
    }
    
    getActiveEnemies() {
        return this.enemies.filter(e => e.hp > 0);
    }
}

// åœ°å›¾ç”Ÿæˆå™¨
class MapGenerator {
    generate(floor = 1) {
        const rooms = new Map();
        const start = new Room(0, 0, 'start', floor);
        rooms.set(start.id, start);
        
        const queue = [start];
        const dirs = [
            { dx: 0, dy: -1, name: 'up', opp: 'down' },
            { dx: 1, dy: 0, name: 'right', opp: 'left' },
            { dx: 0, dy: 1, name: 'down', opp: 'up' },
            { dx: -1, dy: 0, name: 'left', opp: 'right' }
        ];
        
        let count = 1;
        const maxRooms = 8 + floor * 2;
        
        while (queue.length && count < maxRooms) {
            const cur = queue.shift();
            for (const dir of dirs.sort(() => Math.random() - 0.5)) {
                const nx = cur.gx + dir.dx, ny = cur.gy + dir.dy;
                const id = `${nx},${ny}`;
                
                if (rooms.has(id)) {
                    const ex = rooms.get(id);
                    if (!cur.doors[dir.name]) {
                        cur.doors[dir.name] = { open: cur.cleared, target: ex };
                        ex.doors[dir.opp] = { open: ex.cleared, target: cur };
                    }
                    continue;
                }
                
                if (Math.random() > 0.4 || count < 5) {
                    let type = 'normal';
                    if (count === maxRooms - 1) {
                        type = 'boss';
                    } else if (count > 3) {
                        const roll = Math.random();
                        if (roll < 0.15) type = 'treasure';
                        else if (roll < 0.30) type = 'shop';
                        else if (roll < 0.35) type = 'hidden';
                    }
                    
                    const nr = new Room(nx, ny, type, floor);
                    cur.doors[dir.name] = { open: cur.cleared, target: nr };
                    nr.doors[dir.opp] = { open: nr.cleared, target: cur };
                    rooms.set(id, nr);
                    queue.push(nr);
                    count++;
                }
            }
        }
        
        // ä¿®å¤ï¼šç¡®ä¿æ‰€æœ‰ç›¸é‚»æˆ¿é—´éƒ½æœ‰åŒå‘é—¨è¿æ¥
        this.fixDoorConnections(rooms);
        
        return { start, rooms };
    }
    
    // ä¿®å¤é—¨è¿æ¥ï¼šç¡®ä¿ç›¸é‚»æˆ¿é—´éƒ½æœ‰åŒå‘é—¨
    fixDoorConnections(rooms) {
        const dirs = [
            { dx: 0, dy: -1, name: 'up', opp: 'down' },
            { dx: 1, dy: 0, name: 'right', opp: 'left' },
            { dx: 0, dy: 1, name: 'down', opp: 'up' },
            { dx: -1, dy: 0, name: 'left', opp: 'right' }
        ];
        
        for (const room of rooms.values()) {
            for (const dir of dirs) {
                const nx = room.gx + dir.dx;
                const ny = room.gy + dir.dy;
                const neighborId = `${nx},${ny}`;
                
                if (rooms.has(neighborId)) {
                    const neighbor = rooms.get(neighborId);
                    // å¦‚æœå½“å‰æˆ¿é—´æ²¡æœ‰è¿™ä¸ªæ–¹å‘çš„é—¨ï¼Œåˆ›å»ºä¸€ä¸ª
                    if (!room.doors[dir.name]) {
                        room.doors[dir.name] = { 
                            open: room.cleared, 
                            target: neighbor 
                        };
                    }
                    // å¦‚æœç›¸é‚»æˆ¿é—´æ²¡æœ‰åå‘çš„é—¨ï¼Œåˆ›å»ºä¸€ä¸ª
                    if (!neighbor.doors[dir.opp]) {
                        neighbor.doors[dir.opp] = { 
                            open: neighbor.cleared, 
                            target: room 
                        };
                    }
                }
            }
        }
    }
}

// ============================================================================
// ä¸»æ¸¸æˆç±» v0.7.2
// ============================================================================
// ==================== å¸è¡€é¬¼å¹¸å­˜è€…é£æ ¼é‡æ„ ====================
const SURVIVOR_CONFIG = {
    VIEW_WIDTH: 900, VIEW_HEIGHT: 600,
    CAMERA_SMOOTH: 0.1,
    WAVE_INTERVAL: 30, WAVE_BASE_COUNT: 20, WAVE_INCREMENT: 5,
    GRID_CELL_SIZE: 150,
    // è‡ªé€‚åº”è§†é‡ï¼šå¦‚æœå±å¹•å¤Ÿå¤§å°±æ˜¾ç¤ºå®Œæ•´æˆ¿é—´
    ADAPTIVE_VIEW: true,
    // æˆ¿é—´å°ºå¯¸ä¼šåœ¨è¿è¡Œæ—¶æ ¹æ®canvasåŠ¨æ€è®¡ç®—
    ROOM_WIDTH: 1200,
    ROOM_HEIGHT: 800
};

class SurvivorCamera {
    constructor() {
        this.x = SURVIVOR_CONFIG.ROOM_WIDTH / 2;
        this.y = SURVIVOR_CONFIG.ROOM_HEIGHT / 2;
        this.target = null;
        this.viewWidth = SURVIVOR_CONFIG.VIEW_WIDTH;
        this.viewHeight = SURVIVOR_CONFIG.VIEW_HEIGHT;
        this.showFullRoom = false;
        this.zoom = 1;
        this.updateViewport();
    }
    
    // æ ¹æ®çª—å£å°ºå¯¸è®¾ç½®æˆ¿é—´å¤§å°ï¼Œç¡®ä¿æˆ¿é—´å®Œæ•´æ˜¾ç¤ºå¹¶å¡«æ»¡æ¸¸æˆåŒºåŸŸ
    updateViewport() {
        // ä½¿ç”¨çª—å£å°ºå¯¸å‡å»ä¸¤ä¾§è¾¹æ 
        const sidebarWidth = 260 * 2; // å·¦å³è¾¹æ 
        const canvasW = Math.max(800, window.innerWidth - sidebarWidth - 40);
        const canvasH = Math.max(600, window.innerHeight - 100);
        
        const canvas = document.getElementById('gameCanvas');
        if (canvas) {
            canvas.width = canvasW;
            canvas.height = canvasH;
        }
        
        // æˆ¿é—´å°ºå¯¸ = canvas å°ºå¯¸å‡å»å¢™è¾¹è·
        const wallMargin = 60;
        SURVIVOR_CONFIG.ROOM_WIDTH = Math.floor(canvasW - wallMargin * 2);
        SURVIVOR_CONFIG.ROOM_HEIGHT = Math.floor(canvasH - wallMargin * 2);
        
        const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
        const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
        
        // å§‹ç»ˆæ˜¾ç¤ºå®Œæ•´æˆ¿é—´
        this.showFullRoom = true;
        this.viewWidth = roomW;
        this.viewHeight = roomH;
        this.x = roomW / 2;
        this.y = roomH / 2;
        this.zoom = 1;
        
        console.log(`ğŸ“ æˆ¿é—´å°ºå¯¸: ${roomW}x${roomH}, Canvas: ${canvasW}x${canvasH}`);
    }
    
    follow(target) { this.target = target; }
    
    update() {
        if (this.showFullRoom) {
            // æ˜¾ç¤ºå®Œæ•´æˆ¿é—´æ—¶ï¼Œç›¸æœºå›ºå®šåœ¨ä¸­å¿ƒ
            this.x = SURVIVOR_CONFIG.ROOM_WIDTH / 2;
            this.y = SURVIVOR_CONFIG.ROOM_HEIGHT / 2;
            return;
        }
        
        if (!this.target) return;
        this.x += (this.target.x - this.x) * SURVIVOR_CONFIG.CAMERA_SMOOTH;
        this.y += (this.target.y - this.y) * SURVIVOR_CONFIG.CAMERA_SMOOTH;
        const minX = this.viewWidth / 2, maxX = SURVIVOR_CONFIG.ROOM_WIDTH - this.viewWidth / 2;
        const minY = this.viewHeight / 2, maxY = SURVIVOR_CONFIG.ROOM_HEIGHT - this.viewHeight / 2;
        this.x = Math.max(minX, Math.min(maxX, this.x));
        this.y = Math.max(minY, Math.min(maxY, this.y));
    }
    
    worldToScreen(wx, wy) {
        if (this.showFullRoom) {
            // å®Œæ•´æˆ¿é—´æ¨¡å¼ï¼šæˆ¿é—´å¡«æ»¡ canvasï¼Œè®¡ç®—å±…ä¸­åç§»
            const canvas = document.getElementById('gameCanvas');
            const canvasW = canvas ? canvas.clientWidth : 900;
            const canvasH = canvas ? canvas.clientHeight : 600;
            const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
            const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
            
            // è®¡ç®—å±…ä¸­åç§»ï¼ˆæˆ¿é—´å°ºå¯¸å·²ç»æ ¹æ® canvas è°ƒæ•´è¿‡ï¼‰
            const offsetX = (canvasW - roomW) / 2;
            const offsetY = (canvasH - roomH) / 2;
            
            return { 
                x: wx + offsetX, 
                y: wy + offsetY 
            };
        }
        return { x: wx - this.x + this.viewWidth / 2, y: wy - this.y + this.viewHeight / 2 };
    }
    
    isVisible(wx, wy, radius = 50) {
        if (this.showFullRoom) {
            return wx >= -radius && wx <= SURVIVOR_CONFIG.ROOM_WIDTH + radius 
                && wy >= -radius && wy <= SURVIVOR_CONFIG.ROOM_HEIGHT + radius;
        }
        return Math.abs(wx - this.x) < this.viewWidth / 2 + radius && Math.abs(wy - this.y) < this.viewHeight / 2 + radius;
    }
}

class SpatialGrid {
    constructor() {
        this.cellSize = SURVIVOR_CONFIG.GRID_CELL_SIZE;
        this.cells = new Map();
    }
    getKey(cx, cy) { return `${cx},${cy}`; }
    getCellByPos(x, y) {
        return { cx: Math.floor(x / this.cellSize), cy: Math.floor(y / this.cellSize) };
    }
    clear() { this.cells.clear(); }
    insert(entity) {
        const { cx, cy } = this.getCellByPos(entity.x, entity.y);
        const key = this.getKey(cx, cy);
        if (!this.cells.has(key)) this.cells.set(key, []);
        this.cells.get(key).push(entity);
        entity._gridCell = { cx, cy };
    }
    getNearby(x, y) {
        const { cx, cy } = this.getCellByPos(x, y);
        const result = [];
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const cell = this.cells.get(this.getKey(cx + dx, cy + dy));
                if (cell) result.push(...cell);
            }
        }
        return result;
    }
}

// å¯¹è±¡æ± ç®¡ç†å™¨ - ç»Ÿä¸€ç®¡ç†å¯å¤ç”¨å¯¹è±¡
class ObjectPool {
    constructor(createFn, resetFn, initialSize = 50) {
        this.createFn = createFn;
        this.resetFn = resetFn;
        this.available = [];
        this.inUse = new Set();
        
        // é¢„åˆ›å»ºå¯¹è±¡
        for (let i = 0; i < initialSize; i++) {
            this.available.push(this.createFn());
        }
    }
    
    acquire() {
        let obj = this.available.pop();
        if (!obj) {
            obj = this.createFn();
        }
        this.resetFn(obj);
        this.inUse.add(obj);
        return obj;
    }
    
    release(obj) {
        if (this.inUse.has(obj)) {
            this.inUse.delete(obj);
            this.available.push(obj);
        }
    }
    
    releaseAll() {
        this.inUse.forEach(obj => this.available.push(obj));
        this.inUse.clear();
    }
    
    getStats() {
        return {
            available: this.available.length,
            inUse: this.inUse.size,
            total: this.available.length + this.inUse.size
        };
    }
}

// æ€§èƒ½ç›‘æ§å™¨
class PerformanceMonitor {
    constructor() {
        this.frames = [];
        this.lastTime = performance.now();
        this.fps = 60;
        this.avgFps = 60;
        this.frameTime = 16.67;
        this.updateInterval = 500; // æ¯500msæ›´æ–°ä¸€æ¬¡æ˜¾ç¤º
        this.lastUpdate = 0;
        this.visible = false;
    }
    
    update() {
        const now = performance.now();
        const delta = now - this.lastTime;
        this.lastTime = now;
        
        this.frameTime = delta;
        this.frames.push(1000 / delta);
        
        // ä¿ç•™æœ€è¿‘60å¸§
        if (this.frames.length > 60) {
            this.frames.shift();
        }
        
        // è®¡ç®—å¹³å‡FPS
        if (now - this.lastUpdate > this.updateInterval) {
            this.avgFps = Math.round(this.frames.reduce((a, b) => a + b, 0) / this.frames.length);
            this.lastUpdate = now;
        }
        
        this.fps = Math.round(1000 / delta);
    }
    
    draw(ctx, x, y) {
        if (!this.visible) return;
        
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(x, y, 140, 70);
        
        ctx.fillStyle = this.avgFps >= 55 ? '#4f4' : this.avgFps >= 30 ? '#ff0' : '#f44';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`FPS: ${this.avgFps}`, x + 10, y + 20);
        
        ctx.fillStyle = '#fff';
        ctx.font = '12px Arial';
        ctx.fillText(`Frame: ${this.frameTime.toFixed(1)}ms`, x + 10, y + 38);
        ctx.fillText(`Objects: ${window.game?.bullets?.length || 0}B ${window.game?.particles?.active?.length || 0}P`, x + 10, y + 56);
    }
    
    toggle() {
        this.visible = !this.visible;
        return this.visible;
    }
}

// 8ä¸ªæˆ¿é—´æ¨¡æ¿ - ä½¿ç”¨ç›¸å¯¹åæ ‡ (0-1)ï¼Œåœ¨ Room æ„é€ å‡½æ•°ä¸­è½¬æ¢ä¸ºç»å¯¹åæ ‡
const ROOM_TEMPLATES = {
    empty: { name: 'ç©ºæ—·å¤§å…', spawnPoints: [{x:0.5,y:0.5}] },
    pillars: { name: 'æŸ±å»Š', spawnPoints: [{x:0.5,y:0.5}] },
    corners: { name: 'å¹¿åœº', spawnPoints: [{x:0.5,y:0.5}] },
    cross: { name: 'åå­—å…', spawnPoints: [{x:0.5,y:0.5}] },
    sides: { name: 'å›å»Š', spawnPoints: [{x:0.5,y:0.5}] },
    grid: { name: 'å¤§å…', spawnPoints: [{x:0.5,y:0.5}] },
    ring: { name: 'ç«æŠ€åœº', spawnPoints: [{x:0.5,y:0.5}] },
    maze: { name: 'è¿·å®«', spawnPoints: [{x:0.5,y:0.5}] }
};

// æ¥¼å±‚ä¸»é¢˜é…ç½®
const FLOOR_THEMES = {
    1: { name: 'èŒä¸åŒº', bgColor: '#0a0f0a', accentColor: '#4a4', enemyMod: 0.8 },
    2: { name: 'å­µåŒ–æ¸©å®¤', bgColor: '#0a0a0f', accentColor: '#48f', enemyMod: 0.9 },
    3: { name: 'ç¥ç»ç´¢', bgColor: '#0f0a0f', accentColor: '#f4f', enemyMod: 1.0 },
    4: { name: 'æ¶ˆåŒ–ç†”ç‚‰', bgColor: '#0f0a0a', accentColor: '#f44', enemyMod: 1.1 },
    5: { name: 'æ¯è™«åº­é™¢', bgColor: '#0a0f0f', accentColor: '#4ff', enemyMod: 1.2 },
    6: { name: 'åƒæ ¹ä¹‹å¿ƒ', bgColor: '#0a0a0a', accentColor: '#ff0', enemyMod: 1.3 }
};

// åœ°å›¾äº‹ä»¶ç±»å‹
const MAP_EVENTS = {
    trap: { name: 'é™·é˜±', icon: 'âš ï¸', chance: 0.05, effect: 'damage' },
    shrine: { name: 'ç¥é¾›', icon: 'ğŸ™', chance: 0.03, effect: 'bless' },
    cache: { name: 'è¡¥ç»™', icon: 'ğŸ“¦', chance: 0.04, effect: 'loot' },
    portal: { name: 'ä¼ é€é—¨', icon: 'ğŸŒ€', chance: 0.02, effect: 'warp' }
};

// å…¨å±é€‚é…å™¨ - 3æ å¸ƒå±€æ¨¡å¼ä¸‹ä¸å¹²é¢„canvasæ ·å¼
class FullscreenAdapter {
    constructor(canvas, gameWidth = 900, gameHeight = 600) {
        this.canvas = canvas;
        this.gameWidth = gameWidth;
        this.gameHeight = gameHeight;
        this.scale = 1;
        // 3æ å¸ƒå±€æ¨¡å¼ä¸‹ä¸è‡ªåŠ¨è°ƒæ•´canvasæ ·å¼
        // this.setup();
        // window.addEventListener('resize', () => this.resize());
    }
    setup() {
        // å·²ç¦ç”¨ - 3æ å¸ƒå±€ç”±CSSæ§åˆ¶
    }
    resize() {
        // å·²ç¦ç”¨ - 3æ å¸ƒå±€ç”±CSSæ§åˆ¶
        // åªæ›´æ–°ç›¸æœºè§†é‡
        if (window.game?.camera) {
            window.game.camera.updateViewport();
        }
    }
}

// ============================================================================
// åˆ†æ•°ç³»ç»Ÿ - ScoreManager
// ============================================================================

class ScoreManager {
    constructor() {
        this.score = 0;
        this.startTime = 0;
        this.endTime = 0;
        this.isPlaying = false;
        
        // ç»Ÿè®¡
        this.stats = {
            enemiesKilled: 0,
            elitesKilled: 0,
            bossesKilled: 0,
            roomsExplored: 0,
            itemsCollected: 0,
            goldCollected: 0,
            damageTaken: 0,
            floorsCleared: 0
        };
        
        // è¿æ€ç³»ç»Ÿ
        this.killStreak = 0;
        this.lastKillTime = 0;
        this.streakMultiplier = 1;
        
        // æœ€ä½åˆ†ä¿æŠ¤
        this.MIN_SCORE = 100;
    }
    
    start() {
        this.score = 0;
        this.startTime = Date.now();
        this.isPlaying = true;
        this.stats = {
            enemiesKilled: 0,
            elitesKilled: 0,
            bossesKilled: 0,
            roomsExplored: 0,
            itemsCollected: 0,
            goldCollected: 0,
            damageTaken: 0,
            floorsCleared: 0
        };
        this.killStreak = 0;
        this.streakMultiplier = 1;
        console.log('ğŸ† åˆ†æ•°ç³»ç»Ÿå¯åŠ¨ï¼');
    }
    
    // åŸºç¡€åŠ åˆ†
    add(points, reason = '') {
        if (!this.isPlaying) return;
        const actual = Math.floor(points * this.streakMultiplier);
        this.score += actual;
        if (reason) console.log(`ğŸ’¯ +${actual}åˆ† (${reason})`);
        return actual;
    }
    
    // æ‰£åˆ†
    deduct(points, reason = '') {
        if (!this.isPlaying) return;
        this.score = Math.max(this.MIN_SCORE - 500, this.score - points); // ä¿è¯æ­»äº¡åä¸ä½äºMIN_SCORE
        if (reason) console.log(`ğŸ’” -${points}åˆ† (${reason})`);
    }
    
    // å‡»æ€æ•Œäºº
    onKillEnemy(enemyType = 'normal') {
        this.stats.enemiesKilled++;
        
        // è¿æ€è®¡ç®—
        const now = Date.now();
        if (now - this.lastKillTime < 10000) { // 10ç§’å†…
            this.killStreak++;
            if (this.killStreak >= 3) {
                this.streakMultiplier = 1.5;
                console.log(`ğŸ”¥ è¿æ€x${this.killStreak}ï¼åˆ†æ•°åŠ æˆ50%`);
            }
        } else {
            this.killStreak = 1;
            this.streakMultiplier = 1;
        }
        this.lastKillTime = now;
        
        let points = 10;
        if (enemyType === 'elite') {
            points = 30;
            this.stats.elitesKilled++;
        } else if (enemyType === 'boss') {
            points = 500;
            this.stats.bossesKilled++;
        }
        
        this.add(points, `å‡»æ€${enemyType === 'normal' ? 'æ™®é€šæ€ª' : enemyType === 'elite' ? 'ç²¾è‹±' : 'Boss'}`);
    }
    
    // è¿›å…¥æ–°æˆ¿é—´
    onEnterRoom() {
        this.stats.roomsExplored++;
        this.add(50, 'æ¢ç´¢æ–°æˆ¿é—´');
    }
    
    // æ‹¾å–é“å…·
    onCollectItem() {
        this.stats.itemsCollected++;
        this.add(50, 'æ‹¾å–é“å…·');
    }
    
    // æ‹¾å–é‡‘å¸
    onCollectGold(amount) {
        this.stats.goldCollected += amount;
        this.add(amount, `æ‹¾å–${amount}é‡‘å¸`);
    }
    
    // å—ä¼¤
    onDamage() {
        this.stats.damageTaken++;
        this.deduct(5, 'å—ä¼¤');
    }
    
    // åˆ°è¾¾ä¸‹å±‚
    onFloorClear(floorNum) {
        this.stats.floorsCleared++;
        this.add(300, `é€šå…³ç¬¬${floorNum}å±‚`);
    }
    
    // è¿›å…¥æ–°å±‚ï¼ˆåˆ«åï¼‰
    onEnterFloor(floorNum) {
        this.onFloorClear(floorNum);
    }
    
    // æ¸¸æˆç»“æŸè®¡ç®—
    end(result) {
        this.isPlaying = false;
        this.endTime = Date.now();
        
        const playTime = (this.endTime - this.startTime) / 1000; // ç§’
        let finalScore = this.score;
        let multiplier = 1;
        
        // é€šå…³åŠ æˆ
        if (result === 'cleared') {
            multiplier = 1.5;
            
            // æ— ä¼¤åŠ æˆ
            if (this.stats.damageTaken === 0) {
                multiplier = 2.0;
                console.log('ğŸŒŸ æ— ä¼¤é€šå…³ï¼åˆ†æ•°Ã—2');
            }
            
            // å¿«é€Ÿé€šå…³
            if (playTime < 300) { // 5åˆ†é’Ÿ
                multiplier *= 1.5;
                console.log('âš¡ æé€Ÿé€šå…³ï¼é¢å¤–Ã—1.5');
            }
        }
        
        // æ­»äº¡æƒ©ç½š
        if (result === 'dead') {
            finalScore -= 500;
            console.log('ğŸ’€ æ­»äº¡æƒ©ç½š -500åˆ†');
        }
        
        finalScore = Math.max(this.MIN_SCORE, Math.floor(finalScore * multiplier));
        
        // ä¿å­˜åˆ°æœ¬åœ°æ’è¡Œæ¦œ
        this.saveHighScore(finalScore, result);
        
        return {
            finalScore,
            baseScore: this.score,
            multiplier,
            playTime,
            stats: {...this.stats},
            result
        };
    }
    
    // ä¿å­˜æœ€é«˜åˆ†
    saveHighScore(score, result) {
        const key = 'rougecow_highscores';
        let scores = JSON.parse(localStorage.getItem(key) || '[]');
        scores.push({
            score,
            result,
            date: new Date().toISOString(),
            stats: {...this.stats}
        });
        scores.sort((a, b) => b.score - a.score);
        scores = scores.slice(0, 10); // åªä¿ç•™å‰10
        localStorage.setItem(key, JSON.stringify(scores));
    }
    
    // è·å–æ’è¡Œæ¦œ
    getHighScores() {
        return JSON.parse(localStorage.getItem('rougecow_highscores') || '[]');
    }
    
    // æ ¼å¼åŒ–æ˜¾ç¤º
    formatScore() {
        return this.score.toLocaleString();
    }
}

// ============================================================================

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // åˆ†æ•°ç³»ç»Ÿ
        this.scoreManager = new ScoreManager();
        
        // å…¨å±é€‚é…
        this.fullscreen = new FullscreenAdapter(this.canvas, 900, 600);
        
        // ç›¸æœºç³»ç»Ÿ
        this.camera = new SurvivorCamera();
        
        // ç©ºé—´ç½‘æ ¼ï¼ˆç¢°æ’ä¼˜åŒ–ï¼‰
        this.spatialGrid = new SpatialGrid();
        this.perfMonitor = new PerformanceMonitor();
        
        this.sprites = new SpriteLoader();
        this.state = 'loading';
        
        // ç©å®¶åˆå§‹ä½ç½® - æ‰¾å®‰å…¨ä½ç½®ï¼ˆé¿å¼€éšœç¢ç‰©ï¼‰
        let startX = SURVIVOR_CONFIG.ROOM_WIDTH / 2;
        let startY = SURVIVOR_CONFIG.ROOM_HEIGHT / 2;
        
        // æ£€æŸ¥ä¸­å¿ƒæ˜¯å¦æœ‰éšœç¢ç‰©ï¼Œå¦‚æœæœ‰å°±å°è¯•å…¶ä»–ä½ç½®
        const wallT = 60;  // å¢™åšåº¦æ”¹å°
        const safePositions = [
            {x: startX, y: startY},                    // ä¸­å¿ƒ
            {x: startX - 100, y: startY},              // å·¦
            {x: startX + 100, y: startY},              // å³
            {x: startX, y: startY - 100},              // ä¸Š
            {x: startX, y: startY + 100},              // ä¸‹
            {x: startX - 150, y: startY - 150},        // å·¦ä¸Š
            {x: startX + 150, y: startY - 150},        // å³ä¸Š
            {x: startX - 150, y: startY + 150},        // å·¦ä¸‹
            {x: startX + 150, y: startY + 150},        // å³ä¸‹
            {x: wallT + 50, y: wallT + 50},            // å·¦ä¸Šè§’é™„è¿‘
            {x: SURVIVOR_CONFIG.ROOM_WIDTH - wallT - 50, y: wallT + 50}, // å³ä¸Šè§’
            {x: wallT + 50, y: SURVIVOR_CONFIG.ROOM_HEIGHT - wallT - 50}, // å·¦ä¸‹è§’
            {x: SURVIVOR_CONFIG.ROOM_WIDTH - wallT - 50, y: SURVIVOR_CONFIG.ROOM_HEIGHT - wallT - 50} // å³ä¸‹è§’
        ];
        
        let safePos = safePositions[0];
        
        this.player = { x: safePos.x, y: safePos.y, hp: 6, maxHp: 6, exp: 0, lv: 1, gold: 100, 
            facingRight: true, isMoving: false, walkCycle: 0,
            isDashing: false, dashTime: 0, dashCooldown: 0, dashDirection: {x:0, y:0}, dashTrail: [], jumpY: 0
        };
        
        // ç›¸æœºè·Ÿéšç©å®¶
        this.camera.follow(this.player);
        this.items = new ItemManager(this.player);
        this.passives = new PassiveManager(this.player); // è¢«åŠ¨é“å…·ç³»ç»Ÿï¼ˆå¸è¡€é¬¼å¹¸å­˜è€…é£æ ¼ï¼‰
        this.totems = new TotemManager();
        this.materials = new MaterialManager(); // ææ–™ç³»ç»Ÿ
        this.weapons = [];  // æ­¦å™¨å°†åœ¨é€‰æ‹©ååˆå§‹åŒ–
        this.bullets = [];
        this.particles = new ParticleSystem();
        this.damageNumbers = new DamageNumberSystem();
        this.gems = [];
        this.goldDrops = [];
        
        this.currentFloor = 1;
        this.maxFloors = 6;
        // 6å±‚åœ°å½¢åç§°
        this.floorNames = ['èŒä¸åŒº', 'å­µåŒ–æ¸©å®¤', 'ç¥ç»ç´¢', 'æ¶ˆåŒ–ç†”ç‚‰', 'æ¯è™«åº­é™¢', 'åƒæ ¹ä¹‹å¿ƒ'];
        this.allFloors = new Map();
        
        // å…ˆåˆå§‹åŒ–ç›¸æœºè§†é‡ï¼Œç¡®ä¿æˆ¿é—´å°ºå¯¸æ­£ç¡®
        this.camera.updateViewport();
        
        // ç­‰å¾…ä¸€å¸§ç¡®ä¿ canvas å°ºå¯¸æ­£ç¡®
        setTimeout(() => {
            this.camera.updateViewport();
            // é‡æ–°ç”Ÿæˆåœ°å›¾ä»¥ä½¿ç”¨æ­£ç¡®çš„æˆ¿é—´å°ºå¯¸
            this.regenerateMap();
        }, 0);
        
        // ä¸´æ—¶åœ°å›¾ï¼ˆä¼šè¢«æ›¿æ¢ï¼‰
        const gen = new MapGenerator();
        const map = gen.generate(1);
        this.curRoom = map.start;
        this.allRooms = map.rooms;
        this.curRoom.visited = true;
        this.allFloors.set(1, { start: map.start, rooms: map.rooms });
        
        this.keys = {};
        this.transition = { active: false, timer: 0, dir: null, target: null };
        this.rafId = null;
        this.godMode = false;
        
        this.shopOpen = false;
        this.shopItems = [];
        this.shopSelected = -1;
        
        this.levelUpOpen = false; // 4é€‰1å‡çº§é€‰æ‹©ç•Œé¢ï¼ˆ2æ­¦å™¨+2è¢«åŠ¨ï¼‰
        this.levelUpOptions = [];
        
        this.sounds = new SoundManager();
        
        // æ—¶é—´ç¼©æ”¾ï¼ˆæ¸¸æˆé€Ÿåº¦ï¼‰
        this.timeScale = 1;
        
        // æš‚åœçŠ¶æ€
        this.paused = false;
        
        this.setupInput();
        
        // æš´éœ²åˆ°å…¨å±€ä¾›æŒ‰é’®è°ƒç”¨
        window.game = this;
    }
    
    setSpeed(speed) {
        if (speed <= 0) {
            console.warn(`[Game] éæ³•é€Ÿåº¦: ${speed}, ä½¿ç”¨1x`);
            speed = 1;
        }
        this.timeScale = speed;
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.speed) === speed);
        });
        console.log(`âš¡ æ¸¸æˆé€Ÿåº¦è®¾ç½®ä¸º ${speed}x`);
    }
    
    // åˆ‡æ¢æ— æ•Œæ¨¡å¼ï¼ˆæµ‹è¯•ç”¨ï¼‰
    toggleGodMode() {
        this.godMode = !this.godMode;
        const btn = document.getElementById('godModeBtn');
        const status = document.getElementById('godModeStatus');
        if (btn && status) {
            btn.classList.toggle('active', this.godMode);
            status.textContent = this.godMode ? 'ON' : 'OFF';
            status.style.color = this.godMode ? '#4f4' : '#888';
        }
        console.log(`ğŸ›¡ï¸ æ— æ•Œæ¨¡å¼: ${this.godMode ? 'å¼€å¯' : 'å…³é—­'}`);
    }
    
    // åˆ‡æ¢ä¸»é¢˜
    toggleTheme() {
        const html = document.documentElement;
        const currentTheme = html.getAttribute('data-theme') || 'dark';
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        html.setAttribute('data-theme', newTheme);
        localStorage.setItem('gameTheme', newTheme);
        console.log(`ğŸ¨ ä¸»é¢˜åˆ‡æ¢: ${newTheme}`);
        return newTheme;
    }
    
    // åŠ è½½ä¿å­˜çš„ä¸»é¢˜
    loadTheme() {
        const savedTheme = localStorage.getItem('gameTheme') || 'dark';
        document.documentElement.setAttribute('data-theme', savedTheme);
    }
    
    // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
    updateScoreDisplay() {
        const sm = this.scoreManager;
        if (!sm.isPlaying) return;
        
        // é¡¶éƒ¨ä¸­å¤®åˆ†æ•°
        const scoreValue = document.getElementById('scoreValue');
        if (scoreValue) scoreValue.textContent = sm.formatScore();
        
        // è¿æ€æ˜¾ç¤º
        const streakEl = document.getElementById('killStreak');
        if (streakEl) {
            if (sm.killStreak >= 3) {
                streakEl.style.display = 'block';
                document.getElementById('streakCount').textContent = sm.killStreak;
            } else {
                streakEl.style.display = 'none';
            }
        }
    }
    
    // ç»“æŸæ¸¸æˆå¹¶è®¡ç®—åˆ†æ•°
    endGame(result) {
        // é‡å¯æœŸé—´ç¦æ­¢è°ƒç”¨ endGame
        if (this.isRestarting) {
            console.log('âš¡ endGame è¢«é˜»æ­¢ï¼šæ­£åœ¨é‡å¯ä¸­');
            return;
        }
        const scoreData = this.scoreManager.end(result);
        console.log('ğŸ† æ¸¸æˆç»“æŸï¼åˆ†æ•°ç»Ÿè®¡ï¼š', scoreData);
        this.gameResult = result;
        this.gameResultData = scoreData;
        this.showResultScreen = true;
        return scoreData;
    }
    
    // è¿”å›ä¸»èœå•ï¼ˆé‡æ–°å¼€å§‹ï¼‰
    returnToMainMenu() {
        // ç«‹å³åœæ­¢æ¸¸æˆå¾ªç¯
        this.paused = true;
        
        // è®¾ç½®é‡å¯æ ‡å¿—ï¼Œé˜²æ­¢åœ¨æ­¤æœŸé—´è§¦å‘endGame
        this.isRestarting = true;
        
        // å¼€å¯æ— æ•Œæ¨¡å¼ï¼Œé˜²æ­¢é‡å¯æœŸé—´å—åˆ°ä¼¤å®³
        this.godMode = true;
        
        // é‡ç½®æ¸¸æˆçŠ¶æ€
        this.showResultScreen = false;
        this.gameResult = null;
        this.gameResultData = null;
        this.state = 'menu';
        this.scoreManager.isPlaying = false;
        
        // éšè—æ¸¸æˆå¸ƒå±€ï¼Œæ˜¾ç¤ºæ•…äº‹ç•Œé¢
        const mainLayout = document.getElementById('mainLayout');
        mainLayout.classList.remove('active');
        // æ¸…é™¤å¯èƒ½è®¾ç½®çš„å†…è”æ ·å¼ï¼Œé¿å…å½±å“ä¸‹æ¬¡æ˜¾ç¤º
        mainLayout.style.display = '';
        document.getElementById('topScoreBar').style.display = 'none';
        document.getElementById('weaponSelect').style.display = 'none';  // éšè—æ­¦å™¨é€‰æ‹©ç•Œé¢
        document.getElementById('story').style.display = 'block';
        
        // é‡æ–°åˆå§‹åŒ–æ¸¸æˆ
        this.restartGame();
    }
    
    // é‡æ–°å¼€å§‹æ¸¸æˆ
    restartGame() {
        // è®¾ç½®é‡å¯æ ‡å¿—ï¼Œé˜²æ­¢drawUIåœ¨æ­¤æœŸé—´è§¦å‘endGame
        this.isRestarting = true;
        
        // é‡ç½®çŠ¶æ€
        this.state = 'menu';
        this.scoreManager.isPlaying = false;
        
        // é‡ç½®ç©å®¶æ•°æ®
        this.player.hp = this.player.maxHp = 6;
        console.log(`âš¡ HPé‡ç½®ä¸º ${this.player.hp}/${this.player.maxHp}`);
        this.player.exp = 0;
        this.player.lv = 1;
        this.player.gold = 100;
        this.player.facingRight = true;
        this.player.isMoving = false;
        this.player.walkCycle = 0;
        this.player.isDashing = false;
        this.player.dashTime = 0;
        this.player.dashCooldown = 0;
        this.player.dashDirection = {x:0, y:0};
        this.player.dashTrail = [];
        this.player.jumpY = 0;
        
        // é‡ç½®æ¸¸æˆçŠ¶æ€
        this.currentFloor = 1;
        this.weapons = [];  // æ­¦å™¨å°†åœ¨é€‰æ‹©ååˆå§‹åŒ–
        this.passives = new PassiveManager(this.player);
        this.items = new ItemManager(this.player);
        this.totems = new TotemManager();
        this.materials = new MaterialManager();
        this.bullets = [];
        this.particles = new ParticleSystem();
        this.damageNumbers = new DamageNumberSystem();
        this.gems = [];
        this.goldDrops = [];
        
        // é‡ç½®æš‚åœçŠ¶æ€å’Œæ¸¸æˆçŠ¶æ€
        this.paused = false;
        this.state = 'menu'; // å…³é”®ï¼šé‡ç½®çŠ¶æ€ï¼Œé˜²æ­¢drawUIå†æ¬¡è§¦å‘endGame
        
        // é‡ç½®æ¸¸æˆé€Ÿåº¦å’Œæ—¶é—´æˆ³
        this.timeScale = 1;
        this.lastT = null; // é‡ç½®æ—¶é—´æˆ³ï¼Œé˜²æ­¢dtè®¡ç®—é”™è¯¯
        console.log('ğŸ”„ restartGame: çŠ¶æ€é‡ç½®ä¸º menu, timeScale=1, lastT=null');
        try {
            this.setSpeed(1); // æ›´æ–°UIæŒ‰é’®çŠ¶æ€
        } catch (e) {
            console.error('setSpeed å¤±è´¥:', e);
        }
        
        // å…³é—­æ‰€æœ‰ç•Œé¢
        this.shopOpen = false;
        this.levelUpOpen = false;
        this.shopItems = [];
        this.levelUpOptions = [];
        
        // æ³¨æ„ï¼šæ— æ•Œæ¨¡å¼ä¿æŒå¼€å¯ï¼Œç›´åˆ° startGameBtn ç‚¹å‡»å2ç§’æ‰æ¸…é™¤
        // this.godMode = false; // å·²åˆ é™¤ - ç”± startGameBtn å¤„ç†
        const godModeBtn = document.getElementById('godModeBtn');
        const godModeStatus = document.getElementById('godModeStatus');
        if (godModeBtn && godModeStatus) {
            godModeBtn.classList.remove('active');
            godModeStatus.textContent = 'OFF';
            godModeStatus.style.color = '#888';
        }
        
        // é‡ç½®ç›¸æœº
        this.camera.x = SURVIVOR_CONFIG.ROOM_WIDTH / 2;
        this.camera.y = SURVIVOR_CONFIG.ROOM_HEIGHT / 2;
        
        // é‡æ–°ç”Ÿæˆåœ°å›¾
        this.regenerateMap();
        
        // é‡ç½®åˆ†æ•°ç³»ç»Ÿ
        this.scoreManager.start();
        
        // æ³¨æ„ï¼šisRestartingå’ŒgodModeåœ¨startGameæŒ‰é’®ç‚¹å‡»æ—¶æ¸…é™¤
        
        console.log(`âš¡ restartGameå®Œæˆ: HP=${this.player.hp}, state=${this.state}, isPlaying=${this.scoreManager.isPlaying}`);
    }
    
    // åˆå§‹åŒ–é“å…·æ ¼å­
    initItemGrid() {
        const grid = document.getElementById('sidebarItems');
        if (!grid) return;
        grid.innerHTML = '';
        for (let i = 0; i < 20; i++) {
            const slot = document.createElement('div');
            slot.className = 'item-cell';
            slot.id = `sidebarItem${i}`;
            grid.appendChild(slot);
        }
    }
    
    // æ›´æ–°ä¾§è¾¹é¢æ¿
    updateSidePanels() {
        // å·¦ä¾§è¾¹æ  - è§’è‰²çŠ¶æ€
        const hpEl = document.getElementById('sidebarHp');
        if (hpEl) hpEl.textContent = `${this.player.hp}/${this.player.maxHp}`;
        
        const lvEl = document.getElementById('sidebarLv');
        if (lvEl) lvEl.textContent = `Lv.${this.player.lv}`;
        
        const goldEl = document.getElementById('sidebarGold');
        if (goldEl) goldEl.textContent = this.player.gold;
        
        const floorEl = document.getElementById('sidebarFloor');
        if (floorEl) floorEl.textContent = `${this.currentFloor}/${this.maxFloors}`;
        
        // æ­¦å™¨åˆ—è¡¨
        const weaponList = document.getElementById('sidebarWeapons');
        if (weaponList) {
            weaponList.innerHTML = '';
            // å¹¸å­˜è€…æ¨¡å¼ï¼šæ˜¾ç¤ºæ‰€æœ‰å·²è£…å¤‡æ­¦å™¨
            this.weapons.forEach((w) => {
                const div = document.createElement('div');
                div.className = 'weapon-item';
                div.innerHTML = `
                    <span class="weapon-icon">${w.cfg.icon}</span>
                    <span class="weapon-name">${w.cfg.name}</span>
                    <span class="weapon-lv">Lv.${w.level}${w.evolution ? 'â˜…' : ''}</span>
                `;
                weaponList.appendChild(div);
            });
        }
        
        // ææ–™
        const matsEl = document.getElementById('sidebarMaterials');
        if (matsEl) {
            const mats = this.materials.getAll();
            if (mats.length > 0) {
                matsEl.innerHTML = mats.map(m => `${m.icon}${m.count}`).join(' ');
            } else {
                matsEl.textContent = 'æš‚æ— ';
            }
        }
        
        // æˆ˜æ–—å±æ€§
        if (this.items) {
            const stats = this.items.getStats();
            // å¹¸å­˜è€…æ¨¡å¼ï¼šæ˜¾ç¤ºæ‰€æœ‰æ­¦å™¨æ€»DPS
            const dmgEl = document.getElementById('sidebarDmg');
            if (dmgEl && this.weapons.length > 0) {
                // è®¡ç®—æ‰€æœ‰æ­¦å™¨çš„å¹³å‡ä¼¤å®³
                let totalDmg = 0;
                this.weapons.forEach(w => {
                    totalDmg += Math.floor(w.cfg.dmg * (1 + (w.level - 1) * 0.15) * stats.projSize);
                });
                dmgEl.textContent = totalDmg;
            }
            
            // ç§»é€Ÿ
            const speedEl = document.getElementById('sidebarSpeed');
            if (speedEl) {
                const speedPercent = Math.floor(stats.speed * 100);
                speedEl.textContent = speedPercent + '%';
            }
            
            // æ”»é€Ÿ
            const fireRateEl = document.getElementById('sidebarFireRate');
            if (fireRateEl) {
                const fireRatePercent = Math.floor(stats.fireRate * 100);
                fireRateEl.textContent = fireRatePercent + '%';
            }
            
            // æš´å‡»ç‡
            const critEl = document.getElementById('sidebarCrit');
            if (critEl) {
                const critPercent = Math.floor(stats.crit * 100);
                critEl.textContent = critPercent + '%';
            }
            
            // æŠ¤ç”²
            const armorEl = document.getElementById('sidebarArmor');
            if (armorEl) {
                armorEl.textContent = stats.armor;
            }
        }
        
        // å³ä¾§è¾¹æ  - æˆ¿é—´ç±»å‹å’ŒçŠ¶æ€
        const roomTypeEl = document.getElementById('sidebarRoomType');
        if (roomTypeEl) {
            const names = { start: 'èµ·ç‚¹', normal: 'æˆ˜æ–—', boss: 'BOSS', treasure: 'å®ç®±', shop: 'å•†åº—', hidden: 'éšè—' };
            roomTypeEl.textContent = names[this.curRoom.type] || 'æœªçŸ¥';
        }
        
        const roomStatusEl = document.getElementById('sidebarRoomStatus');
        if (roomStatusEl) {
            if (this.curRoom.cleared) {
                roomStatusEl.innerHTML = 'âœ“ <span style="color:#4f4">å·²æ¸…ç†</span>';
            } else {
                roomStatusEl.innerHTML = 'ğŸ”’ <span style="color:#f44">é”å®š</span>';
            }
        }
        
        // åˆ†æ•°
        const scoreEl = document.getElementById('sidebarScore');
        if (scoreEl && this.scoreManager) {
            scoreEl.textContent = this.scoreManager.score;
        }
        
        // å‡»æ€
        const killsEl = document.getElementById('sidebarKills');
        if (killsEl && this.scoreManager) {
            killsEl.textContent = this.scoreManager.stats.enemiesKilled;
        }
        
        // æ¢ç´¢
        const roomsEl = document.getElementById('sidebarRooms');
        if (roomsEl && this.scoreManager) {
            roomsEl.textContent = this.scoreManager.stats.roomsExplored;
        }
        
        // é“å…·æ ¼å­ï¼ˆ20æ ¼ï¼‰- ä»ownedå¯¹è±¡è·å–é“å…·åˆ—è¡¨
        const ownedItems = this.items ? this.items.getOwnedItems() : [];
        for (let i = 0; i < 20; i++) {
            const slot = document.getElementById(`sidebarItem${i}`);
            if (slot) {
                if (ownedItems[i]) {
                    slot.textContent = ownedItems[i].icon;
                    slot.classList.add('filled');
                    slot.title = ownedItems[i].name + (ownedItems[i].count > 1 ? ` x${ownedItems[i].count}` : '');
                } else {
                    slot.textContent = '';
                    slot.classList.remove('filled');
                    slot.title = '';
                }
            }
        }
        
        // å·¦ä¾§è¾¹æ  - è§’è‰²çŠ¶æ€æ›´æ–°
        // 1. ç©å®¶ç”Ÿå‘½å€¼ï¼ˆå¿ƒå½¢ï¼‰
        const heartsEl = document.getElementById('playerHearts');
        if (heartsEl && this.player) {
            const maxHearts = Math.ceil(this.player.maxHp / 2); // æ¯2ç‚¹HPä¸€ä¸ªå¿ƒ
            const currentHearts = Math.floor(this.player.hp / 2);
            const hasHalf = this.player.hp % 2 === 1;
            let heartsStr = '';
            for (let i = 0; i < maxHearts; i++) {
                if (i < currentHearts) {
                    heartsStr += 'â¤ï¸'; // å®å¿ƒ
                } else if (i === currentHearts && hasHalf) {
                    heartsStr += 'ğŸ’”'; // åŠå¿ƒï¼ˆç”¨ç ´ç¢å¿ƒä»£æ›¿ï¼‰
                } else {
                    heartsStr += 'ğŸ–¤'; // ç©ºå¿ƒï¼ˆç”¨é»‘å¿ƒä»£æ›¿ï¼‰
                }
            }
            heartsEl.textContent = heartsStr;
        }
        
        // 2. ç»éªŒæ¡
        const expBar = document.getElementById('expBar');
        const levelDisplay = document.getElementById('levelDisplay');
        const expText = document.getElementById('expText');
        if (expBar && this.player) {
            const expNeeded = this.player.lv * 100;
            const expPercent = (this.player.exp / expNeeded) * 100;
            expBar.style.width = `${expPercent}%`;
            if (levelDisplay) levelDisplay.textContent = this.player.lv;
            if (expText) expText.textContent = `${this.player.exp}/${expNeeded}`;
        }
        
        // é¡¶éƒ¨ä¿¡æ¯æ æ›´æ–°
        // 3. å±‚æ•°â€”â€”åœ°å½¢åç§°
        const floorDisplay = document.getElementById('currentFloorDisplay');
        const floorName = document.getElementById('floorName');
        if (floorDisplay) floorDisplay.textContent = this.currentFloor;
        if (floorName) floorName.textContent = this.floorNames[this.currentFloor - 1] || 'æœªçŸ¥';
        
        // 4. æ³¢æ¬¡ | æ•Œäºº | è¿æ€
        const waveNum = document.getElementById('waveNum');
        const enemyNum = document.getElementById('enemyNum');
        if (waveNum) {
            waveNum.textContent = this.curRoom.hordeManager ? this.curRoom.hordeManager.wave : 0;
        }
        if (enemyNum) {
            const activeCount = this.curRoom.hordeManager ? 
                this.curRoom.hordeManager.getActiveEnemies().length : 
                this.curRoom.enemies.filter(e => e.hp > 0).length;
            enemyNum.textContent = activeCount;
        }
        
        // æ›´æ–°å°åœ°å›¾ï¼ˆä»¥æ’’é£æ ¼ï¼šå·²è®¿é—®=å®å¿ƒï¼Œæœªè®¿é—®=è½®å»“ï¼‰
        this.updateMiniMap();
    }
    
    // å°åœ°å›¾åœ¨å³ä¾§è¾¹æ ä»¥æ’’é£æ ¼ç»˜åˆ¶ (updateMiniMap)
    // å·²è®¿é—®æˆ¿é—´=å®å¿ƒï¼Œæœªè®¿é—®æˆ¿é—´=è½®å»“
    async loadSprites() {
        const basePath = 'https://wearescientist.github.io/rouge-cow/assets/sprites/';  
        const v = '?v=095'; // ç‰ˆæœ¬å·å¼ºåˆ¶åˆ·æ–°ç¼“å­˜
        await this.sprites.load('player', basePath + 'player_cow.png' + v);
        
        // åŠ è½½æ‰€æœ‰22ç§æ•Œäººç²¾çµ
        const allEnemies = [
            'chick', 'mouse', 'snail', 'pigeon', 'duck3',      // Tier 1
            'rabbit', 'rabbit2', 'bird', 'duck2', 'pig2',      // Tier 2
            'cat', 'duck', 'squirrel', 'goose',                // Tier 3
            'dog', 'pig', 'sheep', 'snake',                    // Tier 4
            'bear', 'crab', 'dog2',                            // Tier 5
            'turtle'                                           // Tier 6
        ];
        
        for (const name of allEnemies) {
            await this.sprites.load(name, basePath + name + '.png' + v);
            this.updateLoadingProgress();
        }
    }
    
    updateLoadingProgress() {
        const progress = this.sprites.getProgress() * 100;
        const progressBar = document.getElementById('loadingProgress');
        const loadingText = document.getElementById('loadingText');
        if (progressBar) progressBar.style.width = `${progress}%`;
        if (loadingText) loadingText.textContent = `æ­£åœ¨åŠ è½½... ${Math.floor(progress)}%`;
    }
    
    // é‡æ–°ç”Ÿæˆåœ°å›¾ï¼ˆå½“æˆ¿é—´å°ºå¯¸æ”¹å˜æ—¶è°ƒç”¨ï¼‰
    regenerateMap() {
        const gen = new MapGenerator();
        const map = gen.generate(1);
        this.curRoom = map.start;
        this.allRooms = map.rooms;
        this.curRoom.visited = true;
        this.allFloors.set(1, { start: map.start, rooms: map.rooms });
        
        // é‡æ–°è®¾ç½®ç©å®¶ä½ç½®
        const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
        const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
        this.player.x = roomW / 2;
        this.player.y = roomH / 2;
        this.camera.follow(this.player);
        
        console.log(`ğŸ—ºï¸ åœ°å›¾é‡æ–°ç”Ÿæˆ: ${roomW}x${roomH}`);
    }

    setupInput() {
        window.addEventListener('keydown', e => {
            this.keys[e.key] = true;
            
            // ç»“ç®—ç”»é¢æ“ä½œ
            if (this.showResultScreen) {
                if (e.key === ' ' || e.key === 'Enter' || e.key === 'Escape') {
                    this.returnToMainMenu();
                }
                return;
            }
            
            // ESCæš‚åœ/æ¢å¤ï¼ˆä»…åœ¨æ¸¸æˆä¸­ï¼Œä¸åœ¨å•†åº—/å‡çº§ç•Œé¢ï¼‰
            if (e.key === 'Escape') {
                if (this.state === 'playing' && !this.shopOpen && !this.levelUpOpen) {
                    this.togglePause();
                }
                return;
            }
            
            // å¦‚æœæ¸¸æˆæš‚åœï¼Œä¸å¤„ç†å…¶ä»–æŒ‰é”®
            if (this.paused) return;
            
            // å‡çº§é€‰æ‹©ç•Œé¢æ“ä½œï¼ˆ4é€‰1ï¼‰
            if (this.levelUpOpen) {
                if (e.key >= '1' && e.key <= '4') {
                    this.selectLevelUpOption(parseInt(e.key) - 1);
                }
                return;
            }
            
            // å•†åº—äº¤äº’
            if (e.key === 'e' || e.key === 'E') {
                if (this.shopOpen) {
                    this.closeShop();
                } else if (this.curRoom.type === 'shop' && this.curRoom.npc) {
                    const d = dist(this.player.x, this.player.y, this.curRoom.npc.x, this.curRoom.npc.y);
                    if (d < 80) {
                        this.openShop();
                    }
                }
            }
            
            if (this.shopOpen) {
                if (e.key >= '1' && e.key <= '3') {
                    this.buyItem(parseInt(e.key) - 1);
                }
                return;
            }
            
            if (e.key >= '1' && e.key <= '9') {
                const id = parseInt(e.key);
                if (this.items.add(id)) {
                    this.particles.burst(this.player.x, this.player.y, '#ff0', 15);
                }
            }
            
            if (e.key === 'f' || e.key === 'F') {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }
            
            if (e.key === 'g' || e.key === 'G') {
                this.toggleGodMode();
            }
            
            // é€Ÿåº¦è°ƒæ•´å¿«æ·é”® -/+ (æˆ– =)
            if (e.key === '-' || e.key === '_') {
                const speeds = [1, 2, 5, 10];
                const currentIdx = speeds.indexOf(this.timeScale);
                const newIdx = Math.max(0, currentIdx - 1);
                this.setSpeed(speeds[newIdx]);
            }
            if (e.key === '=' || e.key === '+' || e.key === '0') {
                const speeds = [1, 2, 5, 10];
                const currentIdx = speeds.indexOf(this.timeScale);
                const newIdx = Math.min(speeds.length - 1, currentIdx + 1);
                this.setSpeed(speeds[newIdx]);
            }
            
            // å­˜æ¡£åŠŸèƒ½å¿«æ·é”®ï¼ˆç¬¬5æ¬¡è¿­ä»£ï¼‰
            if (e.key === 'l' || e.key === 'L') {
                if (this.hasSave()) {
                    this.loadGame();
                    this.particles.burst(this.player.x, this.player.y, '#48f', 20);
                    console.log('ğŸ“‚ å·²åŠ è½½å­˜æ¡£');
                } else {
                    console.log('âŒ æ— å­˜æ¡£å¯åŠ è½½');
                }
            }
            if (e.key === 'k' || e.key === 'K') {
                this.saveGame();
                this.particles.burst(this.player.x, this.player.y, '#4f4', 20);
                console.log('ğŸ’¾ å·²æ‰‹åŠ¨å­˜æ¡£');
            }
        });
        
        window.addEventListener('keyup', e => this.keys[e.key] = false);
        
        // é¼ æ ‡ç‚¹å‡»æ”¯æŒ
        const canvas = document.getElementById('gameCanvas');
        if (canvas) {
            canvas.addEventListener('mousedown', e => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                this.mouseX = (e.clientX - rect.left) * scaleX;
                this.mouseY = (e.clientY - rect.top) * scaleY;
                this.mouseDown = true;
                this.handleClick(this.mouseX, this.mouseY);
            });
            
            canvas.addEventListener('mouseup', () => {
                this.mouseDown = false;
            });
            
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                this.mouseX = (e.clientX - rect.left) * scaleX;
                this.mouseY = (e.clientY - rect.top) * scaleY;
            });
            
            // è§¦æ‘¸æ§åˆ¶æ”¯æŒï¼ˆç§»åŠ¨è®¾å¤‡ï¼‰
            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                this.mouseX = (touch.clientX - rect.left) * scaleX;
                this.mouseY = (touch.clientY - rect.top) * scaleY;
                this.mouseDown = true;
                this.handleClick(this.mouseX, this.mouseY);
            }, { passive: false });
            
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                this.mouseX = (touch.clientX - rect.left) * scaleX;
                this.mouseY = (touch.clientY - rect.top) * scaleY;
            }, { passive: false });
            
            canvas.addEventListener('touchend', e => {
                e.preventDefault();
                this.mouseDown = false;
            }, { passive: false });
            
        }
    }
    
    // å¤„ç†ç‚¹å‡»äº‹ä»¶
    handleClick(x, y) {
        // ç»“ç®—ç”»é¢ç‚¹å‡»å¤„ç†
        if (this.showResultScreen) {
            // ä½¿ç”¨ä¿å­˜çš„æŒ‰é’®åæ ‡è¿›è¡Œæ£€æµ‹
            const btn = this.resultBtnRect;
            if (btn && x > btn.x && x < btn.x + btn.w && y > btn.y && y < btn.y + btn.h) {
                this.returnToMainMenu();
            }
            return;
        }
        
        // å‡çº§é€‰æ‹©ç•Œé¢ç‚¹å‡»å¤„ç†ï¼ˆ4é€‰1ï¼‰
        if (this.levelUpOpen) {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) return;
            const cw = canvas.width;
            const ch = canvas.height;
            
            // è®¡ç®—å››ä¸ªé€‰é¡¹çš„ä½ç½®ï¼ˆ2x2ç½‘æ ¼ï¼‰
            const boxWidth = 560;
            const boxHeight = 400;
            const boxX = (cw - boxWidth) / 2;
            const boxY = (ch - boxHeight) / 2;
            const cardWidth = 240;
            const cardHeight = 150;
            const gapX = 40;
            const gapY = 30;
            const startX = boxX + (boxWidth - 2 * cardWidth - gapX) / 2 + cardWidth / 2;
            const startY = boxY + 100 + cardHeight / 2;
            
            for (let i = 0; i < 4; i++) {
                const row = Math.floor(i / 2);
                const col = i % 2;
                const cx = startX + col * (cardWidth + gapX);
                const cy = startY + row * (cardHeight + gapY);
                if (x > cx - cardWidth/2 && x < cx + cardWidth/2 &&
                    y > cy - cardHeight/2 && y < cy + cardHeight/2) {
                    this.selectLevelUpOption(i);
                    return;
                }
            }
            return;
        }
        
        // å•†åº—ç•Œé¢ç‚¹å‡»å¤„ç†
        if (this.shopOpen) {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) return;
            const cw = canvas.width || 900;
            const ch = canvas.height || 600;
            const centerX = cw / 2;
            const centerY = ch / 2;
            
            // ä¸ drawShopUI å®Œå…¨ä¸€è‡´çš„åæ ‡
            const boxWidth = 500;
            const boxHeight = 350;
            const boxX = centerX - boxWidth / 2;
            const boxY = centerY - boxHeight / 2;
            const itemWidth = 130;
            const itemHeight = 160;
            const startX = centerX - (this.shopItems.length * itemWidth) / 2 + itemWidth / 2;
            const itemY = boxY + 160;
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨å…³é—­åŒºåŸŸï¼ˆç‚¹å‡»èƒŒæ™¯å…³é—­ï¼‰
            if (x < boxX || x > boxX + boxWidth || y < boxY || y > boxY + boxHeight) {
                this.closeShop();
                return;
            }
            
            for (let i = 0; i < this.shopItems.length; i++) {
                const ix = startX + i * (itemWidth + 20);
                if (x > ix - itemWidth/2 && x < ix + itemWidth/2 &&
                    y > itemY - itemHeight/2 && y < itemY + itemHeight/2) {
                    this.buyItem(i);
                    return;
                }
            }
            return;
        }
    }
    
    // å¸è¡€é¬¼å¹¸å­˜è€…é£æ ¼ï¼š4é€‰1å‡çº§é€‰æ‹©ç•Œé¢ï¼ˆ2æ­¦å™¨+2è¢«åŠ¨ï¼‰
    openLevelUpSelect() {
        this.levelUpOpen = true;
        this.levelUpOptions = [];
        
        // å‡çº§ç‰¹æ•ˆ
        this.particles.explosion(this.player.x, this.player.y, '#ff0', 40);
        this.particles.sparkle(this.player.x, this.player.y, '#fff', 15);
        
        // ç”Ÿæˆ2ä¸ªæ­¦å™¨é€‰é¡¹
        const availableWeapons = Object.keys(WEAPONS).filter(key => {
            const existing = this.weapons.find(w => w.baseKey === key && !w.isSuper);
            // æœªæ»¡çº§çš„æ­¦å™¨æˆ–æ–°æ­¦å™¨
            return !existing || existing.canLevelUp();
        });
        
        for (let i = 0; i < 2 && availableWeapons.length > 0; i++) {
            const idx = Math.floor(Math.random() * availableWeapons.length);
            const key = availableWeapons.splice(idx, 1)[0];
            const existing = this.weapons.find(w => w.baseKey === key);
            
            this.levelUpOptions.push({
                type: 'weapon',
                key: key,
                isNew: !existing,
                level: existing ? existing.level + 1 : 1,
                maxLevel: WEAPONS[key].maxLevel,
                data: WEAPONS[key]
            });
        }
        
        // ç”Ÿæˆ2ä¸ªè¢«åŠ¨é€‰é¡¹
        const availablePassives = Object.keys(PASSIVES).filter(key => {
            const level = this.passives.getLevel(key);
            const maxLevel = PASSIVES[key].maxLevel;
            return level < maxLevel; // æœªæ»¡çº§çš„è¢«åŠ¨
        });
        
        for (let i = 0; i < 2 && availablePassives.length > 0; i++) {
            const idx = Math.floor(Math.random() * availablePassives.length);
            const key = availablePassives.splice(idx, 1)[0];
            const currentLevel = this.passives.getLevel(key);
            
            this.levelUpOptions.push({
                type: 'passive',
                key: key,
                level: currentLevel + 1,
                maxLevel: PASSIVES[key].maxLevel,
                data: PASSIVES[key]
            });
        }
        
        console.log('å‡çº§é€‰æ‹©ç•Œé¢å·²æ‰“å¼€', this.levelUpOptions);
    }
    
    closeLevelUpSelect() {
        this.levelUpOpen = false;
        this.levelUpOptions = [];
    }
    
    selectLevelUpOption(index) {
        if (index >= this.levelUpOptions.length) return;
        const option = this.levelUpOptions[index];
        
        if (option.type === 'weapon') {
            const existingIdx = this.weapons.findIndex(w => w.baseKey === option.key && !w.isSuper);
            if (existingIdx >= 0) {
                // å‡çº§ç°æœ‰æ­¦å™¨
                const weapon = this.weapons[existingIdx];
                if (weapon.canLevelUp()) {
                    weapon.level++;
                    this.particles.burst(this.player.x, this.player.y, '#f0f', 20);
                    console.log(`æ­¦å™¨å‡çº§: ${option.data.name} Lv.${weapon.level}`);
                    
                    // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›åŒ–æˆè¶…æ­¦
                    this.checkWeaponEvolution(existingIdx);
                }
            } else if (this.weapons.length < 6) {
                // æ·»åŠ æ–°æ­¦å™¨
                this.weapons.push(new Weapon(option.key, 1));
                this.particles.burst(this.player.x, this.player.y, '#4f4', 15);
                console.log(`è·å¾—æ–°æ­¦å™¨: ${option.data.name}`);
            }
        } else if (option.type === 'passive') {
            // æ·»åŠ æˆ–å‡çº§è¢«åŠ¨
            const isNew = this.passives.getLevel(option.key) === 0;
            this.passives.add(option.key);
            this.particles.burst(this.player.x, this.player.y, '#48f', 15);
            console.log(`${isNew ? 'è·å¾—' : 'å‡çº§'}è¢«åŠ¨: ${option.data.name} Lv.${option.level}`);
        }
        
        this.closeLevelUpSelect();
    }
    
    // æ£€æŸ¥æ­¦å™¨æ˜¯å¦å¯ä»¥è¿›åŒ–æˆè¶…æ­¦
    checkWeaponEvolution(weaponIdx) {
        const weapon = this.weapons[weaponIdx];
        if (!weapon || weapon.isSuper) return;
        if (weapon.level < weapon.maxLevel) return; // å¿…é¡»æ»¡çº§
        
        const evo = this.passives.checkEvolution(weapon.baseKey);
        if (!evo) return;
        
        // å¯ä»¥è¿›åŒ–ï¼
        console.log(`æ­¦å™¨${weapon.cfg.name}å¯ä»¥è¿›åŒ–æˆ${evo.name}ï¼`);
        
        // è¿›åŒ–æ­¦å™¨
        weapon.evolveToSuper(evo.result);
        this.particles.burst(this.player.x, this.player.y, '#f0f', 50);
        this.sounds.play('evolve');
        console.log(`âœ¨ æ­¦å™¨è¿›åŒ–: ${evo.name}ï¼`);
    }
    
    openShop() {
        if (this.shopItems.length === 0) {
            const itemIds = Object.keys(ITEMS).map(Number);
            const selected = [];
            while (selected.length < 3 && itemIds.length > 0) {
                const idx = Math.floor(Math.random() * itemIds.length);
                const itemId = itemIds.splice(idx, 1)[0];
                const item = ITEMS[itemId];
                if (item) {
                    selected.push({
                        id: itemId,
                        icon: item.icon,
                        name: item.name,
                        desc: item.desc,
                        price: getItemPrice(itemId),
                        rarity: item.rarity
                    });
                }
            }
            this.shopItems = selected;
        }
        this.shopOpen = true;
        console.log('å•†åº—å·²æ‰“å¼€');
    }
    
    closeShop() {
        this.shopOpen = false;
        this.shopSelected = -1;
        console.log('å•†åº—å·²å…³é—­');
    }
    
    // å…³é—­å½“å‰æˆ¿é—´æ‰€æœ‰é—¨ï¼ˆè¿›å…¥åˆ·æ€ªæˆ¿é—´æ—¶è°ƒç”¨ï¼‰
    closeAllDoors() {
        for (const door of Object.values(this.curRoom.doors)) {
            if (door) {
                door.open = false;
                door.locked = true;
            }
        }
        console.log('ğŸšª é—¨å·²å…³é—­ï¼Œæ¸…ç†æˆ¿é—´ä»¥å¼€å¯');
    }
    
    // æ‰“å¼€å½“å‰æˆ¿é—´æ‰€æœ‰é—¨ï¼ˆæ¸…ç†å®Œæˆåè°ƒç”¨ï¼‰
    openAllDoors() {
        for (const door of Object.values(this.curRoom.doors)) {
            if (door) {
                door.open = true;
                door.locked = false;
            }
        }
        console.log('ğŸšª é—¨å·²å¼€å¯');
    }
    
    // æˆ¿é—´æ¸…ç†å®Œæˆåè‡ªåŠ¨æ‹¾å–æ‰€æœ‰ç»éªŒçƒ
    autoCollectAllGems() {
        if (this.gems.length === 0) return;
        
        let totalExp = 0;
        const expBonus = this.passives ? this.passives.getStats().expBonus : 0;
        
        // è®¡ç®—æ‰€æœ‰ç»éªŒå€¼
        for (const g of this.gems) {
            totalExp += Math.floor(g.v * (1 + expBonus));
        }
        
        // æ¸…ç©ºæ‰€æœ‰ç»éªŒçƒ
        this.gems = [];
        
        // ä¸€æ¬¡æ€§æ·»åŠ ç»éªŒ
        this.player.exp += totalExp;
        
        // æ˜¾ç¤ºç»éªŒé£˜å­—æ•ˆæœ
        this.particles.burst(this.player.x, this.player.y, '#48f', 15);
        
        console.log(`âœ¨ è‡ªåŠ¨æ‹¾å–ç»éªŒ: +${totalExp}`);
        
        // æ£€æŸ¥å‡çº§ï¼ˆå¯èƒ½è¿ç»­å‡å¤šçº§ï¼‰
        while (this.player.exp >= this.player.lv * 100) {
            this.player.exp -= this.player.lv * 100;
            this.player.lv++;
            this.sounds.play('levelup');
            this.particles.burst(this.player.x, this.player.y, '#ff0', 20);
            // æ‰“å¼€4é€‰1å‡çº§ç•Œé¢
            this.openLevelUpSelect();
            // å‡çº§ç•Œé¢æ‰“å¼€åé€€å‡ºå¾ªç¯ï¼Œç­‰å‡çº§å®Œæˆåå†æ£€æŸ¥
            break;
        }
    }
    
    buyItem(index) {
        if (index < 0 || index >= this.shopItems.length) return;
        const item = this.shopItems[index];
        if (this.player.gold >= item.price) {
            this.player.gold -= item.price;
            this.items.add(item.id);
            this.particles.burst(this.player.x, this.player.y, '#ff0', 20);
            this.sounds.play('buy');
            this.shopItems.splice(index, 1);
            console.log(`è´­ä¹°æˆåŠŸ: ${item.name}`);
        } else {
            console.log('é‡‘å¸ä¸è¶³');
        }
    }

    async start() {
        // åŠ è½½ä¿å­˜çš„ä¸»é¢˜
        this.loadTheme();
        
        await this.loadSprites();
        this.sounds.init();
        document.getElementById('loading').classList.add('hidden');
        
        // çª—å£å¤§å°å˜åŒ–æ—¶æ›´æ–°ç›¸æœºè§†é‡
        window.addEventListener('resize', () => {
            if (this.camera) {
                this.camera.updateViewport();
            }
        });
        
        document.getElementById('story').style.display = 'block';
        document.getElementById('startGameBtn').addEventListener('click', () => {
            // éšè—æ•…äº‹ç•Œé¢ï¼Œæ˜¾ç¤ºæ­¦å™¨é€‰æ‹©
            document.getElementById('story').style.display = 'none';
            this.showWeaponSelect();
        });
    }
    
    // æ˜¾ç¤ºæ­¦å™¨é€‰æ‹©ç•Œé¢
    showWeaponSelect() {
        console.log('ğŸ¯ æ˜¾ç¤ºæ­¦å™¨é€‰æ‹©ç•Œé¢...');
        const weaponSelect = document.getElementById('weaponSelect');
        const weaponOptions = document.getElementById('weaponOptions');
        console.log(`   weaponSelect=${weaponSelect}, weaponOptions=${weaponOptions}`);
        
        // å®šä¹‰å¯é€‰æ­¦å™¨ï¼ˆ3æŠŠåˆå§‹æ­¦å™¨ï¼‰
        const starterWeapons = [
            { key: 'wand', name: 'é­”æ–', icon: 'ğŸ”®', desc: 'å¹³è¡¡å‹è¿œç¨‹æ­¦å™¨ï¼Œå°„é€Ÿä¸­ç­‰', color: '#48f' },
            { key: 'knife', name: 'é£åˆ€', icon: 'ğŸ—¡ï¸', desc: 'å¿«é€Ÿè¿å°„ï¼Œå¯ç©¿é€æ•Œäºº', color: '#ccc' },
            { key: 'garlic', name: 'å¤§è’œ', icon: 'ğŸ§„', desc: 'è¿‘è·ç¦»èŒƒå›´ä¼¤å®³ï¼Œé«˜å°„é€Ÿ', color: '#4a4' }
        ];
        
        // ç”Ÿæˆæ­¦å™¨é€‰é¡¹HTML
        weaponOptions.innerHTML = starterWeapons.map(w => `
            <div class="weapon-option" data-weapon="${w.key}" style="
                width: 250px; 
                padding: 30px; 
                background: rgba(255,255,255,0.05); 
                border: 2px solid #333; 
                border-radius: 12px; 
                cursor: pointer; 
                transition: all 0.3s;
                text-align: center;
            " onmouseover="this.style.borderColor='${w.color}'; this.style.background='rgba(255,255,255,0.1)';" 
               onmouseout="this.style.borderColor='#333'; this.style.background='rgba(255,255,255,0.05)';">
                <div style="font-size: 64px; margin-bottom: 15px;">${w.icon}</div>
                <div style="font-size: 24px; color: ${w.color}; font-weight: bold; margin-bottom: 10px;">${w.name}</div>
                <div style="font-size: 14px; color: #888; line-height: 1.5;">${w.desc}</div>
            </div>
        `).join('');
        
        // æ˜¾ç¤ºé€‰æ‹©ç•Œé¢
        weaponSelect.style.display = 'block';
        
        // ç»‘å®šé€‰æ‹©äº‹ä»¶
        console.log('ğŸ”« ç»‘å®šæ­¦å™¨é€‰æ‹©äº‹ä»¶...');
        weaponOptions.querySelectorAll('.weapon-option').forEach(el => {
            el.addEventListener('click', (e) => {
                const weaponKey = el.dataset.weapon;
                console.log(`ğŸ”« ç‚¹å‡»æ­¦å™¨: ${weaponKey}`);
                this.selectWeapon(weaponKey);
            });
        });
        console.log('ğŸ”« æ­¦å™¨é€‰æ‹©ç•Œé¢å‡†å¤‡å®Œæˆ');
    }
    
    // é€‰æ‹©æ­¦å™¨å¹¶å¼€å§‹æ¸¸æˆ
    selectWeapon(weaponKey) {
        // å…¨å±€æ¸¸æˆå±€æ•°è®¡æ•°ï¼ˆç”¨äºè°ƒè¯•ï¼‰
        window.gameSessionCount = (window.gameSessionCount || 0) + 1;
        console.log(`\n========== ç¬¬ ${window.gameSessionCount} å±€æ¸¸æˆå¼€å§‹ [v2-fix] ==========`);
        console.log(`[å¼€å±€çŠ¶æ€] roomType=${this.curRoom?.type}, enemies=${this.curRoom?.enemies?.length}, cleared=${this.curRoom?.cleared}`);
        
        // åˆå§‹åŒ–æ­¦å™¨
        this.weapons = [new Weapon(weaponKey, 1)];
        // å¼ºåˆ¶é‡ç½®æ­¦å™¨CDï¼Œç¡®ä¿å¯ä»¥ç«‹å³æ”»å‡»
        this.weapons[0].cd = 0;
        console.log(`âš”ï¸ é€‰æ‹©äº†æ­¦å™¨: ${weaponKey}, cd=${this.weapons[0].cd}`);
        
        // åˆå§‹æˆ¿é—´(start)ä¸ç”Ÿæˆæ•Œäººï¼Œç©å®¶éœ€è¦ç§»åŠ¨åˆ°å…¶ä»–æˆ¿é—´æˆ˜æ–—
        
        // éšè—æ­¦å™¨é€‰æ‹©ç•Œé¢
        document.getElementById('weaponSelect').style.display = 'none';
        
        // æ˜¾ç¤ºæ¸¸æˆå¸ƒå±€ï¼ˆä½†æ¸¸æˆé€»è¾‘è¿˜æœªå¼€å§‹ï¼‰
        document.getElementById('mainLayout').classList.add('active');
        document.getElementById('topScoreBar').style.display = 'block';
        
        // å»¶è¿Ÿæ¸…é™¤é‡å¯æ ‡å¿—ï¼Œè§£é™¤åæ¸¸æˆæ‰çœŸæ­£å¼€å§‹
        setTimeout(() => {
            this.isRestarting = false;
            this.godMode = false;
            this.paused = false;
            this.state = 'playing';
            console.log('âš¡ é‡å¯ä¿æŠ¤è§£é™¤ï¼Œæ¸¸æˆæ­£å¸¸è¿›è¡Œ');
        }, 3000);
        
        // åˆå§‹åŒ–ç›¸æœºè§†é‡
        this.camera.updateViewport();
        
        // åˆå§‹åŒ–é“å…·æ ¼å­
        this.initItemGrid();
        
        // å¯åŠ¨åˆ†æ•°ç³»ç»Ÿ
        this.scoreManager.start();
        this.updateScoreDisplay();
        this.loop(0);
    }
    
    // åˆ‡æ¢æš‚åœçŠ¶æ€
    togglePause() {
        this.paused = !this.paused;
        console.log(this.paused ? 'â¸ï¸ æ¸¸æˆå·²æš‚åœ' : 'â–¶ï¸ æ¸¸æˆå·²æ¢å¤');
    }
    
    // ç»˜åˆ¶æš‚åœç•Œé¢
    drawPauseScreen() {
        const ctx = this.ctx;
        const canvas = ctx.canvas;
        const cw = canvas.width || 900;
        const ch = canvas.height || 600;
        
        // åŠé€æ˜é»‘è‰²é®ç½©
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillRect(0, 0, cw, ch);
        
        // æš‚åœæ–‡å­—
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 56px Arial';
        ctx.fillText('â¸ï¸ å·²æš‚åœ', cw / 2, ch / 2 - 30);
        
        // æç¤ºæ–‡å­—
        ctx.fillStyle = '#aaa';
        ctx.font = '20px Arial';
        ctx.fillText('æŒ‰ ESC é”®æ¢å¤æ¸¸æˆ', cw / 2, ch / 2 + 30);
    }

    update(dt) {
        // è°ƒè¯•ï¼šç¡®è®¤updateè¢«è°ƒç”¨ï¼ˆæ¯60å¸§è¾“å‡ºä¸€æ¬¡ï¼‰
        this._updateDebugFrame = (this._updateDebugFrame || 0) + 1;
        if (this._updateDebugFrame % 60 === 0) {
            const wInfo = this.weapons && this.weapons.length > 0 ? `${this.weapons[0].cfg.name},cd=${this.weapons[0].cd.toFixed(2)}` : 'æ— æ­¦å™¨';
            console.log(`[update#${this._updateDebugFrame}] state=${this.state}, paused=${this.paused}, godMode=${this.godMode}, ${wInfo}`);
        }
        
        if (this.shopOpen || this.levelUpOpen || this.paused) return;
        
        // æ›´æ–°æˆ¿é—´ï¼ˆæ³¢æ¬¡ç³»ç»Ÿï¼‰
        this.curRoom.update(dt);
        
        if (this.transition.active) {
            this.transition.timer -= dt;
            if (this.transition.timer <= 0) {
                this.curRoom = this.transition.target;
                this.curRoom.visited = true;
                // åˆ†æ•°ï¼šè¿›å…¥æ–°æˆ¿é—´
                this.scoreManager.onEnterRoom();
                const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
                const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
                const wallT = 60;
                // ä¼ é€ä½ç½®ï¼šè¿œç¦»é—¨åŒºåŸŸï¼Œå¾€æˆ¿é—´ä¸­å¿ƒç§»åŠ¨ 150px
                const spawnOffset = 150;
                if (this.transition.dir === 'left') this.player.x = roomW - wallT - spawnOffset;
                else if (this.transition.dir === 'right') this.player.x = wallT + spawnOffset;
                else this.player.x = roomW / 2;
                
                if (this.transition.dir === 'up') this.player.y = roomH - wallT - spawnOffset;
                else if (this.transition.dir === 'down') this.player.y = wallT + spawnOffset;
                else this.player.y = roomH / 2;
                
                this.transition.active = false;
                
                // å¦‚æœæ˜¯é¦–æ¬¡è¿›å…¥æˆ¿é—´ï¼Œç”Ÿæˆæ•Œäººï¼ˆåŒ…æ‹¬Bossï¼‰
                if (!this.curRoom.cleared && this.curRoom.enemies.length === 0) {
                    this.curRoom.spawnEnemies();
                    // æ’­æ”¾å¯¹åº”æˆ¿é—´ç±»å‹çš„éŸ³æ•ˆ
                    if (this.curRoom.type === 'boss') {
                        this.sounds.play('boss');
                    } else if (this.curRoom.type === 'hidden') {
                        this.sounds.play('elite');
                    }
                }
                
                // å¦‚æœæˆ¿é—´ä¼šåˆ·æ€ªä¸”æœªæ¸…ç†ï¼Œå…³é—­æ‰€æœ‰é—¨ï¼ˆå°é”æˆ¿é—´ç›´åˆ°æ¸…æ€ªå®Œæˆï¼‰
                if (!this.curRoom.cleared && this.curRoom.hordeManager) {
                    this.closeAllDoors();
                }
                
                // è‡ªåŠ¨å­˜æ¡£ï¼ˆè¿›å…¥æ–°æˆ¿é—´æ—¶ï¼‰
                this.saveGame();
            }
            return;
        }

        // åˆå¹¶æ‰€æœ‰å±æ€§æ¥æºï¼šé“å…· + è¢«åŠ¨ + å›¾è…¾
        const itemStats = this.items.getStats();
        const passiveStats = this.passives.getStats();
        const totemBonuses = this.totems.getAllBonuses();
        
        // è®¡ç®— fireRateï¼Œé˜²æ­¢é™¤ä»¥é›¶æˆ–æ— æ•ˆå€¼
        const cooldown = passiveStats.cooldown || 1;
        const fireRate = Math.max(0.5, (itemStats.fireRate || 1) * (1 / cooldown));  // æœ€å°å€¼0.5ï¼Œé˜²æ­¢fireRateè¿‡å°å¯¼è‡´CDè¿‡å¤§
        
        const stats = {
            // åŸºç¡€å±æ€§ï¼ˆé“å…·+è¢«åŠ¨åˆå¹¶ï¼‰
            projCount: (itemStats.projCount || 1) + (passiveStats.projCount || 0),
            projSize: itemStats.projSize || 1,
            fireRate: isFinite(fireRate) ? fireRate : 1, // é˜²æ­¢ Infinity
            pierce: itemStats.pierce || 0,
            crit: Math.min(1, (itemStats.crit || 0) + (totemBonuses.crit || 0) + ((passiveStats.luck || 0) * 0.5)), // å¹¸è¿è½¬åŒ–ä¸ºæš´å‡»
            critDmg: itemStats.critDmg || 1.5,
            maxHp: itemStats.maxHp || 0,
            armor: (itemStats.armor || 0) + (passiveStats.armor || 0),
            lifeSteal: itemStats.lifeSteal || 0,
            speed: ((itemStats.speed || 1) + (passiveStats.speed || 0)) * (1 + (totemBonuses.speed || 0)), // ç¿…è†€+å›¾è…¾
            fly: itemStats.fly || false,
            magnet: (itemStats.magnet || 100) + (passiveStats.magnet || 0),
            goldBonus: itemStats.goldBonus || 1,
            // ä¼¤å®³ç±»å‹
            fireDmg: itemStats.fireDmg || 0,
            thunderDmg: itemStats.thunderDmg || 0,
            poisonDmg: itemStats.poisonDmg || 0,
            curseDmg: itemStats.curseDmg || 0,
            // æ§åˆ¶æ•ˆæœ
            slowChance: itemStats.slowChance || 0,
            slowAmount: itemStats.slowAmount || 0,
            stunChance: itemStats.stunChance || 0,
            // å…¶ä»–
            dmg: (itemStats.dmg || 1) * (passiveStats.dmg || 1) * (1 + (totemBonuses.dmg || 0)) // è èœ+å›¾è…¾
        };
        
        const speed = 300 * stats.speed;  // ç§»é€Ÿç¿»å€
        
        // å†²åˆºå†·å´æ›´æ–°
        if (this.player.dashCooldown > 0) this.player.dashCooldown -= dt;
        
        // å†²åˆºå¤„ç†
        if (this.player.isDashing) {
            this.player.dashTime -= dt;
            if (this.player.dashTime <= 0) {
                this.player.isDashing = false;
                this.player.jumpY = 0;
            } else {
                // å†²åˆºä¸­ - å¿«é€Ÿç§»åŠ¨
                const dashSpeed = 400;
                this.player.x += this.player.dashDirection.x * dashSpeed * dt;
                this.player.y += this.player.dashDirection.y * dashSpeed * dt;
                // è·³è·ƒå¼§çº¿
                const progress = 1 - (this.player.dashTime / 0.15);
                this.player.jumpY = -Math.sin(progress * Math.PI) * 12;
                // æ·»åŠ æ®‹å½±
                if (Math.random() < 0.5) {
                    this.player.dashTrail.push({x: this.player.x, y: this.player.y + this.player.jumpY, alpha: 0.5});
                }
            }
        }
        
        // æ™®é€šç§»åŠ¨
        let dx = 0, dy = 0;
        if (this.keys['w'] || this.keys['W'] || this.keys['ArrowUp']) dy -= 1;
        if (this.keys['s'] || this.keys['S'] || this.keys['ArrowDown']) dy += 1;
        if (this.keys['a'] || this.keys['A'] || this.keys['ArrowLeft']) { dx -= 1; this.player.facingRight = false; }
        if (this.keys['d'] || this.keys['D'] || this.keys['ArrowRight']) { dx += 1; this.player.facingRight = true; }
        
        // ç©ºæ ¼å†²åˆºè§¦å‘
        if (this.keys[' '] && this.player.dashCooldown <= 0 && !this.player.isDashing) {
            if (dx !== 0 || dy !== 0) {
                const len = Math.sqrt(dx*dx + dy*dy);
                this.player.isDashing = true;
                this.player.dashTime = 0.15;
                this.player.dashCooldown = 0.6;
                this.player.dashDirection = {x: dx/len, y: dy/len};
            }
        }
        
        this.player.isMoving = (dx !== 0 || dy !== 0);
        if (this.player.isMoving && !this.player.isDashing) {
            this.player.walkCycle += dt * 15;
        } else {
            this.player.walkCycle = 0;
        }
        
        // æ›´æ–°æ®‹å½±
        for (let i = this.player.dashTrail.length - 1; i >= 0; i--) {
            this.player.dashTrail[i].alpha -= 0.1;
            if (this.player.dashTrail[i].alpha <= 0) this.player.dashTrail.splice(i, 1);
        }
        
        if ((dx !== 0 || dy !== 0) && !this.player.isDashing) {
            const len = Math.sqrt(dx*dx + dy*dy);
            const newX = this.player.x + (dx / len) * speed * dt;
            const newY = this.player.y + (dy / len) * speed * dt;
            
            const wallThickness = 40;
            
            let canMoveX = true;
            const roomWidth = SURVIVOR_CONFIG.ROOM_WIDTH;
            const roomHeight = SURVIVOR_CONFIG.ROOM_HEIGHT;
            const centerX = roomWidth / 2;
            const centerY = roomHeight / 2;
            
            if (newX < wallThickness) {
                if (!(this.player.y > centerY - 40 && this.player.y < centerY + 40 && this.curRoom.doors.left && this.curRoom.doors.left.open)) {
                    canMoveX = false;
                }
            }
            if (newX > roomWidth - wallThickness) {
                if (!(this.player.y > centerY - 40 && this.player.y < centerY + 40 && this.curRoom.doors.right && this.curRoom.doors.right.open)) {
                    canMoveX = false;
                }
            }
            
            let canMoveY = true;
            if (newY < wallThickness) {
                if (!(this.player.x > centerX - 30 && this.player.x < centerX + 30 && this.curRoom.doors.up && this.curRoom.doors.up.open)) {
                    canMoveY = false;
                }
            }
            if (newY > roomHeight - wallThickness) {
                if (!(this.player.x > centerX - 30 && this.player.x < centerX + 30 && this.curRoom.doors.down && this.curRoom.doors.down.open)) {
                    canMoveY = false;
                }
            }
            
            if (canMoveX) this.player.x = newX;
            if (canMoveY) this.player.y = newY;
        }
        
        // ç©å®¶è¾¹ç•Œé™åˆ¶ - æœ‰é—¨çš„åœ°æ–¹å…è®¸èµ°å‡ºå»ï¼ˆèµ°è¿›é—¨è§¦å‘ä¼ é€ï¼‰
        let minX = 0, maxX = SURVIVOR_CONFIG.ROOM_WIDTH;
        let minY = 0, maxY = SURVIVOR_CONFIG.ROOM_HEIGHT;
        
        // å¦‚æœæ²¡æœ‰é—¨ï¼Œé™åˆ¶åœ¨å¢™å†…
        if (!this.curRoom.doors.left) minX = 60;
        if (!this.curRoom.doors.right) maxX = SURVIVOR_CONFIG.ROOM_WIDTH - 60;
        if (!this.curRoom.doors.up) minY = 60;
        if (!this.curRoom.doors.down) maxY = SURVIVOR_CONFIG.ROOM_HEIGHT - 60;
        
        this.player.x = clamp(this.player.x, minX, maxX);
        this.player.y = clamp(this.player.y, minY, maxY);
        
        // é—¨ä¼ é€æ£€æµ‹ - ä¸ Room.draw ä¸­çš„é—¨ä½ç½®ä¿æŒä¸€è‡´ï¼ˆé—¨å’Œå¢™å¹³é½ï¼‰
        if (this.curRoom.cleared) {
            const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
            const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
            const wallT = 60;
            const centerX = roomW / 2;
            const centerY = roomH / 2;
            for (const [dir, door] of Object.entries(this.curRoom.doors)) {
                if (!door || !door.open) continue;
                // é—¨ä½ç½®ä¸ Room.draw ä¸­ä¸€è‡´ï¼ˆå’Œå¢™å¹³é½ï¼‰
                const pos = { 
                    up: [centerX - 40, 0, 80, wallT],              // ä¸Š: y=0, h=60
                    down: [centerX - 40, roomH - wallT, 80, wallT], // ä¸‹: y=740, h=60
                    left: [0, centerY - 50, wallT, 100],           // å·¦: x=0, w=60
                    right: [roomW - wallT, centerY - 50, wallT, 100] // å³: x=1140, w=60
                }[dir];
                if (this.player.x > pos[0] && this.player.x < pos[0] + pos[2] &&
                    this.player.y > pos[1] && this.player.y < pos[1] + pos[3]) {
                    this.transition = { active: true, timer: 0.3, dir, target: door.target };
                    break;
                }
            }
        }
        
        // æ›´æ–°æ•Œäººï¼ˆä½¿ç”¨æ³¢æ¬¡ç®¡ç†å™¨çš„æ´»è·ƒæ•Œäººï¼‰
        const activeEnemies = this.curRoom.getActiveEnemies ? this.curRoom.getActiveEnemies() : this.curRoom.enemies;
        for (const e of activeEnemies) {
            if (e.hp <= 0) continue;
            e.update(dt, this.player, this.curRoom);
            const d = dist(e.x, e.y, this.player.x, this.player.y);
            if (d < 35 && e.attackCd <= 0) {
                if (!this.godMode && !this.player.isDashing) {
                    const actualDmg = Math.max(0, e.dmg - stats.armor);
                    this.player.hp -= actualDmg;
                    // åˆ†æ•°ï¼šå—ä¼¤æ‰£åˆ†
                    if (actualDmg > 0) {
                        this.scoreManager.onDamage();
                        this.sounds.play('hurt');
                    }
                    // HP æ£€æŸ¥å¿…é¡»åœ¨æ— æ•Œæ¨¡å¼ä¿æŠ¤å—å†…ï¼
                    if (this.player.hp <= 0) {
                        this.state = 'gameover';
                        this.sounds.play('gameover');
                    }
                }
                e.attackCd = 0.5;
            }
        }
        
        // æ£€æŸ¥æˆ¿é—´æ˜¯å¦æ¸…ç†å®Œæˆï¼ˆä½¿ç”¨æ´»è·ƒæ•Œäººè€ŒéåŸå§‹æ•°ç»„ï¼‰
        const aliveEnemies = activeEnemies.filter(e => e.hp > 0);
        if (aliveEnemies.length === 0 && !this.curRoom.cleared) {
            this.curRoom.cleared = true;
            this.openAllDoors(); // æ‰“å¼€é—¨
            this.particles.burst(this.player.x, this.player.y, '#4f4', 30);
            
            // æˆ¿é—´æ¸…ç†å®Œæˆï¼Œè‡ªåŠ¨æ‹¾å–æ‰€æœ‰ç»éªŒçƒ
            this.autoCollectAllGems();
            
            if (this.curRoom.type === 'boss') {
                this.spawnTotemPickup();
                this.spawnStairs(); // ç”Ÿæˆé€šå¾€ä¸‹ä¸€å±‚çš„æ¥¼æ¢¯
                // åªæœ‰ç¬¬6å±‚ï¼ˆæœ€åä¸€å±‚ï¼‰Bossæ‰è§¦å‘èƒœåˆ©
                if (this.currentFloor >= this.maxFloors) {
                    this.state = 'victory';
                }
                return;
            }
            
            this.spawnRoomReward();
        }
        
        // å¯»æ‰¾æœ€è¿‘ç›®æ ‡ï¼ˆä»æ´»è·ƒæ•Œäººä¸­ï¼‰
        let target = null, minD = 9999;
        for (const e of activeEnemies) {
            if (e.hp <= 0) continue;
            const d = dist(e.x, e.y, this.player.x, this.player.y);
            if (d < minD) { minD = d; target = e; }
        }
        
        // è°ƒè¯•ï¼šæ£€æŸ¥æ•Œäººå’Œæ­¦å™¨çŠ¶æ€
        this._attackDebugTimer = (this._attackDebugTimer || 0) + dt;
        if (this._attackDebugTimer >= 2) {
            this._attackDebugTimer = 0;
            console.log(`[æ”»å‡»æ£€æµ‹] enemies=${activeEnemies.length}, target=${target ? 'æœ‰' : 'æ— '}, weapons=${this.weapons.length}`);
        }
        
            // å¹¸å­˜è€…æ¨¡å¼ï¼šæ‰€æœ‰æ­¦å™¨ç‹¬ç«‹æ›´æ–°å’Œå¼€ç«ï¼ˆé‡å¯ä¿æŠ¤æœŸé—´ç¦æ­¢å¼€ç«ï¼‰
        for (const w of this.weapons) {
            w.update(dt);
            if (!this.isRestarting && w.canFire() && target) {
                this.bullets.push(...w.fire(this.player, target, stats));
                this.sounds.play('shoot');
            }
        }
        
        // è°ƒè¯•ï¼šæ¯ç§’è¾“å‡ºå®Œæ•´æ”»å‡»çŠ¶æ€
        this._fullDbgTimer = (this._fullDbgTimer || 0) + dt;
        if (this._fullDbgTimer >= 1) {
            this._fullDbgTimer = 0;
            const w = this.weapons[0];
            // è¯¦ç»†çš„æ•ŒäººçŠ¶æ€
            const roomInfo = this.curRoom ? {
                type: this.curRoom.type,
                enemiesLen: this.curRoom.enemies.length,
                hasHorde: !!this.curRoom.hordeManager,
                cleared: this.curRoom.cleared
            } : null;
            console.log(`[çŠ¶æ€] weapon=${w ? w.cfg.name : 'æ— '}, cd=${w ? w.cd.toFixed(2) : 'N/A'}, canFire=${w ? w.canFire() : 'N/A'}, target=${target ? 'Y' : 'N'}, activeEnemies=${activeEnemies.length}, room=${JSON.stringify(roomInfo)}, paused=${this.paused}, state=${this.state}`);
        }
        
        // è°ƒè¯•ï¼šæ¯ç§’è¾“å‡ºæ­¦å™¨CDå€¼
        this._cdDebugTimer = (this._cdDebugTimer || 0) + dt;
        if (this._cdDebugTimer >= 1) {
            this._cdDebugTimer = 0;
            if (this.weapons.length > 0) {
                const w = this.weapons[0];
                console.log(`[CD] ${w.cfg.name}: cd=${w.cd.toFixed(2)}, canFire=${w.canFire()}, fireRate=${stats.fireRate.toFixed(2)}`);
            } else {
                console.log(`[CD] æ— æ­¦å™¨, weapons.length=0`);
            }
        }
        
        // å­å¼¹è¾¹ç•Œæ£€æŸ¥ï¼ˆå¤§æˆ¿é—´ï¼‰
        const roomW = SURVIVOR_CONFIG.ROOM_WIDTH;
        const roomH = SURVIVOR_CONFIG.ROOM_HEIGHT;
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            const b = this.bullets[i];
            
            if (b.x < 0 || b.x > roomW || b.y < 0 || b.y > roomH) {
                this.bullets.splice(i, 1);
                continue;
            }
            
            if (b.homing && b.target && activeEnemies.includes(b.target)) {
                const dx = b.target.x - b.x;
                const dy = b.target.y - b.y;
                const d = Math.sqrt(dx*dx + dy*dy);
                if (d > 0) {
                    const targetAngle = Math.atan2(dy, dx);
                    const currentAngle = Math.atan2(b.vy, b.vx);
                    let angleDiff = targetAngle - currentAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    const turnRate = 3 * dt;
                    const newAngle = currentAngle + Math.max(-turnRate, Math.min(turnRate, angleDiff));
                    const spd = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
                    b.vx = Math.cos(newAngle) * spd;
                    b.vy = Math.sin(newAngle) * spd;
                }
            }
            
            // æ‹–å°¾æ•ˆæœ
            if (b.type !== 'melee' && Math.random() < 0.3) {
                this.particles.trail(b.x, b.y, b.color || '#ff0', 2);
            }
            
            b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
            
            if (b.life <= 0) { this.bullets.splice(i, 1); continue; }
            
            let hit = false;
            // ä½¿ç”¨ç©ºé—´ç½‘æ ¼ä¼˜åŒ–ç¢°æ’æ£€æµ‹
            const nearbyEnemies = this.spatialGrid.getNearby(b.x, b.y);
            for (const e of nearbyEnemies) {
                if (e.hp <= 0) continue;
                if (dist(b.x, b.y, e.x, e.y) < 20 && !b.hits.has(e)) {
                    b.hits.add(e);
                    
                    // è®¡ç®—æ€»ä¼¤å®³
                    let totalDmg = b.dmg;
                    if (stats.fireDmg) totalDmg += stats.fireDmg;
                    if (stats.thunderDmg && Math.random() < 0.3) totalDmg += stats.thunderDmg;
                    
                    const killed = e.takeDamage(totalDmg, stats);
                    
                    if (stats.poisonDmg) e.applyPoison(stats.poisonDmg, 3);
                    if (stats.healOnHit) {
                        this.player.hp = Math.min(this.player.maxHp, this.player.hp + stats.healOnHit);
                    }
                    
                    if (killed) {
                        e.hp = 0; // æ ‡è®°æ­»äº¡
                        this.gems.push({ x: e.x, y: e.y, v: e.exp || 10, life: 30 });
                        // é‡‘å¸ç›´æ¥åŠ ï¼Œä¸æ‰è½
                        const goldAmount = e.gold || 5;
                        this.player.gold += goldAmount;
                        // å‡»æ€çˆ†ç‚¸æ•ˆæœ
                        this.particles.explosion(e.x, e.y, e.color || '#f44', 25);
                        // é‡‘å¸é—ªå…‰
                        this.particles.sparkle(e.x, e.y - 10, '#fc0', 8);
                        
                        // ææ–™æ‰è½
                        if (Math.random() < 0.15) {
                            const matTypes = Object.keys(MATERIALS);
                            const matType = randChoice(matTypes);
                            this.materials.add(matType, 1);
                            console.log(`è·å¾—ææ–™: ${MATERIALS[matType].name}`);
                        }
                        
                        // åˆ†æ•°ï¼šå‡»æ€æ•Œäºº
                        const enemyType = e.isBoss ? 'boss' : (e.elite || e.hp > 50) ? 'elite' : 'normal';
                        this.scoreManager.onKillEnemy(enemyType);
                        
                        this.particles.burst(e.x, e.y, e.color, 8);
                        this.sounds.play('kill');
                    } else {
                        this.sounds.play('hit');
                    }
                    if (b.pierce-- <= 0) { hit = true; break; }
                }
            }
            if (hit) this.bullets.splice(i, 1);
        }
        
        for (let i = this.gems.length - 1; i >= 0; i--) {
            const g = this.gems[i];
            const d = dist(g.x, g.y, this.player.x, this.player.y);
            if (d < stats.magnet) {
                g.x += (this.player.x - g.x) * 5 * dt;
                g.y += (this.player.y - g.y) * 5 * dt;
            }
            if (d < 20) {
                // åº”ç”¨ç»éªŒåŠ æˆ
                const expBonus = this.passives ? this.passives.getStats().expBonus : 0;
                const expGained = Math.floor(g.v * (1 + expBonus));
                this.player.exp += expGained;
                this.gems.splice(i, 1);
                
                // æ’­æ”¾æ‹¾å–éŸ³æ•ˆ
                this.sounds.play('gem');
                
                // æ£€æŸ¥å‡çº§
                if (this.player.exp >= this.player.lv * 100) {
                    this.player.exp -= this.player.lv * 100;
                    this.player.lv++;
                    this.sounds.play('levelup');
                    this.particles.burst(this.player.x, this.player.y, '#ff0', 20);
                    // æ‰“å¼€4é€‰1å‡çº§ç•Œé¢
                    this.openLevelUpSelect();
                }
            }
        }
        
        // é‡‘å¸ç›´æ¥åŠ ï¼Œæ— éœ€æ‹¾å–
        this.goldDrops = [];
        
        for (let i = this.curRoom.items.length - 1; i >= 0; i--) {
            const item = this.curRoom.items[i];
            if (!item || typeof item.x !== 'number' || typeof item.y !== 'number') {
                console.warn('âš ï¸ æ— æ•ˆçš„ç‰©å“æ•°æ®:', item);
                this.curRoom.items.splice(i, 1);
                continue;
            }
            const d = dist(item.x, item.y, this.player.x, this.player.y);
            
            if (d < 30) {
                if (item.type === 'weapon') {
                    // å¸è¡€é¬¼å¹¸å­˜è€…é£æ ¼ï¼šæ‰“å¼€4é€‰1å‡çº§é€‰æ‹©ç•Œé¢
                    this.sounds.play('chest');
                    this.openLevelUpSelect();
                } else if (item.type === 'totem') {
                    if (this.totems.collect(item.totemId)) {
                        this.sounds.play('evolve');
                        this.particles.burst(item.x, item.y, '#ff0', 30);
                        const totem = TOTEMS[item.totemId];
                        if (totem.effect === 'maxHp') {
                            this.player.maxHp += totem.value;
                            this.player.hp += totem.value;
                        }
                    }
                } else if (item.type === 'stairs') {
                    // è¿›å…¥ä¸‹ä¸€å±‚
                    this.sounds.play('portal');
                    this.goToNextFloor();
                } else {
                    this.sounds.play('buy');
                    this.items.add(item.id);
                }
                this.curRoom.items.splice(i, 1);
                this.particles.burst(item.x, item.y, '#ff0', 10);
                // åˆ†æ•°ï¼šæ‹¾å–é“å…·
                this.scoreManager.onCollectItem();
            }
        }
        
        this.particles.update(dt);
        this.damageNumbers.update(dt);
    }

    draw() {
        // æ›´æ–°ç›¸æœº
        this.camera.update();
        
        // ä½¿ç”¨ canvas å®é™…å°ºå¯¸
        const canvasW = this.canvas.width;
        const canvasH = this.canvas.height;
        
        // æ¸…ç©ºç”»å¸ƒ
        this.ctx.fillStyle = '#0d0d1a';
        this.ctx.fillRect(0, 0, canvasW, canvasH);
        
        // ä¿å­˜ä¸Šä¸‹æ–‡ç”¨äºç¼©æ”¾
        this.ctx.save();
        if (this.camera.showFullRoom) {
            this.ctx.scale(this.camera.zoom, this.camera.zoom);
        }
        
        // ç»˜åˆ¶æˆ¿é—´ï¼ˆä¼ å…¥ç›¸æœºï¼‰
        this.curRoom.draw(this.ctx, this.camera);
        
        // ç»˜åˆ¶æ‰è½ç‰©ï¼ˆåªç»˜åˆ¶è§†é‡å†…çš„ï¼‰
        // é‡‘å¸ç›´æ¥åŠ ï¼Œæ— éœ€ç»˜åˆ¶
        for (const g of this.gems) {
            if (!this.camera.isVisible(g.x, g.y, 20)) continue;
            const pos = this.camera.worldToScreen(g.x, g.y);
            this.ctx.fillStyle = '#48f';
            this.ctx.beginPath();
            this.ctx.moveTo(pos.x, pos.y - 5);
            this.ctx.lineTo(pos.x + 4, pos.y);
            this.ctx.lineTo(pos.x, pos.y + 5);
            this.ctx.lineTo(pos.x - 4, pos.y);
            this.ctx.fill();
        }
        
        // ç»˜åˆ¶å­å¼¹ï¼ˆä½¿ç”¨æ­¦å™¨å›¾æ ‡ï¼‰
        for (const b of this.bullets) {
            if (!this.camera.isVisible(b.x, b.y, 20)) continue;
            const pos = this.camera.worldToScreen(b.x, b.y);
            
            if (b.icon && b.type !== 'melee') {
                // ä½¿ç”¨emojiå›¾æ ‡ç»˜åˆ¶å­å¼¹
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(b.icon, pos.x, pos.y);
            } else {
                // è¿‘æˆ˜æˆ–æ²¡æœ‰å›¾æ ‡çš„ç”¨åœ†å½¢
                this.ctx.fillStyle = b.color;
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y, b.type === 'melee' ? 15 : 6, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
        
        for (const item of this.curRoom.items) {
            if (!this.camera.isVisible(item.x, item.y, 30)) continue;
            const pos = this.camera.worldToScreen(item.x, item.y);
            
            // è·å–ç‰©å“æè¿°å’Œå›¾æ ‡
            let desc = '';
            let icon = item.icon;
            if (item.type === 'weapon') {
                // æ­¦å™¨ç®±æ˜¾ç¤ºé—®å·ï¼Œä¸é€éœ²å…·ä½“æ­¦å™¨
                icon = 'â“';
                desc = 'ç¥ç§˜æ­¦å™¨|æ‹¾å–åä¸‰é€‰ä¸€';
            } else if (item.type === 'totem') {
                const t = TOTEMS[item.totemId];
                desc = t ? `${t.name}|${t.desc}` : 'å›¾è…¾';
            } else if (item.type === 'stairs') {
                // æ¥¼æ¢¯ç‰¹æ®Šæ˜¾ç¤º
                desc = 'é€šå¾€ä¸‹ä¸€å±‚';
                icon = 'ğŸ•³ï¸';
                
                // ç»˜åˆ¶æ¥¼æ¢¯ç‰¹æ®Šæ•ˆæœï¼ˆç´«è‰²å‘å…‰åœ†åœˆï¼‰
                const pulse = Math.sin(Date.now() / 300) * 5;
                this.ctx.strokeStyle = 'rgba(160, 32, 240, 0.6)';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y, 25 + pulse, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.fillStyle = 'rgba(160, 32, 240, 0.2)';
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);
                this.ctx.fill();
                
                // ç»˜åˆ¶æè¿°æ–‡å­—
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(pos.x - 50, pos.y - 45, 100, 16);
                this.ctx.fillStyle = '#d0f';
                this.ctx.font = 'bold 11px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(desc, pos.x, pos.y - 33);
                
                // ç»˜åˆ¶æ¥¼æ¢¯å›¾æ ‡ï¼ˆæ›´å¤§ï¼‰
                this.ctx.font = '32px Arial';
                this.ctx.fillText(icon, pos.x, pos.y + 10);
                continue; // æ¥¼æ¢¯ç»˜åˆ¶å®Œæˆï¼Œè·³è¿‡é€šç”¨ç»˜åˆ¶
            } else {
                const itemData = ITEMS[item.id];
                desc = itemData ? `${itemData.name}|${itemData.desc}` : 'é“å…·';
            }
            
            // ç»˜åˆ¶æè¿°æ–‡å­—ï¼ˆç‰©å“ä¸Šæ–¹ï¼‰
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            this.ctx.fillRect(pos.x - 60, pos.y - 35, 120, 14);
            this.ctx.fillStyle = '#fff';
            this.ctx.font = '10px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(desc.substring(0, 20), pos.x, pos.y - 25);
            
            // ç»˜åˆ¶ç‰©å“å›¾æ ‡
            this.ctx.fillStyle = item.type === 'weapon' ? '#f80' : '#ff0';
            this.ctx.font = '20px Arial';
            this.ctx.fillText(icon, pos.x, pos.y + 5);
            
            this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(pos.x, pos.y, 15 + Math.sin(Date.now() / 200) * 3, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        
        // è·å–æ´»è·ƒæ•Œäººå¹¶æ›´æ–°ç©ºé—´ç½‘æ ¼
        const activeEnemies = this.curRoom.hordeManager ? this.curRoom.hordeManager.getActiveEnemies() : this.curRoom.enemies;
        this.spatialGrid.clear();
        for (const e of activeEnemies) {
            if (e.hp > 0) this.spatialGrid.insert(e);
        }
        
        // ç»˜åˆ¶æ•Œäººï¼ˆä½¿ç”¨ç²¾çµå›¾å’ŒåŠ¨ç”»ï¼‰
        for (const e of activeEnemies) {
            if (!this.camera.isVisible(e.x, e.y, 30)) continue;
            // ä½¿ç”¨Enemyç±»çš„drawæ–¹æ³•ï¼Œä¼ å…¥è½¬æ¢åçš„åæ ‡
            const pos = this.camera.worldToScreen(e.x, e.y);
            this.ctx.save();
            this.ctx.translate(pos.x, pos.y);
            e.drawWithOffset(this.ctx, this.sprites);
            this.ctx.restore();
        }
        
        if (this.curRoom.type === 'shop' && this.curRoom.npc) {
            const npc = this.curRoom.npc;
            if (this.camera.isVisible(npc.x, npc.y, 40)) {
                const pos = this.camera.worldToScreen(npc.x, npc.y);
                const d = dist(this.player.x, this.player.y, npc.x, npc.y);
                // ç®€åŒ–çš„NPCç»˜åˆ¶
                this.ctx.fillStyle = '#4a4';
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('ğŸ¦¯', pos.x, pos.y + 5);
                if (d < 80 && !this.shopOpen) {
                    this.ctx.fillStyle = '#4f4';
                    this.ctx.fillText('æŒ‰Eäº¤äº’', pos.x, pos.y - 30);
                }
            }
        }
        
        // ç©å®¶å±å¹•åæ ‡
        const playerScreen = this.camera.worldToScreen(this.player.x, this.player.y);
        
        // ç»˜åˆ¶å†²åˆºæ®‹å½±
        for (const trail of this.player.dashTrail) {
            const trailScreen = this.camera.worldToScreen(trail.x, trail.y);
            this.ctx.globalAlpha = trail.alpha * 0.4;
            this.ctx.fillStyle = '#88ccff';
            this.ctx.beginPath();
            this.ctx.arc(trailScreen.x, trailScreen.y, 12, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1;
        
        // ç»˜åˆ¶ç©å®¶ï¼ˆå¸¦åŠ¨ç”»ï¼‰
        // è®¡ç®—è¡Œèµ°åŠ¨ç”»
        if (this.player.isMoving && !this.player.isDashing) {
            this.player.walkCycle = (this.player.walkCycle || 0) + 0.15;
        } else {
            this.player.walkCycle = 0;
        }
        
        const walkPhase = Math.sin(this.player.walkCycle);
        const walkBob = Math.abs(Math.sin(this.player.walkCycle * 0.5)) * -4; // è¡Œèµ°æ—¶çš„ä¸Šä¸‹é¢ ç°¸
        const breathY = Math.sin(Date.now() / 300) * 1; // å‘¼å¸åŠ¨ç”»
        const wobble = this.player.isMoving ? walkPhase * 3 : 0; // å·¦å³è½»å¾®æ‘‡æ‘†
        
        const totalScreenY = playerScreen.y + (this.player.jumpY || 0) + breathY + walkBob;
        
        const playerSprite = this.sprites.get('player');
        this.ctx.save();
        this.ctx.translate(playerScreen.x, totalScreenY);
        
        // é¢å‘æ–¹å‘ç¿»è½¬
        if (!this.player.facingRight) this.ctx.scale(-1, 1);
        
        // è¡Œèµ°æ—¶çš„èº«ä½“å€¾æ–œ
        if (this.player.isMoving && !this.player.isDashing) {
            this.ctx.rotate(walkPhase * 0.05);
        }
        
        if (playerSprite) {
            // ä½¿ç”¨ç²¾çµå›¾ç»˜åˆ¶è§’è‰²ï¼ˆæ”¾å¤§ä¸€å€ä»¥åŒ¹é…æ•Œäººå°ºå¯¸ï¼‰
            // ç²¾çµå›¾è‡ªå¸¦è…¿éƒ¨ï¼Œä¸éœ€è¦é¢å¤–ç»˜åˆ¶
            this.ctx.drawImage(playerSprite, -32, -32, 64, 64);
        } else {
            // ç¨‹åºåŒ–ç»˜åˆ¶ç‰›ç‰›ï¼ˆå¸¦è¡Œèµ°åŠ¨ç”»ï¼‰
            // èº«ä½“ä¸Šä¸‹åŠ¨
            const bodyY = breathY + walkBob * 0.5;
            
            // èº«ä½“
            this.ctx.fillStyle = '#e8e8e8';
            this.ctx.beginPath();
            this.ctx.ellipse(0, bodyY, 26, 20, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // å¤´éƒ¨è½»å¾®æ‘†åŠ¨
            const headBob = Math.sin(this.player.walkCycle * 0.5) * 2;
            // çœ¼ç›
            this.ctx.fillStyle = '#333';
            this.ctx.beginPath();
            this.ctx.arc(20, -12 + bodyY + headBob, 3, 0, Math.PI * 2);
            this.ctx.fill();
            
            // ç‰›è§’
            this.ctx.fillStyle = '#666';
            this.ctx.beginPath();
            this.ctx.moveTo(15, -25 + bodyY);
            this.ctx.lineTo(20, -35 + bodyY);
            this.ctx.lineTo(25, -25 + bodyY);
            this.ctx.fill();
        }
        
        this.ctx.restore();
        
        // å†²åˆºç‰¹æ•ˆ
        if (this.player.isDashing) {
            this.ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
            this.ctx.lineWidth = 2;
            const dir = this.player.facingRight ? 1 : -1;
            for (let i = 0; i < 3; i++) {
                const offset = (Date.now() / 30 + i * 15) % 25;
                this.ctx.beginPath();
                this.ctx.moveTo(playerScreen.x - dir * (15 + offset), totalScreenY - 10 + i * 8);
                this.ctx.lineTo(playerScreen.x - dir * (25 + offset), totalScreenY - 10 + i * 8);
                this.ctx.stroke();
            }
        }
        
        this.particles.draw(this.ctx);
        this.damageNumbers.draw(this.ctx);
        
        if (this.transition.active) {
            const alpha = Math.sin(this.transition.timer / 0.3 * Math.PI);
            this.ctx.fillStyle = `rgba(0,0,0,${alpha})`;
            this.ctx.fillRect(0, 0, 900, 600);
        }
        
        // å•†åº—UI
        if (this.shopOpen) {
            this.drawShopUI();
        }
        
        // 4é€‰1å‡çº§é€‰æ‹©UI
        if (this.levelUpOpen) {
            this.drawLevelUpUI();
        }
        
        // æ¢å¤ä¸Šä¸‹æ–‡
        this.ctx.restore();
        
        // æš‚åœç•Œé¢ï¼ˆåœ¨å±å¹•åæ ‡ç³»ä¸Šç»˜åˆ¶ï¼‰
        if (this.paused) {
            this.drawPauseScreen();
        }
        
        // æ›´æ–°ä¾§è¾¹é¢æ¿
        this.updateSidePanels();
        
        this.drawUI();
    }
    
    drawShopUI() {
        const ctx = this.ctx;
        const canvas = ctx.canvas;
        const cw = canvas.width || 900;
        const ch = canvas.height || 600;
        const centerX = cw / 2;
        const centerY = ch / 2;
        
        const boxWidth = 500;
        const boxHeight = 350;
        const boxX = centerX - boxWidth / 2;
        const boxY = centerY - boxHeight / 2;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = '#4a4';
        ctx.lineWidth = 3;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        ctx.fillStyle = '#4f4';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ¦¯ ç›²çœ¼çš„å•†åº— ğŸ‘ï¸', centerX, boxY + 40);
        
        ctx.fillStyle = '#fc0';
        ctx.font = '18px Arial';
        ctx.fillText(`ğŸ’° ${this.player.gold}`, centerX, boxY + 70);
        
        const itemWidth = 130;
        const itemHeight = 160;
        const startX = centerX - (this.shopItems.length * itemWidth) / 2 + itemWidth / 2;
        
        this.shopItems.forEach((item, i) => {
            const ix = startX + i * (itemWidth + 20);
            const iy = boxY + 160;
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(ix - itemWidth/2, iy - itemHeight/2, itemWidth, itemHeight);
            ctx.strokeStyle = this.player.gold >= item.price ? '#4a4' : '#a44';
            ctx.lineWidth = 2;
            ctx.strokeRect(ix - itemWidth/2, iy - itemHeight/2, itemWidth, itemHeight);
            
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(item.icon, ix, iy - 20);
            
            ctx.fillStyle = '#fff';
            ctx.font = '14px Arial';
            ctx.fillText(item.name, ix, iy + 15);
            
            ctx.fillStyle = '#aaa';
            ctx.font = '11px Arial';
            ctx.fillText(item.desc, ix, iy + 35);
            
            ctx.fillStyle = this.player.gold >= item.price ? '#fc0' : '#f44';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`ğŸ’°${item.price}`, ix, iy + 60);
            
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.fillText(`[${i + 1}]`, ix, iy + 80);
        });
        
        ctx.fillStyle = '#888';
        ctx.font = '14px Arial';
        ctx.fillText('æŒ‰ 1-3 è´­ä¹° | æŒ‰ E å…³é—­', centerX, boxY + boxHeight - 20);
    }
    
    drawLevelUpUI() {
        const ctx = this.ctx;
        const boxWidth = 640;
        const boxHeight = 460;
        const boxX = (ctx.canvas.width || 900) / 2 - boxWidth / 2;
        const boxY = (ctx.canvas.height || 600) / 2 - boxHeight / 2;
        const centerX = (ctx.canvas.width || 900) / 2;
        
        // æ·±è‰²èƒŒæ™¯
        ctx.fillStyle = 'rgba(10, 10, 20, 0.98)';
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        // é‡‘è‰²è¾¹æ¡†
        ctx.strokeStyle = '#fa0';
        ctx.lineWidth = 4;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        // å†…è¾¹æ¡†
        ctx.strokeStyle = '#840';
        ctx.lineWidth = 2;
        ctx.strokeRect(boxX + 4, boxY + 4, boxWidth - 8, boxHeight - 8);
        
        // æ ‡é¢˜èƒŒæ™¯æ¡
        ctx.fillStyle = 'rgba(250, 160, 0, 0.2)';
        ctx.fillRect(boxX, boxY, boxWidth, 50);
        
        // æ ‡é¢˜
        ctx.fillStyle = '#ff0';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('â­ å‡çº§ï¼é€‰æ‹©ä¸€é¡¹ â­', centerX, boxY + 38);
        
        // è®¡ç®—å¡ç‰‡å¸ƒå±€ - å¡«æ»¡æ•´ä¸ªæ¡†
        const padding = 20; // å†…è¾¹è·
        const bottomBarHeight = 40; // åº•éƒ¨æç¤ºæ é«˜åº¦
        const contentWidth = boxWidth - padding * 2;
        const contentHeight = boxHeight - 50 - bottomBarHeight; // å‡å»æ ‡é¢˜å’Œåº•éƒ¨æ 
        const gapX = 20; // å¡ç‰‡æ¨ªå‘é—´è·
        const gapY = 20; // å¡ç‰‡çºµå‘é—´è·
        
        // 2x2ç½‘æ ¼å¸ƒå±€
        const cardWidth = (contentWidth - gapX) / 2;
        const cardHeight = (contentHeight - gapY) / 2;
        const startX = boxX + padding;
        const startY = boxY + 55; // æ ‡é¢˜ä¸‹æ–¹
        
        this.levelUpOptions.forEach((option, i) => {
            const row = Math.floor(i / 2);
            const col = i % 2;
            const cardX = startX + col * (cardWidth + gapX);
            const cardY = startY + row * (cardHeight + gapY);
            
            const isWeapon = option.type === 'weapon';
            const borderColor = isWeapon ? '#48f' : '#4f4';
            const bgColor = isWeapon ? 'rgba(30, 40, 80, 0.9)' : 'rgba(30, 60, 40, 0.9)';
            
            // å¡ç‰‡èƒŒæ™¯
            ctx.fillStyle = bgColor;
            ctx.fillRect(cardX, cardY, cardWidth, cardHeight);
            
            // å¡ç‰‡è¾¹æ¡†
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 3;
            ctx.strokeRect(cardX, cardY, cardWidth, cardHeight);
            
            // é¡¶éƒ¨ç±»å‹æ¡
            const headerHeight = Math.max(28, cardHeight * 0.15);
            ctx.fillStyle = borderColor;
            ctx.fillRect(cardX, cardY, cardWidth, headerHeight);
            
            // ç±»å‹æ ‡ç­¾
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${Math.max(13, cardHeight * 0.08)}px Arial`;
            ctx.textAlign = 'left';
            ctx.fillText(isWeapon ? 'ğŸ”« æ­¦å™¨' : 'ğŸ“¦ è¢«åŠ¨', cardX + 12, cardY + headerHeight * 0.6);
            
            // æŒ‰é”®æç¤ºï¼ˆå³ä¸Šè§’ï¼‰
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fillRect(cardX + cardWidth - 40, cardY, 40, headerHeight);
            ctx.fillStyle = '#ff0';
            ctx.font = `bold ${Math.max(15, cardHeight * 0.09)}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(`[${i + 1}]`, cardX + cardWidth - 20, cardY + headerHeight * 0.6);
            
            // è®¡ç®—å†…å®¹åŒºåŸŸ
            const contentY = cardY + headerHeight;
            const contentH = cardHeight - headerHeight;
            const centerX = cardX + cardWidth / 2;
            
            // å›¾æ ‡ï¼ˆå±…ä¸­åä¸Šï¼‰
            ctx.font = `${Math.max(40, cardHeight * 0.22)}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(option.data.icon, centerX, contentY + contentH * 0.35);
            
            // åç§°
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${Math.max(16, cardHeight * 0.09)}px Arial`;
            ctx.fillText(option.data.name, centerX, contentY + contentH * 0.55);
            
            // ç­‰çº§/æè¿°åŒºåŸŸ
            const infoY = contentY + contentH * 0.7;
            if (isWeapon) {
                if (option.isNew) {
                    ctx.fillStyle = '#4f4';
                    ctx.font = `bold ${Math.max(14, cardHeight * 0.08)}px Arial`;
                    ctx.fillText('[æ–°æ­¦å™¨]', centerX, infoY);
                } else {
                    ctx.fillStyle = '#f0f';
                    ctx.font = `bold ${Math.max(14, cardHeight * 0.08)}px Arial`;
                    ctx.fillText(`Lv.${option.level}/${option.maxLevel}`, centerX, infoY);
                }
                // æ­¦å™¨å±æ€§
                ctx.fillStyle = '#ccc';
                ctx.font = `${Math.max(12, cardHeight * 0.07)}px Arial`;
                ctx.fillText(`ä¼¤å®³${option.data.dmg} å†·å´${option.data.cd}s`, centerX, contentY + contentH * 0.85);
            } else {
                // è¢«åŠ¨ç­‰çº§
                ctx.fillStyle = '#0ff';
                ctx.font = `bold ${Math.max(14, cardHeight * 0.08)}px Arial`;
                ctx.fillText(`Lv.${option.level}/${option.maxLevel}`, centerX, infoY);
                // è¢«åŠ¨æè¿°
                ctx.fillStyle = '#ccc';
                ctx.font = `${Math.max(12, cardHeight * 0.07)}px Arial`;
                // æˆªçŸ­æè¿°ä»¥é€‚åº”ç©ºé—´
                let desc = option.data.desc;
                if (desc.length > 12) desc = desc.substring(0, 11) + 'â€¦';
                ctx.fillText(desc, centerX, contentY + contentH * 0.85);
            }
        });
        
        // åº•éƒ¨æç¤º
        ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';
        ctx.fillRect(boxX, boxY + boxHeight - bottomBarHeight, boxWidth, bottomBarHeight);
        ctx.fillStyle = '#ff0';
        ctx.font = 'bold 15px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('æŒ‰ 1-4 é€‰æ‹© | æ­¦å™¨æ»¡çº§ + å¯¹åº”è¢«åŠ¨ = åˆæˆè¶…æ­¦', centerX, boxY + boxHeight - 14);
    }

    drawUI() {
        // æ¸¸æˆç»“ç®—ç”»é¢
        if (this.showResultScreen && this.gameResultData) {
            this.drawResultScreen();
            return;
        }
        
        // æ¸¸æˆç»“æŸ/èƒœåˆ©è§¦å‘ï¼ˆé‡å¯æœŸé—´è·³è¿‡ï¼‰
        if (this.isRestarting) {
            console.log(`âš¡ drawUIè·³è¿‡: isRestarting=true, state=${this.state}`);
            return;
        }
        
        if (this.state === 'gameover' && this.scoreManager.isPlaying) {
            this.endGame('dead');
        }
        if (this.state === 'victory' && this.scoreManager.isPlaying) {
            this.sounds.play('victory');
            this.endGame('cleared');
        }
    }
    
    // ç»˜åˆ¶æ¸¸æˆç»“ç®—ç”»é¢
    drawResultScreen() {
        const ctx = this.ctx;
        const data = this.gameResultData;
        const isVictory = this.gameResult === 'cleared';
        const isDead = this.gameResult === 'dead';
        
        // è·å–å®é™…canvaså°ºå¯¸ï¼ˆé€‚é…åŠ¨æ€å¤§å°ï¼‰
        const canvas = this.canvas;
        const cw = canvas.width;
        const ch = canvas.height;
        const centerX = cw / 2;
        const centerY = ch / 2;
        
        // æ·±è‰²èƒŒæ™¯
        ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
        ctx.fillRect(0, 0, cw, ch);
        
        // æ ‡é¢˜
        ctx.textAlign = 'center';
        if (isVictory) {
            ctx.fillStyle = '#4f4';
            ctx.font = 'bold 56px Arial';
            ctx.fillText('ğŸ‰ é€šå…³èƒœåˆ©! ğŸ‰', centerX, ch * 0.13);
        } else if (isDead) {
            ctx.fillStyle = '#f44';
            ctx.font = 'bold 56px Arial';
            ctx.fillText('ğŸ’€ ä½ é˜µäº¡äº† ğŸ’€', centerX, ch * 0.13);
        } else {
            ctx.fillStyle = '#fa0';
            ctx.font = 'bold 56px Arial';
            ctx.fillText('ğŸ æ¸¸æˆç»“æŸ ğŸ', centerX, ch * 0.13);
        }
        
        // ç»Ÿè®¡é¢æ¿èƒŒæ™¯ï¼ˆå±…ä¸­ï¼Œå®½åº¦é€‚åº”ï¼‰
        const panelW = Math.min(500, cw - 40);
        const panelH = Math.min(380, ch - 150);
        const panelX = (cw - panelW) / 2;
        const panelY = ch * 0.18;
        
        ctx.fillStyle = 'rgba(20, 20, 40, 0.9)';
        ctx.fillRect(panelX, panelY, panelW, panelH);
        ctx.strokeStyle = isVictory ? '#4f4' : isDead ? '#f44' : '#fa0';
        ctx.lineWidth = 3;
        ctx.strokeRect(panelX, panelY, panelW, panelH);
        
        // ç»Ÿè®¡æ ‡é¢˜
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 24px Arial';
        ctx.fillText('ğŸ“Š æœ€ç»ˆç»Ÿè®¡', centerX, panelY + 35);
        
        // åˆ†éš”çº¿
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(panelX + 30, panelY + 50);
        ctx.lineTo(panelX + panelW - 30, panelY + 50);
        ctx.stroke();
        
        // ç»Ÿè®¡æ•°æ®
        ctx.font = '20px Arial';
        ctx.textAlign = 'left';
        const stats = [
            { label: 'ğŸ’¯ æœ€ç»ˆåˆ†æ•°', value: data.finalScore.toLocaleString(), color: '#ff0' },
            { label: 'âš”ï¸ å‡»æ€æ•Œäºº', value: data.stats.enemiesKilled, color: '#fff' },
            { label: 'ğŸšª æ¢ç´¢æˆ¿é—´', value: data.stats.roomsExplored, color: '#fff' },
            { label: 'ğŸ’° è·å¾—é‡‘å¸', value: this.player.gold, color: '#fc0' },
            { label: 'ğŸ“ åˆ°è¾¾å±‚æ•°', value: `${this.currentFloor}/6`, color: '#fff' },
            { label: 'â­ æœ€é«˜ç­‰çº§', value: `Lv.${this.player.lv}`, color: '#0ff' }
        ];
        
        const rowHeight = Math.min(45, (panelH - 80) / stats.length);
        const startY = panelY + 90;
        
        stats.forEach((stat, i) => {
            const y = startY + i * rowHeight;
            ctx.fillStyle = '#aaa';
            ctx.fillText(stat.label, panelX + 50, y);
            ctx.fillStyle = stat.color;
            ctx.textAlign = 'right';
            ctx.fillText(String(stat.value), panelX + panelW - 50, y);
            ctx.textAlign = 'left';
        });
        
        // è¿”å›æŒ‰é’®ï¼ˆä¿å­˜åæ ‡ä¾›ç‚¹å‡»æ£€æµ‹ä½¿ç”¨ï¼‰
        const btnW = 200;
        const btnH = 50;
        const btnX = centerX - btnW / 2;
        const btnY = panelY + panelH + 20;
        
        // ä¿å­˜æŒ‰é’®åæ ‡ä¾›handleClickä½¿ç”¨
        this.resultBtnRect = { x: btnX, y: btnY, w: btnW, h: btnH };
        
        // æŒ‰é’®èƒŒæ™¯
        ctx.fillStyle = '#2a2a4a';
        ctx.fillRect(btnX, btnY, btnW, btnH);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(btnX, btnY, btnW, btnH);
        
        // æŒ‰é’®æ–‡å­—
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 22px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('â†© è¿”å›ä¸»èœå•', centerX, btnY + 33);
        
        // æç¤º
        ctx.fillStyle = '#888';
        ctx.font = '14px Arial';
        ctx.fillText('ç‚¹å‡»æŒ‰é’®æˆ–æŒ‰ç©ºæ ¼é”®è¿”å›', centerX, btnY + btnH + 30);
    }
    
    // ä»¥æ’’é£æ ¼å°åœ°å›¾ï¼ˆåœ¨å³ä¾§è¾¹æ æ˜¾ç¤ºï¼‰
    // å·²è®¿é—®æˆ¿é—´=å®å¿ƒï¼Œæœªè®¿é—®æˆ¿é—´=è½®å»“
    updateMiniMap() {
        const canvas = document.getElementById('miniMapCanvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const size = 220;
        
        // æ¸…ç©ºå¹¶å¡«å……èƒŒæ™¯
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, size, size);
        
        if (!this.allRooms || this.allRooms.size === 0) {
            console.warn('å°åœ°å›¾: allRoomsä¸ºç©º');
            return;
        }
        
        const rooms = Array.from(this.allRooms.values());
        
        // è®¡ç®—åœ°å›¾èŒƒå›´
        let minX = 0, maxX = 0, minY = 0, maxY = 0;
        for (const r of rooms) {
            minX = Math.min(minX, r.gx);
            maxX = Math.max(maxX, r.gx);
            minY = Math.min(minY, r.gy);
            maxY = Math.max(maxY, r.gy);
        }
        
        const width = maxX - minX + 1;
        const height = maxY - minY + 1;
        const padding = 20;
        const cellSize = Math.min((size - padding * 2) / width, (size - padding * 2) / height);
        const mapPixelW = width * cellSize;
        const mapPixelH = height * cellSize;
        const offsetX = (size - mapPixelW) / 2;
        const offsetY = (size - mapPixelH) / 2;
        
        // ç»˜åˆ¶æˆ¿é—´
        for (const r of rooms) {
            const rx = offsetX + (r.gx - minX) * cellSize + 2;
            const ry = offsetY + (r.gy - minY) * cellSize + 2;
            const rw = cellSize - 4;
            
            // æœªè®¿é—®çš„æˆ¿é—´åªç»˜åˆ¶è½®å»“ï¼ˆä»¥æ’’é£æ ¼ï¼‰
            if (r.visited) {
                switch(r.type) {
                    case 'start': ctx.fillStyle = '#4f4'; break;
                    case 'boss': ctx.fillStyle = '#f44'; break;
                    case 'treasure': ctx.fillStyle = '#fa0'; break;
                    case 'shop': ctx.fillStyle = '#48f'; break;
                    default: ctx.fillStyle = '#ccc';
                }
                ctx.fillRect(rx, ry, rw, rw);
            } else {
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1.5;
                ctx.strokeRect(rx, ry, rw, rw);
            }
            
            // å½“å‰æˆ¿é—´é«˜äº®
            if (r === this.curRoom) {
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 3;
                ctx.strokeRect(rx - 2, ry - 2, rw + 4, rw + 4);
            }
        }
    }
    
    spawnRoomReward() {
        const roll = Math.random();
        if (this.curRoom.type === 'boss') {
            this.spawnWeaponPickup();
        } else if (this.curRoom.type === 'treasure') {
            this.spawnItemPickup();
        } else if (roll < 0.3) {
            this.spawnItemPickup();
        } else if (roll < 0.5) {
            this.spawnWeaponPickup();
        }
    }
    
    spawnItemPickup() {
        const itemId = randInt(1, 16);
        const item = ITEMS[itemId];
        if (!item) return;
        this.curRoom.items.push({ x: this.curRoom.centerX, y: this.curRoom.centerY, id: itemId, icon: item.icon, name: item.name });
    }
    
    spawnWeaponPickup() {
        // æ­¦å™¨ç®±ä¸æ˜¾ç¤ºå…·ä½“æ­¦å™¨ï¼Œç”¨é—®å·è¡¨ç¤º
        this.curRoom.items.push({
            x: this.curRoom.centerX, y: this.curRoom.centerY,
            type: 'weapon', icon: 'â“', name: 'ç¥ç§˜æ­¦å™¨'
        });
    }
    
    spawnTotemPickup() {
        const totemId = randInt(1, 8);
        const totem = TOTEMS[totemId];
        if (!totem) return;
        this.curRoom.items.push({
            x: this.curRoom.centerX, y: this.curRoom.centerY,
            type: 'totem', totemId: totemId,
            icon: totem.icon, name: totem.name
        });
    }
    
    // ç”Ÿæˆé€šå¾€ä¸‹ä¸€å±‚çš„æ¥¼æ¢¯ï¼ˆBossæˆ¿æ¸…ç†åè°ƒç”¨ï¼‰
    spawnStairs() {
        // åœ¨æˆ¿é—´ä¸‹æ–¹ç”Ÿæˆæ¥¼æ¢¯
        this.curRoom.items.push({
            x: this.curRoom.centerX,
            y: this.curRoom.height - 120,
            type: 'stairs',
            icon: 'ğŸ•³ï¸',
            name: 'é€šå¾€ä¸‹ä¸€å±‚'
        });
        console.log('ğŸ•³ï¸ é€šå¾€ä¸‹ä¸€å±‚çš„æ¥¼æ¢¯å·²å‡ºç°');
    }
    
    // è¿›å…¥ä¸‹ä¸€å±‚
    goToNextFloor() {
        if (this.currentFloor >= this.maxFloors) {
            console.log('ğŸ† å·²åˆ°è¾¾æœ€æ·±å±‚ï¼');
            this.endGame('cleared');
            return;
        }
        
        this.currentFloor++;
        console.log(`â¬‡ï¸ è¿›å…¥ç¬¬ ${this.currentFloor} å±‚`);
        
        // æ¸…ç†å½“å‰æ¸¸æˆå®ä½“
        this.bullets = [];
        this.particles = new ParticleSystem();
        this.gems = [];
        this.goldDrops = [];
        
        // é‡æ–°ç”Ÿæˆåœ°å›¾
        const gen = new MapGenerator();
        const map = gen.generate(this.currentFloor);
        this.curRoom = map.start;
        this.allRooms = map.rooms;
        this.curRoom.visited = true;
        this.allFloors.set(this.currentFloor, { start: map.start, rooms: map.rooms });
        
        // ç¡®ä¿æ–°æˆ¿é—´çš„ items æ•°ç»„æœ‰æ•ˆ
        if (!this.curRoom.items) {
            this.curRoom.items = [];
        }
        
        // ä¼ é€ç©å®¶åˆ°æ–°åœ°å›¾èµ·ç‚¹
        this.player.x = this.curRoom.centerX;
        this.player.y = this.curRoom.centerY;
        
        // æ¢å¤ä¸€äº›ç”Ÿå‘½å€¼ï¼ˆæ¯å±‚æ¢å¤1ç‚¹ï¼‰
        this.player.hp = Math.min(this.player.maxHp, this.player.hp + 1);
        
        // åˆ†æ•°ï¼šè¿›å…¥æ–°å±‚
        this.scoreManager.onEnterFloor(this.currentFloor);
        
        // æ›´æ–°UI
        this.updateScoreDisplay();
        
        // ç‰¹æ•ˆ
        this.particles.burst(this.player.x, this.player.y, '#4f4', 30);
    }

    // å­˜æ¡£ç³»ç»Ÿï¼ˆç¬¬5æ¬¡è¿­ä»£ï¼‰
    saveGame() {
        try {
            const saveData = {
                player: {
                    hp: this.player.hp,
                    maxHp: this.player.maxHp,
                    exp: this.player.exp,
                    lv: this.player.lv,
                    gold: this.player.gold
                },
                items: this.items.owned,
                weapons: this.weapons.map(w => ({ key: w.baseKey, level: w.level, evolution: w.evolution })),
                currentFloor: this.currentFloor,
                timestamp: Date.now()
            };
            localStorage.setItem('rougecow_save', JSON.stringify(saveData));
            console.log('ğŸ’¾ æ¸¸æˆå·²å­˜æ¡£');
            return true;
        } catch (e) {
            console.error('å­˜æ¡£å¤±è´¥:', e);
            return false;
        }
    }
    
    loadGame() {
        try {
            const saveData = localStorage.getItem('rougecow_save');
            if (!saveData) return false;
            
            const data = JSON.parse(saveData);
            
            // æ¢å¤ç©å®¶æ•°æ®
            Object.assign(this.player, data.player);
            
            // æ¢å¤é“å…·
            this.items.owned = data.items || {};
            this.items.dirty = true;
            
            // æ¢å¤æ­¦å™¨
            if (data.weapons && data.weapons.length > 0) {
                this.weapons = data.weapons.map(w => new Weapon(w.key, w.level, w.evolution));
            }
            
            // æ¢å¤å±‚æ•°
            this.currentFloor = data.currentFloor || 1;
            
            console.log('ğŸ“‚ æ¸¸æˆå·²åŠ è½½');
            return true;
        } catch (e) {
            console.error('è¯»æ¡£å¤±è´¥:', e);
            return false;
        }
    }
    
    hasSave() {
        return !!localStorage.getItem('rougecow_save');
    }
    
    deleteSave() {
        localStorage.removeItem('rougecow_save');
        console.log('ğŸ—‘ï¸ å­˜æ¡£å·²åˆ é™¤');
    }

    loop(t) {
        let dt = Math.min((t - (this.lastT || t)) / 1000, 0.1) * this.timeScale;
        if (dt < 0) {
            console.warn(`[Game] dtä¸ºè´Ÿæ•°: ${dt}, é‡ç½®ä¸º0`);
            dt = 0;
        }
        this.lastT = t;
        
        // æ›´æ–°æ€§èƒ½ç›‘æ§
        this.perfMonitor.update();
        
        if (this.state === 'playing' || this.transition.active) {
            this.update(dt);
        }
        this.draw();
        
        // ç»˜åˆ¶æ€§èƒ½ç›‘æ§
        this.perfMonitor.draw(this.ctx, 10, 10);
        
        // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
        if (this.state === 'playing' && this.scoreManager.isPlaying) {
            this.updateScoreDisplay();
        }
        
        this.rafId = requestAnimationFrame(t => this.loop(t));
    }
}

// å¯åŠ¨
window.onload = () => {
    const game = new Game();
    setTimeout(() => game.start(), 500);
    
    // è‡ªåŠ¨æµ‹è¯•ï¼šé‡å¼€æ¸¸æˆåèƒ½å¦æ”»å‡»
    if (window.location.search.includes('test=restart')) {
        setTimeout(() => window.runRestartAttackTest(), 3000);
    }
};

// è‡ªåŠ¨æµ‹è¯•å‡½æ•°
window.runRestartAttackTest = async function() {
    console.log('ğŸ§ª ========== è‡ªåŠ¨æµ‹è¯•ï¼šé‡å¼€æ¸¸æˆåèƒ½å¦æ”»å‡» ==========');
    const game = window.game;
    
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function getBullets() { return game.bullets.length; }
    
    // ç¬¬ä¸€è½®æ¸¸æˆ
    console.log('\nğŸ§ª ç¬¬ä¸€è½®æ¸¸æˆï¼ˆ5å€é€Ÿï¼‰');
    game.setSpeed(5);
    await sleep(2000);
    const b1 = getBullets();
    console.log(`ğŸ§ª åˆå§‹å­å¼¹: ${b1}`);
    await sleep(5000);
    const b2 = getBullets();
    console.log(`ğŸ§ª 5ç§’åå­å¼¹: ${b2}`);
    console.log(b2 > b1 ? 'âœ… ç¬¬ä¸€è½®å¯ä»¥æ”»å‡»' : 'âš ï¸ ç¬¬ä¸€è½®æ— æ”»å‡»');
    
    // ç»“æŸæ¸¸æˆ
    console.log('\nğŸ§ª ç»“æŸæ¸¸æˆ');
    game.state = 'gameover';
    game.endGame('dead');
    await sleep(1500);
    
    // è¿”å›ä¸»èœå•
    console.log('\nğŸ§ª è¿”å›ä¸»èœå•');
    game.returnToMainMenu();
    await sleep(1500);
    
    // ç¬¬äºŒè½®æ¸¸æˆ
    console.log('\nğŸ§ª ç¬¬äºŒè½®æ¸¸æˆï¼ˆé‡å¼€ï¼‰');
    document.getElementById('startGameBtn').click();
    await sleep(2000);
    
    const status = {
        timeScale: game.timeScale,
        lastT: game.lastT,
        weaponCd: game.weapons[0]?.cd
    };
    console.log('ğŸ§ª çŠ¶æ€:', status);
    
    const b3 = getBullets();
    console.log(`ğŸ§ª åˆå§‹å­å¼¹: ${b3}`);
    await sleep(5000);
    const b4 = getBullets();
    console.log(`ğŸ§ª 5ç§’åå­å¼¹: ${b4}`);
    
    // ç»“æœ
    console.log('\nğŸ§ª ========== æµ‹è¯•ç»“æœ ==========');
    if (b4 > b3) {
        console.log('âœ… æµ‹è¯•é€šè¿‡ï¼šé‡å¼€æ¸¸æˆåå¯ä»¥æ”»å‡»ï¼');
        document.body.style.background = '#0f4'; // ç»¿è‰²èƒŒæ™¯è¡¨ç¤ºé€šè¿‡
    } else {
        console.log('âŒ æµ‹è¯•å¤±è´¥ï¼šé‡å¼€æ¸¸æˆåä¸èƒ½æ”»å‡»ï¼');
        console.log(`   timeScale=${status.timeScale}, lastT=${status.lastT}, cd=${status.weaponCd}`);
        document.body.style.background = '#f04'; // çº¢è‰²èƒŒæ™¯è¡¨ç¤ºå¤±è´¥
    }
};
</script>
</body>
</html>
