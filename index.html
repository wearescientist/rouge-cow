<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è‚‰é¸½ç‰›ç‰› - v5.6 åœ°è„‰å…±é¸£</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        html, body { 
            width: 100%; 
            height: 100%; 
            background: #0a0a14; 
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameContainer {
            position: relative;
            width: 900px;
            height: 600px;
            max-width: 100vw;
            max-height: 100vh;
        }
        #gameCanvas { 
            display: block;
            width: 100%;
            height: 100%;
            background: #0d0d1a;
            border: 3px solid #333;
            border-radius: 8px;
        }
        #loading { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: #0a0a14; display: flex; flex-direction: column; 
            justify-content: center; align-items: center; z-index: 1000;
            transition: opacity 0.5s;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        .cow { font-size: 100px; animation: bounce 0.6s infinite alternate; }
        @keyframes bounce { from { transform: translateY(0) scale(1); } to { transform: translateY(-30px) scale(1.1); } }
        .loading-text { color: #4488ff; margin-top: 30px; font-size: 24px; font-family: Arial; }
        .loading-bar { width: 300px; height: 10px; background: #333; border-radius: 5px; margin-top: 20px; overflow: hidden; }
        .loading-progress { width: 0%; height: 100%; background: #4488ff; transition: width 0.3s; }
        .controls-hint { 
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #666; font-family: Arial; font-size: 14px; text-align: center;
            background: rgba(0,0,0,0.8); padding: 10px 20px; border-radius: 20px;
            z-index: 100;
        }
        
        /* ç§»åŠ¨ç«¯è™šæ‹ŸæŒ‰é’® */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            padding: 0 20px;
            z-index: 50;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
                justify-content: space-between;
                align-items: flex-end;
            }
            .controls-hint {
                display: none;
            }
        }
        
        .d-pad {
            position: relative;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }
        
        .d-btn {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: rgba(255,255,255,0.8);
            touch-action: manipulation;
        }
        
        .d-btn:active {
            background: rgba(255,255,255,0.4);
        }
        
        .d-btn.up { top: 0; left: 40px; }
        .d-btn.down { bottom: 0; left: 40px; }
        .d-btn.left { top: 40px; left: 0; }
        .d-btn.right { top: 40px; right: 0; }
        
        .action-btns {
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }
        
        .action-btn {
            width: 60px;
            height: 60px;
            background: rgba(255,100,100,0.3);
            border: 2px solid rgba(255,100,100,0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: rgba(255,255,255,0.9);
            touch-action: manipulation;
        }
        
        .action-btn:active {
            background: rgba(255,100,100,0.5);
        }
        
        .action-btn.weapon {
            background: rgba(100,150,255,0.3);
            border-color: rgba(100,150,255,0.5);
        }
        
        .action-btn.weapon:active {
            background: rgba(100,150,255,0.5);
        }
        .key { background: #333; color: #fff; padding: 2px 8px; border-radius: 4px; margin: 0 2px; }
    </style>
</head>
<body>
    <div id="loading">
        <div class="cow">ğŸ®</div>
        <div class="loading-text" id="loadingText">æ­£åœ¨åŠ è½½ç²¾çµå›¾èµ„æº...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="600"></canvas>
    </div>
    
    <div class="controls-hint">
        <span class="key">WASD</span>ç§»åŠ¨ 
        <span class="key">1-9</span>é“å…· 
        <span class="key">W</span>æ­¦å™¨ 
        <span class="key">F</span>å…¨å±
    </div>
    
    <!-- ç§»åŠ¨ç«¯è™šæ‹ŸæŒ‰é’® -->
    <div class="mobile-controls" id="mobileControls">
        <div class="d-pad">
            <div class="d-btn up" data-key="w">â–²</div>
            <div class="d-btn down" data-key="s">â–¼</div>
            <div class="d-btn left" data-key="a">â—€</div>
            <div class="d-btn right" data-key="d">â–¶</div>
        </div>
        <div class="action-btns">
            <div class="action-btn weapon" id="btnWeapon">âš”ï¸</div>
        </div>
    </div>

<script>
// ============================================================================
// è‚‰é¸½ç‰›ç‰› v2.0 - ç²¾çµå›¾ç‰ˆæœ¬
// ä¿®å¤ç”»é¢æ˜¾ç¤ºï¼Œæ·»åŠ ç²¾çµå›¾æ”¯æŒ
// ============================================================================

const $ = (fn) => fn();
const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
const dist = (x1, y1, x2, y2) => Math.sqrt((x2-x1)**2 + (y2-y1)**2);
const rand = (min, max) => Math.random() * (max - min) + min;
const randInt = (min, max) => Math.floor(rand(min, max));
const randChoice = (arr) => arr[Math.floor(Math.random() * arr.length)];

// ç²¾çµå›¾åŠ è½½å™¨ - v3.1 æ”¹è¿›ç‰ˆ
class SpriteLoader {
    constructor() {
        this.sprites = {};
        this.loaded = 0;
        this.total = 0;
        this.errors = [];
    }
    
    load(name, src) {
        this.total++;
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                this.sprites[name] = img;
                this.loaded++;
                console.log(`âœ“ Loaded: ${name}`);
                resolve(img);
            };
            
            img.onerror = () => {
                console.warn(`âœ— Failed to load: ${src}`);
                this.errors.push({ name, src });
                this.loaded++; // ä»ç„¶è®¡æ•°ä¸ºå·²å¤„ç†
                resolve(null);
            };
            
            // æ·»åŠ è¶…æ—¶å¤„ç†
            setTimeout(() => {
                if (!img.complete) {
                    console.warn(`â± Timeout: ${src}`);
                    this.errors.push({ name, src, timeout: true });
                    resolve(null);
                }
            }, 5000);
            
            img.src = src;
        });
    }
    
    get(name) {
        return this.sprites[name];
    }
    
    has(name) {
        return name in this.sprites;
    }
    
    isReady() {
        return this.loaded >= this.total;
    }
    
    getProgress() {
        return this.total > 0 ? this.loaded / this.total : 1;
    }
    
    getErrorCount() {
        return this.errors.length;
    }
}

// ç²’å­ç³»ç»Ÿ
class ParticleSystem {
    constructor(max = 200) {
        this.pool = Array(max).fill(null).map(() => ({
            x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 1,
            color: '#fff', size: 4, active: false
        }));
        this.active = [];
    }

    emit(x, y, color, opts = {}) {
        const p = this.pool.find(p => !p.active) || this.pool[0];
        p.x = x; p.y = y; p.color = color; p.active = true;
        p.life = opts.life || 1; p.maxLife = p.life;
        p.size = opts.size || 4;
        const speed = opts.speed || 100;
        const angle = opts.angle != null ? opts.angle : Math.random() * Math.PI * 2;
        p.vx = Math.cos(angle) * speed;
        p.vy = Math.sin(angle) * speed;
        if (!this.active.includes(p)) this.active.push(p);
    }

    burst(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
            this.emit(x, y, color, { 
                speed: rand(50, 150), 
                life: rand(0.3, 0.8),
                size: rand(2, 5)
            });
        }
    }

    update(dt) {
        for (let i = this.active.length - 1; i >= 0; i--) {
            const p = this.active[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt;
            if (p.life <= 0) {
                p.active = false;
                this.active.splice(i, 1);
            }
        }
    }

    draw(ctx) {
        for (const p of this.active) {
            const alpha = p.life / p.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
        }
        ctx.globalAlpha = 1;
    }
}

// éŸ³æ•ˆç³»ç»Ÿ - ä½¿ç”¨ Web Audio API
class SoundManager {
    constructor() {
        this.ctx = null;
        this.enabled = true;
        this.sounds = {};
    }
    
    init() {
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn('Web Audio API not supported');
            this.enabled = false;
        }
    }
    
    play(type) {
        if (!this.enabled || !this.ctx) return;
        
        // é¿å…éŸ³é¢‘ä¸Šä¸‹æ–‡è¢«æš‚åœ
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        switch(type) {
            case 'shoot':
                osc.frequency.value = 800;
                gain.gain.value = 0.1;
                osc.start();
                osc.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.stop(this.ctx.currentTime + 0.1);
                break;
            case 'hit':
                osc.frequency.value = 200;
                osc.type = 'square';
                gain.gain.value = 0.15;
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.stop(this.ctx.currentTime + 0.15);
                break;
            case 'kill':
                osc.frequency.value = 600;
                gain.gain.value = 0.2;
                osc.start();
                osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                osc.frequency.setValueAtTime(800, this.ctx.currentTime + 0.1);
                osc.frequency.setValueAtTime(1000, this.ctx.currentTime + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.stop(this.ctx.currentTime + 0.3);
                break;
            case 'levelup':
                osc.frequency.value = 400;
                gain.gain.value = 0.25;
                osc.start();
                for (let i = 0; i < 5; i++) {
                    osc.frequency.setValueAtTime(400 + i * 100, this.ctx.currentTime + i * 0.05);
                }
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.stop(this.ctx.currentTime + 0.5);
                break;
            case 'door':
                osc.frequency.value = 300;
                gain.gain.value = 0.2;
                osc.start();
                osc.frequency.exponentialRampToValueAtTime(600, this.ctx.currentTime + 0.3);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.stop(this.ctx.currentTime + 0.3);
                break;
            case 'damage':
                osc.frequency.value = 150;
                osc.type = 'sawtooth';
                gain.gain.value = 0.2;
                osc.start();
                osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.stop(this.ctx.currentTime + 0.2);
                break;
            case 'item':
                osc.frequency.value = 600;
                gain.gain.value = 0.15;
                osc.start();
                osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                osc.frequency.setValueAtTime(800, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.stop(this.ctx.currentTime + 0.2);
                break;
        }
    }
    
    toggle() {
        this.enabled = !this.enabled;
        return this.enabled;
    }
}

// é“å…·æ•°æ®åº“
const ITEMS = {
    1: { id: 1, name: 'å¤šé‡å°„å‡»', icon: 'ğŸ¯', rarity: 'common', effect: 'projCount', value: 1, desc: 'å­å¼¹+1' },
    2: { id: 2, name: 'å·¨å¤§åŒ–', icon: 'ğŸ“', rarity: 'common', effect: 'projSize', value: 0.3, desc: 'å­å¼¹å˜å¤§' },
    3: { id: 3, name: 'å¿«é€Ÿå°„å‡»', icon: 'âš¡', rarity: 'common', effect: 'fireRate', value: 0.15, desc: 'å°„é€Ÿ+15%' },
    4: { id: 4, name: 'ç©¿ç”²å¼¹', icon: 'ğŸ”©', rarity: 'rare', effect: 'pierce', value: 1, desc: 'ç©¿é€+1' },
    5: { id: 5, name: 'æš´å‡»é•œç‰‡', icon: 'ğŸ”', rarity: 'rare', effect: 'crit', value: 0.1, desc: 'æš´å‡»+10%' },
    6: { id: 6, name: 'å¿ƒä¹‹å®¹å™¨', icon: 'â¤ï¸', rarity: 'common', effect: 'maxHp', value: 2, desc: 'ç”Ÿå‘½+2' },
    7: { id: 7, name: 'é’¢é“æŠ¤ç”²', icon: 'ğŸ›¡ï¸', rarity: 'rare', effect: 'armor', value: 1, desc: 'æŠ¤ç”²+1' },
    8: { id: 8, name: 'å¸è¡€ç ç‰™', icon: 'ğŸ¦·', rarity: 'rare', effect: 'lifeSteal', value: 0.05, desc: 'å¸è¡€5%' },
    9: { id: 9, name: 'åŠ é€Ÿé´', icon: 'ğŸ‘Ÿ', rarity: 'common', effect: 'speed', value: 0.2, desc: 'ç§»é€Ÿ+20%' },
    10: { id: 10, name: 'é£è¡Œç¿…è†€', icon: 'ğŸ¦…', rarity: 'epic', effect: 'fly', value: 1, desc: 'å¯ä»¥é£è¡Œ' },
    11: { id: 11, name: 'ç£é“', icon: 'ğŸ§²', rarity: 'rare', effect: 'magnet', value: 50, desc: 'å¸èŒƒå›´+50' },
    12: { id: 12, name: 'é‡‘è›‹', icon: 'ğŸ¥š', rarity: 'epic', effect: 'goldBonus', value: 0.5, desc: 'é‡‘å¸+50%' },
    // v3.4 æ–°å¢
    13: { id: 13, name: 'ç«ç„°é™„é­”', icon: 'ğŸ”¥', rarity: 'rare', effect: 'fireDmg', value: 5, desc: 'ç«ç„°ä¼¤å®³+5' },
    14: { id: 14, name: 'å†°å†»æ ¸å¿ƒ', icon: 'â„ï¸', rarity: 'rare', effect: 'slow', value: 0.2, desc: 'å‡é€Ÿæ•Œäºº20%' },
    15: { id: 15, name: 'é›·ç”µå®ç ', icon: 'âš¡', rarity: 'epic', effect: 'chain', value: 1, desc: 'è¿é”æ”»å‡»+1' }
};

class ItemManager {
    constructor(player) {
        this.player = player;
        this.owned = {};
        this.cache = null;
        this.dirty = true;
    }

    add(id) {
        const item = ITEMS[id];
        if (!item) return false;
        this.owned[id] = (this.owned[id] || 0) + 1;
        this.dirty = true;
        
        if (item.effect === 'maxHp') {
            this.player.maxHp += item.value;
            this.player.hp += item.value;
        }
        return true;
    }

    getStats() {
        if (!this.dirty) return this.cache;
        
        const s = {
            projCount: 1, projSize: 1, fireRate: 1, pierce: 0,
            crit: 0, maxHp: 0, armor: 0, lifeSteal: 0,
            speed: 1, fly: false, magnet: 100, goldBonus: 1
        };
        
        for (const [id, count] of Object.entries(this.owned)) {
            const item = ITEMS[id];
            if (!item) continue;
            const v = item.value * count;
            
            switch (item.effect) {
                case 'projCount': s.projCount += v; break;
                case 'projSize': s.projSize += v; break;
                case 'fireRate': s.fireRate *= (1 + v); break;
                case 'pierce': s.pierce += v; break;
                case 'crit': s.crit = Math.min(1, s.crit + v); break;
                case 'maxHp': s.maxHp += v; break;
                case 'armor': s.armor += v; break;
                case 'lifeSteal': s.lifeSteal += v; break;
                case 'speed': s.speed += v; break;
                case 'fly': s.fly = true; break;
                case 'magnet': s.magnet += v; break;
                case 'goldBonus': s.goldBonus += v; break;
            }
        }
        
        this.cache = s;
        this.dirty = false;
        return s;
    }

    has(id) { return (this.owned[id] || 0) > 0; }
    count(id) { return this.owned[id] || 0; }
    getList() { return Object.entries(this.owned).map(([id, c]) => ({ ...ITEMS[id], count: c })).filter(x => x.name); }
}

// æ­¦å™¨ç³»ç»Ÿ
const WEAPONS = {
    whip: { key: 'whip', name: 'é­å­', icon: 'ğŸª„', dmg: 12, cd: 1.2, range: 80, type: 'melee', color: '#f60' },
    wand: { key: 'wand', name: 'é­”æ–', icon: 'ğŸ”®', dmg: 8, cd: 0.8, speed: 250, type: 'proj', color: '#48f' },
    knife: { key: 'knife', name: 'é£åˆ€', icon: 'ğŸ—¡ï¸', dmg: 6, cd: 0.5, speed: 350, pierce: 2, type: 'proj', color: '#ccc' },
    axe: { key: 'axe', name: 'æ–§å¤´', dmg: 15, cd: 1.5, speed: 200, type: 'proj', color: '#8b4513' }
};

class Weapon {
    constructor(key, level = 1) {
        this.cfg = WEAPONS[key];
        this.level = level;
        this.cd = 0;
        this.xp = 0;
        this.xpToNext = 100;
    }
    
    getDamage(stats) { return this.cfg.dmg * (1 + (this.level - 1) * 0.15) * stats.projSize; }
    
    update(dt) { this.cd -= dt; }
    canFire() { return this.cd <= 0; }
    
    addXp(amount) {
        this.xp += amount;
        if (this.xp >= this.xpToNext) {
            this.xp -= this.xpToNext;
            this.level++;
            this.xpToNext = Math.floor(this.xpToNext * 1.5);
            return true; // å‡çº§äº†
        }
        return false;
    }
    
    getLevelColor() {
        if (this.level >= 5) return '#f0f'; // ç´«è‰²
        if (this.level >= 3) return '#fa0'; // æ©™è‰²
        if (this.level >= 2) return '#0ff'; // é’è‰²
        return '#fff'; // ç™½è‰²
    }
    
    fire(player, target, stats) {
        this.cd = this.cfg.cd / stats.fireRate;
        const bullets = [];
        const count = Math.floor(stats.projCount);
        
        // è¿‘æˆ˜æ­¦å™¨ç‰¹æ®Šå¤„ç†
        if (this.cfg.type === 'melee') {
            // è¿‘æˆ˜æ­¦å™¨åˆ›å»ºä¸€ä¸ªç«‹å³ç”Ÿæ•ˆçš„å¼§å½¢æ”»å‡»
            const range = this.cfg.range || 80;
            const angle = target ? Math.atan2(target.y - player.y, target.x - player.x) : 0;
            
            bullets.push({
                x: player.x, y: player.y,
                vx: 0, vy: 0, // è¿‘æˆ˜å­å¼¹ä¸ç§»åŠ¨
                dmg: this.getDamage(stats),
                color: this.cfg.color,
                life: 0.1, // å¾ˆçŸ­çš„å­˜åœ¨æ—¶é—´
                pierce: 99, // æ— é™ç©¿é€
                type: 'melee',
                range: range,
                angle: angle,
                hits: new Set(),
                isMelee: true
            });
            return bullets;
        }
        
        // è¿œç¨‹æ­¦å™¨å‘å°„å­å¼¹
        for (let i = 0; i < count; i++) {
            let angle = 0;
            if (target) {
                angle = Math.atan2(target.y - player.y, target.x - player.x);
                if (count > 1) angle += (i - (count - 1) / 2) * 0.15;
            } else {
                angle = Math.random() * Math.PI * 2;
            }
            
            bullets.push({
                x: player.x, y: player.y,
                vx: Math.cos(angle) * (this.cfg.speed || 200),
                vy: Math.sin(angle) * (this.cfg.speed || 200),
                dmg: this.getDamage(stats),
                color: this.cfg.color,
                life: 3,
                pierce: (this.cfg.pierce || 0) + stats.pierce,
                type: this.cfg.type,
                range: this.cfg.range,
                hits: new Set()
            });
        }
        return bullets;
    }
}

// æ•Œäººé…ç½® - ä½¿ç”¨ç²¾çµå›¾/emoji
const ENEMY_TYPES = {
    // åŸºç¡€æ•Œäºº
    chick: { name: 'å˜å¼‚å°é¸¡', hp: 15, speed: 80, dmg: 1, exp: 2, color: '#ff6', sprite: 'chick', emoji: 'ğŸ¤' },
    pig: { name: 'å˜å¼‚å°çŒª', hp: 30, speed: 50, dmg: 2, exp: 4, color: '#f9c', sprite: 'pig', emoji: 'ğŸ·' },
    sheep: { name: 'å˜å¼‚å°ç¾Š', hp: 20, speed: 60, dmg: 1, exp: 3, color: '#eee', sprite: 'sheep', emoji: 'ğŸ‘' },
    dog: { name: 'ç–¯ç‹—', hp: 25, speed: 100, dmg: 2, exp: 5, color: '#963', sprite: 'dog', emoji: 'ğŸ•' },
    cat: { name: 'å˜å¼‚çŒ«', hp: 18, speed: 90, dmg: 1, exp: 3, color: '#fa3', sprite: 'cat', emoji: 'ğŸ±' },
    bear: { name: 'å·¨ç†Š', hp: 50, speed: 40, dmg: 3, exp: 8, color: '#630', sprite: 'bear', emoji: 'ğŸ»' },
    
    // æ•…äº‹ä¸­çš„ç‰¹æ®Šæ•Œäºº (v5.4æ–°å¢)
    tiaotiao: { 
        name: 'è·³è·³', hp: 40, speed: 120, dmg: 2, exp: 6, color: '#c85', sprite: 'rabbit', emoji: 'ğŸ¦˜',
        special: 'jump', // è·³è·ƒæ”»å‡»
        desc: 'è¢«å¯„ç”Ÿçš„è¢‹é¼ ï¼Œä»¥ä¸å¯èƒ½çš„è§’åº¦è·³è·ƒæ”»å‡»'
    },
    tiezhua: { 
        name: 'é“çˆª', hp: 35, speed: 150, dmg: 3, exp: 7, color: '#a52', sprite: 'bird', emoji: 'ğŸ¦…',
        special: 'dive', // ä¿¯å†²æ”»å‡»
        desc: 'ç¿…è†€é•¿æ»¡èŒä¸çš„é‡‘é›•ï¼Œé«˜é€Ÿä¿¯å†²'
    },
    nibei: { 
        name: 'æ³¥èƒŒ', hp: 80, speed: 30, dmg: 2, exp: 8, color: '#6a5', sprite: 'turtle', emoji: 'ğŸ¢',
        special: 'tank', // é«˜æŠ¤ç”²
        armor: 2,
        desc: 'èƒŒç”²å˜æˆå­µåŒ–åœºçš„è€è±¡é¾Ÿ'
    },
    yinya: { 
        name: 'é“¶ç‰™', hp: 45, speed: 90, dmg: 2, exp: 10, color: '#789', sprite: 'dog2', emoji: 'ğŸº',
        special: 'summon', // å¬å”¤å°å¼Ÿ
        desc: 'ç‹¼ç¾¤é¦–é¢†ï¼Œèƒ½å¬å”¤å…±ç”Ÿç‹¼ç¾¤'
    }
};

// BOSSé…ç½®
const BOSS_TYPES = {
    mother: {
        name: 'æ¯ä½“',
        hp: 500,
        speed: 30,
        dmg: 5,
        exp: 100,
        color: '#f0f',
        sprite: 'bear',
        scale: 2,
        phases: [
            { hpPercent: 100, behavior: 'normal' },
            { hpPercent: 70, behavior: 'enrage' },
            { hpPercent: 30, behavior: 'desperate' }
        ]
    }
};

class Enemy {
    constructor(x, y, typeKey) {
        const cfg = ENEMY_TYPES[typeKey] || ENEMY_TYPES.chick;
        this.x = x; this.y = y;
        this.typeKey = typeKey;
        this.cfg = cfg; // ä¿å­˜é…ç½®
        this.hp = cfg.hp + (cfg.armor || 0) * 10; // æŠ¤ç”²è½¬åŒ–ä¸ºé¢å¤–ç”Ÿå‘½
        this.maxHp = this.hp;
        this.speed = cfg.speed;
        this.dmg = cfg.dmg;
        this.exp = cfg.exp;
        this.color = cfg.color;
        this.sprite = cfg.sprite;
        this.emoji = cfg.emoji;
        this.special = cfg.special;
        this.armor = cfg.armor || 0;
        this.vx = 0; this.vy = 0;
        this.hitTimer = 0;
        this.attackCd = 0;
        this.specialCd = 0;
        this.isBoss = false;
    }

    update(dt, player, room) {
        const cfg = this.cfg;
        
        // ç‰¹æ®Šè¡Œä¸º
        if (this.special === 'jump' && this.specialCd <= 0) {
            // è·³è·³ï¼šå‘¨æœŸæ€§è·³è·ƒ
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d > 0 && d < 200) {
                // å‘ç©å®¶è·³è·ƒ
                this.vx = (dx / d) * this.speed * 2;
                this.vy = (dy / d) * this.speed * 2;
                this.specialCd = 2; // 2ç§’å†·å´
            }
        } else if (this.special === 'dive' && this.specialCd <= 0) {
            // é“çˆªï¼šä¿¯å†²æ”»å‡»
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d > 100 && d < 400) {
                // é«˜é€Ÿä¿¯å†²
                this.vx = (dx / d) * this.speed * 3;
                this.vy = (dy / d) * this.speed * 3;
                this.specialCd = 3;
            }
        } else {
            // æ™®é€šç§»åŠ¨
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            
            if (d > 0) {
                this.vx = (dx / d) * this.speed;
                this.vy = (dy / d) * this.speed;
            }
        }
        
        // æ³¥èƒŒï¼šé«˜æŠ¤ç”²å‡ä¼¤
        if (this.special === 'tank') {
            // ç§»åŠ¨æ›´æ…¢ä½†æ›´ç¨³å®š
            this.vx *= 0.8;
            this.vy *= 0.8;
        }
        
        // é“¶ç‰™ï¼šå¬å”¤å°å¼Ÿ
        if (this.special === 'summon' && this.specialCd <= 0 && room.enemies.length < 10) {
            this.specialCd = 5;
            // åœ¨å‘¨å›´ç”Ÿæˆä¸€ä¸ªå°ç‹¼
            const angle = Math.random() * Math.PI * 2;
            const r = 30;
            room.enemies.push(new Enemy(
                this.x + Math.cos(angle) * r,
                this.y + Math.sin(angle) * r,
                'dog' // å¬å”¤æ™®é€šç‹—
            ));
        }
        
        // ç®€å•åˆ†ç¦»
        for (const other of room.enemies) {
            if (other === this) continue;
            const odx = this.x - other.x;
            const ody = this.y - other.y;
            const od = Math.sqrt(odx*odx + ody*ody);
            if (od < 30 && od > 0) {
                this.vx += (odx / od) * 50;
                this.vy += (ody / od) * 50;
            }
        }
        
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        // è¾¹ç•Œ
        this.x = clamp(this.x, 50, 850);
        this.y = clamp(this.y, 50, 550);
        
        if (this.hitTimer > 0) this.hitTimer -= dt;
        if (this.attackCd > 0) this.attackCd -= dt;
        if (this.specialCd > 0) this.specialCd -= dt;
    }

    takeDamage(dmg) {
        // æŠ¤ç”²å‡ä¼¤
        const actualDmg = Math.max(1, dmg - this.armor);
        this.hp -= actualDmg;
        this.hitTimer = 0.1;
        return this.hp <= 0;
    }

    draw(ctx, sprites) {
        const size = this.isBoss ? 48 : 28; // ç¨å¾®å¤§ä¸€ç‚¹æ˜¾ç¤ºemoji
        
        // å—å‡»é—ªçƒ
        if (this.hitTimer > 0 && Math.floor(Date.now() / 50) % 2) {
            ctx.globalAlpha = 0.5;
        }
        
        // ç‰¹æ®Šæ•Œäººå…‰æ™•
        if (this.special) {
            ctx.strokeStyle = `rgba(255, 100, 100, ${0.3 + Math.sin(Date.now() / 300) * 0.2})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size + 8, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // BOSSå…‰æ™•
        if (this.isBoss) {
            ctx.strokeStyle = `rgba(255, 0, 255, ${0.3 + Math.sin(Date.now() / 200) * 0.2})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size + 10, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // ä¼˜å…ˆä½¿ç”¨emojiæ˜¾ç¤º
        if (this.emoji) {
            ctx.font = `${size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.emoji, this.x, this.y);
        } else {
            // å°è¯•ä½¿ç”¨ç²¾çµå›¾
            const sprite = sprites.get(this.sprite);
            if (sprite) {
                ctx.drawImage(sprite, this.x - size, this.y - size, size * 2, size * 2);
            } else {
                // å¤‡ç”¨ï¼šä½¿ç”¨emoji
                const emojiMap = {
                    chick: 'ğŸ¤', pig: 'ğŸ·', sheep: 'ğŸ‘', dog: 'ğŸ•',
                    cat: 'ğŸ±', bear: 'ğŸ»'
                };
                ctx.font = `${size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(emojiMap[this.sprite] || 'ğŸ‘¾', this.x, this.y);
            }
        }
        
        ctx.globalAlpha = 1;
        
        // è¡€æ¡
        if (this.hp < this.maxHp) {
            const barWidth = this.isBoss ? 100 : 28;
            ctx.fillStyle = '#000';
            ctx.fillRect(this.x - barWidth/2, this.y - size - 12, barWidth, 6);
            ctx.fillStyle = this.isBoss ? '#f0f' : '#f00';
            ctx.fillRect(this.x - barWidth/2, this.y - size - 12, barWidth * (this.hp / this.maxHp), 6);
        }
        
        // æŠ¤ç”²æ˜¾ç¤º
        if (this.armor > 0) {
            ctx.fillStyle = '#48f';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`+${this.armor}ğŸ›¡ï¸`, this.x, this.y - size - 18);
        }
        
        // åå­—æ˜¾ç¤ºï¼ˆç‰¹æ®Šæ•Œäººï¼‰
        if (this.special) {
            ctx.fillStyle = '#f88';
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(this.cfg.name, this.x, this.y + size + 12);
        }
        
        // BOSSåå­—
        if (this.isBoss) {
            ctx.fillStyle = '#f0f';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(this.cfg.name, this.x, this.y - size - 25);
        }
    }
}

// æˆ¿é—´ç±»
class Room {
    constructor(gx, gy, type = 'normal') {
        this.gx = gx; this.gy = gy;
        this.id = `${gx},${gy}`;
        this.type = type;
        this.doors = { up: null, down: null, left: null, right: null };
        this.enemies = [];
        this.cleared = type === 'start'; // èµ·ç‚¹æˆ¿é—´é»˜è®¤å·²æ¸…ç†
        this.visited = false;
        this.items = [];
        
        this.spawnEnemies();
    }

    spawnEnemies() {
        if (this.type === 'start') {
            console.log('Start room - no enemies');
            return;
        }
        
        if (this.type === 'boss') {
            // ç”ŸæˆBOSS
            console.log('Spawning BOSS');
            const bossCfg = BOSS_TYPES.mother;
            const boss = new Enemy(450, 200, 'bear'); // ä½¿ç”¨bearä½œä¸ºåŸºç¡€
            boss.name = bossCfg.name;
            boss.hp = bossCfg.hp;
            boss.maxHp = bossCfg.hp;
            boss.speed = bossCfg.speed;
            boss.dmg = bossCfg.dmg;
            boss.exp = bossCfg.exp;
            boss.color = bossCfg.color;
            boss.isBoss = true;
            boss.phase = 0;
            this.enemies.push(boss);
            return;
        }
        
        // ç‰¹æ®Šæˆ¿é—´ç”Ÿæˆç‰¹æ®Šæ•Œäºº
        if (this.type === 'treasure') {
            // å®ç®±æˆ¿æœ‰30%å‡ ç‡å‡ºç°ç‰¹æ®Šæ•Œäººå®ˆæŠ¤
            if (Math.random() < 0.3) {
                const specialTypes = ['tiaotiao', 'tiezhua', 'nibei', 'yinya'];
                const type = randChoice(specialTypes);
                this.enemies.push(new Enemy(450, 300, type));
                console.log(`å®ˆæŠ¤å®ç®±: ${ENEMY_TYPES[type].name}`);
                return; // åªæœ‰ä¸€ä¸ªå®ˆæŠ¤è€…
            }
        }
        
        const count = randInt(3, 7);
        const types = Object.keys(ENEMY_TYPES).filter(k => !ENEMY_TYPES[k].special); // åŸºç¡€æ•Œäºº
        
        console.log(`Spawning ${count} enemies in ${this.type} room`);
        
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const r = 150 + Math.random() * 100;
            const x = 450 + Math.cos(angle) * r;
            const y = 300 + Math.sin(angle) * r;
            
            // 10%å‡ ç‡ç”Ÿæˆç‰¹æ®Šæ•Œäººï¼ˆåœ¨æ·±å±‚ï¼‰
            if (Math.random() < 0.1 && (this.gx + this.gy) > 2) {
                const specialTypes = ['tiaotiao', 'tiezhua', 'nibei', 'yinya'];
                const type = randChoice(specialTypes);
                console.log(`  Spawning special ${type} at (${x.toFixed(0)}, ${y.toFixed(0)})`);
                this.enemies.push(new Enemy(x, y, type));
            } else {
                const typeKey = randChoice(types);
                console.log(`  Spawning ${typeKey} at (${x.toFixed(0)}, ${y.toFixed(0)})`);
                this.enemies.push(new Enemy(x, y, typeKey));
            }
        }
        
        console.log(`Total enemies: ${this.enemies.length}`);
    }

    draw(ctx) {
        // åœ°æ¿
        const floorColors = { start: '#1a1a2e', normal: '#16213e', boss: '#2d1b2e', treasure: '#1b2d1b' };
        ctx.fillStyle = floorColors[this.type] || '#16213e';
        ctx.fillRect(0, 0, 900, 600);
        
        // ç½‘æ ¼è£…é¥°
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1;
        for (let x = 0; x <= 900; x += 50) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, 600); ctx.stroke();
        }
        for (let y = 0; y <= 600; y += 50) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(900, y); ctx.stroke();
        }
        
        // å¢™å£
        ctx.fillStyle = '#0f0f1a';
        ctx.fillRect(0, 0, 900, 40);
        ctx.fillRect(0, 560, 900, 40);
        ctx.fillRect(0, 0, 40, 600);
        ctx.fillRect(860, 0, 40, 600);
        
        // é—¨
        for (const [dir, door] of Object.entries(this.doors)) {
            if (!door) continue;
            ctx.fillStyle = door.open ? '#4a4' : '#a44';
            const pos = { up: [420, 0, 60, 40], down: [420, 560, 60, 40], left: [0, 260, 40, 80], right: [860, 260, 40, 80] }[dir];
            ctx.fillRect(...pos);
        }
    }
}

// å›¾è…¾ç³»ç»Ÿ - æ°¸ä¹…å‡çº§
const TOTEMS = {
    1: { id: 1, name: 'å…ˆç¥–ä¹‹åŠ›', icon: 'ğŸ¦´', desc: 'æ”»å‡»åŠ›+10%', effect: 'dmg', value: 0.1 },
    2: { id: 2, name: 'åœ°è„‰å®ˆæŠ¤', icon: 'ğŸ›¡ï¸', desc: 'æœ€å¤§ç”Ÿå‘½+1', effect: 'maxHp', value: 1 },
    3: { id: 3, name: 'ç–¾é£æ­¥', icon: 'ğŸ‘Ÿ', desc: 'ç§»åŠ¨é€Ÿåº¦+10%', effect: 'speed', value: 0.1 },
    4: { id: 4, name: 'æ™ºæ…§ä¹‹çœ¼', icon: 'ğŸ‘ï¸', desc: 'ç»éªŒè·å–+20%', effect: 'exp', value: 0.2 },
    5: { id: 5, name: 'è´ªå©ªä¹‹æ‰‹', icon: 'ğŸ’°', desc: 'é‡‘å¸è·å–+25%', effect: 'gold', value: 0.25 },
    6: { id: 6, name: 'å†ç”Ÿä¹‹è¡€', icon: 'â¤ï¸', desc: 'ç”Ÿå‘½æ¢å¤+0.1/ç§’', effect: 'regen', value: 0.1 },
    7: { id: 7, name: 'å¹¸è¿æ˜Ÿ', icon: 'â­', desc: 'æš´å‡»ç‡+5%', effect: 'crit', value: 0.05 }
};

class TotemManager {
    constructor() {
        this.owned = new Set();
        this.load();
    }
    
    load() {
        // ä»æœ¬åœ°å­˜å‚¨åŠ è½½
        try {
            const saved = localStorage.getItem('rougecow_totems');
            if (saved) {
                this.owned = new Set(JSON.parse(saved));
            }
        } catch (e) {
            console.log('No saved totems');
        }
    }
    
    save() {
        try {
            localStorage.setItem('rougecow_totems', JSON.stringify([...this.owned]));
        } catch (e) {
            console.log('Failed to save totems');
        }
    }
    
    collect(id) {
        if (this.owned.has(id)) return false;
        this.owned.add(id);
        this.save();
        return true;
    }
    
    has(id) {
        return this.owned.has(id);
    }
    
    getCount() {
        return this.owned.size;
    }
    
    getBonus(effect) {
        let bonus = 0;
        for (const id of this.owned) {
            const totem = TOTEMS[id];
            if (totem && totem.effect === effect) {
                bonus += totem.value;
            }
        }
        return bonus;
    }
    
    getAllBonuses() {
        const bonuses = { dmg: 0, maxHp: 0, speed: 0, exp: 0, gold: 0, regen: 0, crit: 0 };
        for (const id of this.owned) {
            const totem = TOTEMS[id];
            if (totem) {
                bonuses[totem.effect] += totem.value;
            }
        }
        return bonuses;
    }
}

// ç‰›ç‰›ç‰¹æ®Šèƒ½åŠ› - åœ°è„‰å…±é¸£
class GeoResonance {
    constructor() {
        this.cd = 0;
        this.maxCd = 30; // 30ç§’å†·å´
        this.duration = 0;
        this.maxDuration = 3; // 3ç§’æŒç»­
        this.active = false;
    }
    
    activate() {
        if (this.cd > 0) return false;
        this.active = true;
        this.duration = this.maxDuration;
        this.cd = this.maxCd;
        return true;
    }
    
    update(dt) {
        if (this.cd > 0) this.cd -= dt;
        if (this.duration > 0) {
            this.duration -= dt;
            if (this.duration <= 0) {
                this.active = false;
            }
        }
    }
    
    getCdPercent() {
        return Math.max(0, 1 - this.cd / this.maxCd);
    }
    
    getDurationPercent() {
        return this.active ? this.duration / this.maxDuration : 0;
    }
}

// å›¾è…¾ç®¡ç†å™¨ç±»
class TotemManager {
    constructor() {
        this.owned = new Set();
        this.load();
    }
    
    load() {
        // ä»æœ¬åœ°å­˜å‚¨åŠ è½½
        try {
            const saved = localStorage.getItem('rougecow_totems');
            if (saved) {
                this.owned = new Set(JSON.parse(saved));
            }
        } catch (e) {
            console.log('No saved totems');
        }
    }
    
    save() {
        try {
            localStorage.setItem('rougecow_totems', JSON.stringify([...this.owned]));
        } catch (e) {
            console.log('Failed to save totems');
        }
    }
    
    collect(id) {
        if (this.owned.has(id)) return false;
        this.owned.add(id);
        this.save();
        return true;
    }
    
    has(id) {
        return this.owned.has(id);
    }
    
    getCount() {
        return this.owned.size;
    }
    
    getBonus(effect) {
        let bonus = 0;
        for (const id of this.owned) {
            const totem = TOTEMS[id];
            if (totem && totem.effect === effect) {
                bonus += totem.value;
            }
        }
        return bonus;
    }
    
    getAllBonuses() {
        const bonuses = { dmg: 0, maxHp: 0, speed: 0, exp: 0, gold: 0, regen: 0, crit: 0 };
        for (const id of this.owned) {
            const totem = TOTEMS[id];
            if (totem) {
                bonuses[totem.effect] += totem.value;
            }
        }
        return bonuses;
    }
}

class MapGenerator {
    generate() {
        const rooms = new Map();
        const start = new Room(0, 0, 'start');
        rooms.set(start.id, start);
        
        const queue = [start];
        const dirs = [
            { dx: 0, dy: -1, name: 'up', opp: 'down' },
            { dx: 1, dy: 0, name: 'right', opp: 'left' },
            { dx: 0, dy: 1, name: 'down', opp: 'up' },
            { dx: -1, dy: 0, name: 'left', opp: 'right' }
        ];
        
        let count = 1;
        while (queue.length && count < 12) {
            const cur = queue.shift();
            for (const dir of dirs.sort(() => Math.random() - 0.5)) {
                const nx = cur.gx + dir.dx, ny = cur.gy + dir.dy;
                const id = `${nx},${ny}`;
                
                if (rooms.has(id)) {
                    const ex = rooms.get(id);
                    if (!cur.doors[dir.name]) {
                        cur.doors[dir.name] = { open: cur.cleared, target: ex };
                        ex.doors[dir.opp] = { open: ex.cleared, target: cur };
                    }
                    continue;
                }
                
                if (Math.random() > 0.4 || count < 5) {
                    const type = count === 11 ? 'boss' : Math.random() < 0.2 ? 'treasure' : 'normal';
                    const nr = new Room(nx, ny, type);
                    cur.doors[dir.name] = { open: cur.cleared, target: nr };
                    nr.doors[dir.opp] = { open: nr.cleared, target: cur };
                    rooms.set(id, nr);
                    queue.push(nr);
                    count++;
                }
            }
        }
        
        return { start, rooms };
    }
}

// ============================================================================
// ä¸»æ¸¸æˆç±» v2.0
// ============================================================================
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // å›ºå®šç”»å¸ƒå¤§å°ï¼Œä½¿ç”¨CSSç¼©æ”¾
        this.canvas.width = 900;
        this.canvas.height = 600;
        
        // ç²¾çµå›¾åŠ è½½å™¨
        this.sprites = new SpriteLoader();
        
        // æ¸¸æˆçŠ¶æ€
        this.state = 'loading';
        this.player = { x: 450, y: 300, hp: 6, maxHp: 6, exp: 0, lv: 1, gold: 0 };
        this.items = new ItemManager(this.player);
        this.totems = new TotemManager(); // å›¾è…¾ç³»ç»Ÿ
        this.weapons = [new Weapon('whip', 1)];
        this.activeWeapon = 0; // å½“å‰æ¿€æ´»çš„æ­¦å™¨ç´¢å¼•
        this.bullets = [];
        this.particles = new ParticleSystem();
        this.gems = [];
        
        // åœ°å›¾
        const gen = new MapGenerator();
        const map = gen.generate();
        this.curRoom = map.start;
        this.allRooms = map.rooms;
        this.curRoom.visited = true;
        
        // ç³»ç»Ÿ
        this.keys = {};
        this.transition = { active: false, timer: 0, dir: null, target: null };
        this.rafId = null;
        
        // åœ°è„‰å…±é¸£èƒ½åŠ›
        this.resonance = new GeoResonance();
        
        // åŠ¨ç”»ç³»ç»Ÿ
        this.animations = {
            player: { frame: 0, timer: 0, speed: 0.15 },
            enemies: new Map()
        };
        
        // éŸ³æ•ˆç³»ç»Ÿ
        this.sounds = new SoundManager();
        
        this.setupInput();
    }

    async loadSprites() {
        // ä½¿ç”¨ç»å¯¹è·¯å¾„
        const basePath = 'https://wearescientist.github.io/rouge-cow/assets/sprites/';
        
        // åŠ è½½ä¸»è§’ç²¾çµå›¾
        await this.sprites.load('player', basePath + 'player_cow.png');
        
        // åŠ è½½æ•Œäººç²¾çµå›¾
        const enemies = ['chick', 'pig', 'sheep', 'dog', 'cat', 'bear'];
        for (const name of enemies) {
            await this.sprites.load(name, basePath + name + '.png');
            this.updateLoadingProgress();
        }
        
        // åŠ è½½ç‰¹æ®Šæ•Œäººç²¾çµå›¾ (v5.5)
        const specialEnemies = ['bird', 'turtle', 'rabbit', 'dog2'];
        for (const name of specialEnemies) {
            await this.sprites.load(name, basePath + name + '.png');
            this.updateLoadingProgress();
        }
        
        console.log(`âœ“ Loaded ${this.sprites.loaded}/${this.sprites.total} sprites`);
        if (this.sprites.getErrorCount() > 0) {
            console.warn(`âš  ${this.sprites.getErrorCount()} sprites failed to load`);
        }
    }
    
    updateLoadingProgress() {
        const progress = this.sprites.getProgress() * 100;
        const progressBar = document.getElementById('loadingProgress');
        const loadingText = document.getElementById('loadingText');
        if (progressBar) progressBar.style.width = `${progress}%`;
        if (loadingText) loadingText.textContent = `æ­£åœ¨åŠ è½½... ${Math.floor(progress)}%`;
    }

    setupInput() {
        window.addEventListener('keydown', e => {
            this.keys[e.key] = true;
            
            if (e.key >= '1' && e.key <= '9') {
                const id = parseInt(e.key);
                if (this.items.add(id)) {
                    this.particles.burst(this.player.x, this.player.y, '#ff0', 15);
                }
            }
            
            if (e.key === 'f' || e.key === 'F') {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }
            
            // æ­¦å™¨åˆ‡æ¢
            if (e.key === 'q' || e.key === 'Q') {
                this.activeWeapon = (this.activeWeapon - 1 + this.weapons.length) % this.weapons.length;
                console.log(`åˆ‡æ¢æ­¦å™¨: ${this.weapons[this.activeWeapon].cfg.name}`);
            }
            if (e.key === 'e' || e.key === 'E') {
                this.activeWeapon = (this.activeWeapon + 1) % this.weapons.length;
                console.log(`åˆ‡æ¢æ­¦å™¨: ${this.weapons[this.activeWeapon].cfg.name}`);
            }
            
            // åœ°è„‰å…±é¸£ - ç©ºæ ¼é”®
            if (e.key === ' ' || e.key === 'Spacebar') {
                if (this.resonance.activate()) {
                    console.log('åœ°è„‰å…±é¸£æ¿€æ´»ï¼');
                    this.particles.burst(this.player.x, this.player.y, '#ff0', 30);
                }
            }
        });
        
        window.addEventListener('keyup', e => this.keys[e.key] = false);
        
        // è§¦æ‘¸æ§åˆ¶
        this.setupTouchControls();
    }
    
    setupTouchControls() {
        const canvas = this.canvas;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchId = null;
        
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            if (touchId !== null) return;
            const touch = e.touches[0];
            touchId = touch.identifier;
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }, { passive: false });
        
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (touchId === null) return;
            
            const touch = Array.from(e.touches).find(t => t.identifier === touchId);
            if (!touch) return;
            
            const dx = touch.clientX - touchStartX;
            const dy = touch.clientY - touchStartY;
            const threshold = 20;
            
            this.keys['w'] = dy < -threshold;
            this.keys['s'] = dy > threshold;
            this.keys['a'] = dx < -threshold;
            this.keys['d'] = dx > threshold;
        }, { passive: false });
        
        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            const touch = Array.from(e.changedTouches).find(t => t.identifier === touchId);
            if (!touch) return;
            
            touchId = null;
            this.keys['w'] = false;
            this.keys['s'] = false;
            this.keys['a'] = false;
            this.keys['d'] = false;
        }, { passive: false });
        
        canvas.addEventListener('touchcancel', e => {
            e.preventDefault();
            touchId = null;
            this.keys['w'] = false;
            this.keys['s'] = false;
            this.keys['a'] = false;
            this.keys['d'] = false;
        }, { passive: false });
        
        // è™šæ‹ŸæŒ‰é’®æ§åˆ¶
        const dBtns = document.querySelectorAll('.d-btn');
        dBtns.forEach(btn => {
            const key = btn.dataset.key;
            
            btn.addEventListener('touchstart', e => {
                e.preventDefault();
                this.keys[key] = true;
                btn.style.background = 'rgba(255,255,255,0.4)';
            }, { passive: false });
            
            btn.addEventListener('touchend', e => {
                e.preventDefault();
                this.keys[key] = false;
                btn.style.background = '';
            }, { passive: false });
            
            btn.addEventListener('touchcancel', e => {
                e.preventDefault();
                this.keys[key] = false;
                btn.style.background = '';
            }, { passive: false });
        });
        
        // æ­¦å™¨åˆ‡æ¢æŒ‰é’®
        const weaponBtn = document.getElementById('btnWeapon');
        if (weaponBtn) {
            weaponBtn.addEventListener('touchstart', e => {
                e.preventDefault();
                this.activeWeapon = (this.activeWeapon + 1) % this.weapons.length;
                console.log(`åˆ‡æ¢æ­¦å™¨: ${this.weapons[this.activeWeapon].cfg.name}`);
                weaponBtn.style.background = 'rgba(100,150,255,0.5)';
                setTimeout(() => {
                    weaponBtn.style.background = '';
                }, 200);
            }, { passive: false });
        }
    }

    async start() {
        await this.loadSprites();
        this.sounds.init(); // åˆå§‹åŒ–éŸ³æ•ˆ
        document.getElementById('loading').classList.add('hidden');
        this.state = 'playing';
        this.loop(0);
    }

    update(dt) {
        if (this.transition.active) {
            this.transition.timer -= dt;
            if (this.transition.timer <= 0) {
                this.curRoom = this.transition.target;
                this.curRoom.visited = true;
                this.player.x = 450 + (this.transition.dir === 'left' ? 400 : this.transition.dir === 'right' ? -400 : 0);
                this.player.y = 300 + (this.transition.dir === 'up' ? 250 : this.transition.dir === 'down' ? -250 : 0);
                this.transition.active = false;
            }
            return;
        }

        const stats = this.items.getStats();
        
        // åº”ç”¨å›¾è…¾æ°¸ä¹…åŠ æˆ
        const totemBonuses = this.totems.getAllBonuses();
        stats.dmg = (stats.dmg || 1) * (1 + totemBonuses.dmg);
        stats.maxHp += totemBonuses.maxHp;
        stats.speed *= (1 + totemBonuses.speed);
        stats.crit = Math.min(1, stats.crit + totemBonuses.crit);
        
        const speed = 150 * stats.speed;
        
        // æ›´æ–°åœ°è„‰å…±é¸£
        this.resonance.update(dt);
        
        // ç©å®¶ç§»åŠ¨
        let dx = 0, dy = 0;
        if (this.keys['w'] || this.keys['W'] || this.keys['ArrowUp']) dy -= 1;
        if (this.keys['s'] || this.keys['S'] || this.keys['ArrowDown']) dy += 1;
        if (this.keys['a'] || this.keys['A'] || this.keys['ArrowLeft']) dx -= 1;
        if (this.keys['d'] || this.keys['D'] || this.keys['ArrowRight']) dx += 1;
        
        if (dx !== 0 || dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            this.player.x += (dx / len) * speed * dt;
            this.player.y += (dy / len) * speed * dt;
        }
        
        // è¾¹ç•Œ
        this.player.x = clamp(this.player.x, 20, 880);
        this.player.y = clamp(this.player.y, 20, 580);
        
        // é—¨æ£€æµ‹
        if (this.curRoom.cleared) {
            for (const [dir, door] of Object.entries(this.curRoom.doors)) {
                if (!door || !door.open) continue;
                const pos = { up: [420, 0, 60, 40], down: [420, 560, 60, 40], left: [0, 260, 40, 80], right: [860, 260, 40, 80] }[dir];
                if (this.player.x > pos[0] && this.player.x < pos[0] + pos[2] &&
                    this.player.y > pos[1] && this.player.y < pos[1] + pos[3]) {
                    this.transition = { active: true, timer: 0.3, dir, target: door.target };
                    break;
                }
            }
        }
        
        // æ•Œäºº
        for (const e of this.curRoom.enemies) {
            e.update(dt, this.player, this.curRoom);
            const d = dist(e.x, e.y, this.player.x, this.player.y);
            if (d < 25 && e.attackCd <= 0) {
                this.player.hp -= Math.max(0, e.dmg - stats.armor);
                e.attackCd = 0.5;
                this.sounds.play('damage');
                if (this.player.hp <= 0) this.state = 'gameover';
            }
        }
        
        if (this.curRoom.enemies.length === 0 && !this.curRoom.cleared) {
            this.curRoom.cleared = true;
            for (const door of Object.values(this.curRoom.doors)) {
                if (door) door.open = true;
            }
            this.particles.burst(450, 300, '#4f4', 30);
            this.sounds.play('door');
            
            // æ£€æŸ¥æ˜¯å¦å‡»è´¥äº†BOSS
            if (this.curRoom.type === 'boss') {
                this.state = 'victory';
                this.sounds.play('levelup');
                return;
            }
            
            // æˆ¿é—´æ¸…ç†åæ‰è½é“å…·
            this.spawnRoomReward();
        }
        
        // æ­¦å™¨ - åªä½¿ç”¨å½“å‰æ¿€æ´»çš„æ­¦å™¨
        let target = null, minD = 9999;
        for (const e of this.curRoom.enemies) {
            const d = dist(e.x, e.y, this.player.x, this.player.y);
            if (d < minD) { minD = d; target = e; }
        }
        
        // æ›´æ–°æ‰€æœ‰æ­¦å™¨CD
        for (const w of this.weapons) {
            w.update(dt);
        }
        
        // åªå‘å°„å½“å‰æ¿€æ´»çš„æ­¦å™¨
        const activeW = this.weapons[this.activeWeapon];
        if (activeW && activeW.canFire() && target) {
            this.bullets.push(...activeW.fire(this.player, target, stats));
            this.sounds.play('shoot');
        }
        
        // å­å¼¹
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            const b = this.bullets[i];
            
            // è¿‘æˆ˜å­å¼¹ä¸ç§»åŠ¨ï¼Œä½†æ£€æŸ¥èŒƒå›´å†…çš„æ•Œäºº
            if (b.isMelee) {
                b.life -= dt;
                if (b.life <= 0) { this.bullets.splice(i, 1); continue; }
                
                // å¯¹èŒƒå›´å†…çš„æ‰€æœ‰æ•Œäººé€ æˆä¼¤å®³
                for (let j = this.curRoom.enemies.length - 1; j >= 0; j--) {
                    const e = this.curRoom.enemies[j];
                    const d = dist(b.x, b.y, e.x, e.y);
                    // æ£€æŸ¥è§’åº¦èŒƒå›´ï¼ˆå¼§å½¢æ”»å‡»ï¼‰
                    const angleToEnemy = Math.atan2(e.y - b.y, e.x - b.x);
                    const angleDiff = Math.abs(angleToEnemy - b.angle);
                    const normalizedDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);
                    
                    if (d < b.range && normalizedDiff < Math.PI / 3 && !b.hits.has(e)) {
                        b.hits.add(e);
                        if (e.takeDamage(b.dmg)) {
                            this.curRoom.enemies.splice(j, 1);
                            this.gems.push({ x: e.x, y: e.y, v: e.exp, life: 30 });
                            this.particles.burst(e.x, e.y, e.color, 8);
                            this.sounds.play('kill');
                        } else {
                            this.sounds.play('hit');
                        }
                    }
                }
                continue;
            }
            
            // è¿œç¨‹å­å¼¹æ­£å¸¸ç§»åŠ¨
            b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
            
            if (b.life <= 0) { this.bullets.splice(i, 1); continue; }
            
            let hit = false;
            for (let j = this.curRoom.enemies.length - 1; j >= 0; j--) {
                const e = this.curRoom.enemies[j];
                if (dist(b.x, b.y, e.x, e.y) < 20 && !b.hits.has(e)) {
                    b.hits.add(e);
                    if (e.takeDamage(b.dmg)) {
                        this.curRoom.enemies.splice(j, 1);
                        this.gems.push({ x: e.x, y: e.y, v: e.exp, life: 30 });
                        this.particles.burst(e.x, e.y, e.color, 8);
                        this.sounds.play('kill');
                    } else {
                        this.sounds.play('hit');
                    }
                    if (b.pierce-- <= 0) { hit = true; break; }
                }
            }
            if (hit) this.bullets.splice(i, 1);
        }
        
        // ç»éªŒå®çŸ³
        for (let i = this.gems.length - 1; i >= 0; i--) {
            const g = this.gems[i];
            const d = dist(g.x, g.y, this.player.x, this.player.y);
            if (d < stats.magnet) {
                g.x += (this.player.x - g.x) * 5 * dt;
                g.y += (this.player.y - g.y) * 5 * dt;
            }
            if (d < 20) {
                this.player.exp += g.v;
                this.gems.splice(i, 1);
                if (this.player.exp >= this.player.lv * 100) {
                    this.player.exp -= this.player.lv * 100;
                    this.player.lv++;
                    this.player.maxHp++;
                    this.player.hp++;
                    this.particles.burst(this.player.x, this.player.y, '#ff0', 20);
                    this.sounds.play('levelup');
                }
            }
        }
        
        // æ‹¾å–é“å…·
        for (let i = this.curRoom.items.length - 1; i >= 0; i--) {
            const item = this.curRoom.items[i];
            const d = dist(item.x, item.y, this.player.x, this.player.y);
            
            if (d < 30) {
                if (item.type === 'weapon') {
                    // æ£€æŸ¥æ˜¯å¦å·²æœ‰åŒç±»å‹æ­¦å™¨
                    const existingIdx = this.weapons.findIndex(w => w.cfg.key === item.weaponKey);
                    if (existingIdx >= 0) {
                        // å‡çº§ç°æœ‰æ­¦å™¨
                        const leveledUp = this.weapons[existingIdx].addXp(100);
                        if (leveledUp) {
                            console.log(`æ­¦å™¨å‡çº§: ${item.name} Lv.${this.weapons[existingIdx].level}`);
                            this.particles.burst(item.x, item.y, '#f0f', 20);
                        } else {
                            console.log(`æ­¦å™¨ç»éªŒå¢åŠ : ${item.name}`);
                        }
                    } else if (this.weapons.length < 5) {
                        // æ·»åŠ æ–°æ­¦å™¨
                        this.weapons.push(new Weapon(item.weaponKey, 1));
                        console.log(`æ‹¾å–æ­¦å™¨: ${item.name}`);
                    }
                } else if (item.type === 'totem') {
                    // æ‹¾å–å›¾è…¾
                    if (this.totems.collect(item.totemId)) {
                        console.log(`æ”¶é›†å›¾è…¾: ${item.name}`);
                        this.particles.burst(item.x, item.y, '#ff0', 30);
                        // åº”ç”¨å›¾è…¾æ•ˆæœ
                        const totem = TOTEMS[item.totemId];
                        if (totem.effect === 'maxHp') {
                            this.player.maxHp += totem.value;
                            this.player.hp += totem.value;
                        }
                    } else {
                        console.log(`å·²æ‹¥æœ‰å›¾è…¾: ${item.name}`);
                    }
                } else {
                    // æ‹¾å–é“å…·
                    if (this.items.add(item.id)) {
                        console.log(`æ‹¾å–é“å…·: ${item.name}`);
                    }
                }
                this.curRoom.items.splice(i, 1);
                this.particles.burst(item.x, item.y, '#ff0', 10);
                this.sounds.play('item');
            }
        }
        
        this.particles.update(dt);
    }

    draw() {
        // æ¸…ç©º
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, 900, 600);
        
        // æˆ¿é—´
        this.curRoom.draw(this.ctx);
        
        // å®çŸ³
        for (const g of this.gems) {
            this.ctx.fillStyle = '#48f';
            this.ctx.beginPath();
            this.ctx.moveTo(g.x, g.y - 5);
            this.ctx.lineTo(g.x + 4, g.y);
            this.ctx.lineTo(g.x, g.y + 5);
            this.ctx.lineTo(g.x - 4, g.y);
            this.ctx.fill();
        }
        
        // å­å¼¹
        for (const b of this.bullets) {
            this.ctx.fillStyle = b.color;
            this.ctx.beginPath();
            this.ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // æˆ¿é—´é“å…·
        for (const item of this.curRoom.items) {
            this.ctx.fillStyle = '#ff0';
            this.ctx.font = '20px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(item.icon, item.x, item.y + 5);
            
            // å…‰æ™•æ•ˆæœ
            this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(item.x, item.y, 15 + Math.sin(Date.now() / 200) * 3, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        
        // æ•Œäºº
        for (const e of this.curRoom.enemies) {
            e.draw(this.ctx, this.sprites);
        }
        
        // åœ°è„‰å…±é¸£æ•ˆæœ - æ˜¾ç¤ºå…¨å›¾æ•Œäººä½ç½®
        if (this.resonance.active) {
            const ctx = this.ctx;
            
            // å±å¹•è¾¹ç¼˜è„‰åŠ¨æ•ˆæœ
            const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
            ctx.strokeStyle = `rgba(255, 215, 0, ${pulse})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, 900, 600);
            
            // ç‰›ç‰›åŒè§’å‘å…‰
            ctx.fillStyle = `rgba(255, 215, 0, ${pulse})`;
            ctx.beginPath();
            ctx.arc(this.player.x - 8, this.player.y - 12, 6, 0, Math.PI * 2);
            ctx.arc(this.player.x + 8, this.player.y - 12, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // æ˜¾ç¤ºæ‰€æœ‰æˆ¿é—´æ•Œäººä½ç½®ï¼ˆå°åœ°å›¾æ”¾å¤§æ•ˆæœï¼‰
            for (const [, room] of this.allRooms) {
                if (!room.visited || room === this.curRoom) continue;
                
                // è®¡ç®—ç›¸å¯¹ä½ç½®
                const dx = room.gx - this.curRoom.gx;
                const dy = room.gy - this.curRoom.gy;
                
                // åœ¨å±å¹•è¾¹ç¼˜æ˜¾ç¤ºæ–¹å‘æç¤º
                if (room.enemies.length > 0) {
                    const indicatorX = 450 + dx * 100;
                    const indicatorY = 300 + dy * 80;
                    
                    // é™åˆ¶åœ¨å±å¹•å†…
                    const clampedX = clamp(indicatorX, 50, 850);
                    const clampedY = clamp(indicatorY, 50, 550);
                    
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(clampedX, clampedY, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#f88';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${room.enemies.length}ğŸ‘¾`, clampedX, clampedY - 8);
                }
            }
        }
        
        // ç©å®¶ - ä½¿ç”¨ç²¾çµå›¾
        const playerSprite = this.sprites.get('player');
        if (playerSprite) {
            this.ctx.drawImage(playerSprite, this.player.x - 16, this.player.y - 16, 32, 32);
        } else {
            // å¤‡ç”¨emoji
            this.ctx.font = '24px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('ğŸ®', this.player.x, this.player.y + 8);
        }
        
        // ç²’å­
        this.particles.draw(this.ctx);
        
        // è½¬åœºé®ç½©
        if (this.transition.active) {
            const alpha = Math.sin(this.transition.timer / 0.3 * Math.PI);
            this.ctx.fillStyle = `rgba(0,0,0,${alpha})`;
            this.ctx.fillRect(0, 0, 900, 600);
        }
        
        // UI
        this.drawUI();
    }

    drawUI() {
        const ctx = this.ctx;
        const pad = 20;
        
        // çŠ¶æ€é¢æ¿
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(pad, pad, 180, 100);
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('â¤ï¸'.repeat(Math.max(0, Math.ceil(this.player.hp))), pad + 10, pad + 35);
        
        ctx.fillStyle = '#48f';
        ctx.fillText(`Lv.${this.player.lv} EXP:${Math.floor(this.player.exp)}/${this.player.lv*100}`, pad + 10, pad + 60);
        
        ctx.fillStyle = '#fc0';
        ctx.fillText(`ğŸ’° ${this.player.gold}`, pad + 10, pad + 85);
        
        // æˆ¿é—´ä¿¡æ¯
        ctx.textAlign = 'right';
        ctx.fillStyle = '#fff';
        const names = { start: 'èµ·ç‚¹', normal: 'æˆ˜æ–—', boss: 'BOSS', treasure: 'å®ç®±' };
        ctx.fillText(`${names[this.curRoom.type]}æˆ¿é—´`, 880, pad + 35);
        ctx.fillText(`æ•Œäºº:${this.curRoom.enemies.length}`, 880, pad + 60);
        
        if (!this.curRoom.cleared) {
            ctx.fillStyle = '#f44';
            ctx.fillText('ğŸ”’ é”å®š', 880, pad + 85);
        } else {
            ctx.fillStyle = '#4f4';
            ctx.fillText('âœ“ å·²æ¸…ç†', 880, pad + 85);
        }
        
        // å°åœ°å›¾
        const mx = 750, my = 120;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(mx, my, 130, 130);
        
        for (const [, r] of this.allRooms) {
            if (!r.visited) continue;
            const rx = mx + 10 + (r.gx + 5) * 10;
            const ry = my + 10 + (r.gy + 5) * 10;
            ctx.fillStyle = r === this.curRoom ? '#ff0' : { normal: '#666', boss: '#f00', treasure: '#0f0', start: '#66f' }[r.type];
            ctx.fillRect(rx, ry, 8, 8);
        }
        
        // æ­¦å™¨æ 
        const by = 530;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(pad, by, 300, 50);
        
        let wx = pad + 10;
        for (let i = 0; i < this.weapons.length; i++) {
            const w = this.weapons[i];
            // èƒŒæ™¯æ¡†
            ctx.fillStyle = i === this.activeWeapon ? '#444' : '#333';
            ctx.fillRect(wx, by + 5, 40, 40);
            
            // æ­¦å™¨å›¾æ ‡
            ctx.fillStyle = w.getLevelColor();
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(w.cfg.icon, wx + 20, by + 32);
            
            // ç­‰çº§æ˜¾ç¤º
            if (w.level > 1) {
                ctx.fillStyle = '#ff0';
                ctx.font = '10px Arial';
                ctx.fillText('+' + (w.level - 1), wx + 35, by + 15);
            }
            
            wx += 50;
        }
        
        // å›¾è…¾æ”¶é›†è¿›åº¦
        const totemCount = this.totems.getCount();
        if (totemCount > 0) {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(320, by, 120, 50);
            ctx.fillStyle = '#fc0';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`å›¾è…¾: ${totemCount}/7`, 380, by + 20);
            ctx.font = '12px Arial';
            ctx.fillStyle = '#aaa';
            ctx.fillText('æ°¸ä¹…åŠ æˆ', 380, by + 40);
        }
        
        // åœ°è„‰å…±é¸£å†·å´æ¡
        const resCd = this.resonance.getCdPercent();
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(450, by, 150, 50);
        ctx.fillStyle = '#333';
        ctx.fillRect(460, by + 30, 130, 10);
        if (resCd >= 1) {
            ctx.fillStyle = '#fd0'; // é‡‘è‰² - å‡†å¤‡å°±ç»ª
        } else if (this.resonance.active) {
            ctx.fillStyle = '#0f0'; // ç»¿è‰² - æ¿€æ´»ä¸­
        } else {
            ctx.fillStyle = '#666'; // ç°è‰² - å†·å´ä¸­
        }
        ctx.fillRect(460, by + 30, 130 * resCd, 10);
        ctx.fillStyle = '#fff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('åœ°è„‰å…±é¸£ [ç©ºæ ¼]', 525, by + 20);
        if (this.resonance.active) {
            ctx.fillStyle = '#0f0';
            ctx.fillText('æ¿€æ´»ä¸­!', 525, by + 48);
        } else if (resCd < 1) {
            ctx.fillStyle = '#888';
            ctx.fillText(`å†·å´: ${Math.ceil(this.resonance.cd)}s`, 525, by + 48);
        }
        
        // æ¸¸æˆç»“æŸ
        if (this.state === 'gameover') {
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, 900, 600);
            ctx.fillStyle = '#f44';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('æ¸¸æˆç»“æŸ', 450, 280);
            ctx.font = '24px Arial';
            ctx.fillStyle = '#fff';
            ctx.fillText(`åˆ°è¾¾å±‚æ•°: ${this.player.lv} | å‡»æ€: ${Array.from(this.allRooms.values()).reduce((a,r) => a + (r.cleared ? 1 : 0), 0)}`, 450, 340);
            ctx.fillText('æŒ‰ F5 é‡æ–°å¼€å§‹', 450, 380);
        }
        
        // èƒœåˆ©ç”»é¢
        if (this.state === 'victory') {
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, 900, 600);
            ctx.fillStyle = '#4f4';
            ctx.font = 'bold 56px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸ‰ èƒœåˆ©! ğŸ‰', 450, 260);
            ctx.font = '24px Arial';
            ctx.fillStyle = '#fff';
            ctx.fillText('ä½ å‡»è´¥äº†æ¯ä½“ï¼Œæ‹¯æ•‘äº†å†œåœº!', 450, 320);
            ctx.fillText(`æœ€ç»ˆç­‰çº§: ${this.player.lv} | æ­¦å™¨æ•°: ${this.weapons.length}`, 450, 360);
            ctx.fillText('æŒ‰ F5 å†æ¬¡æŒ‘æˆ˜', 450, 420);
        }
    }

    loop(t) {
        const dt = Math.min((t - (this.lastT || t)) / 1000, 0.1);
        this.lastT = t;
        
        if (this.state === 'playing' || this.transition.active) {
            this.update(dt);
        }
        this.draw();
        
        this.rafId = requestAnimationFrame(t => this.loop(t));
    }
    
    spawnRoomReward() {
        // æ ¹æ®æˆ¿é—´ç±»å‹å†³å®šå¥–åŠ±
        const roll = Math.random();
        
        if (this.curRoom.type === 'boss') {
            // Bossæˆ¿å¿…æ‰å›¾è…¾
            this.spawnTotemPickup();
            this.spawnWeaponPickup();
        } else if (this.curRoom.type === 'treasure') {
            // å®ç®±æˆ¿50%æ‰å›¾è…¾
            if (Math.random() < 0.5) {
                this.spawnTotemPickup();
            } else {
                this.spawnItemPickup();
            }
        } else if (roll < 0.15) {
            // æ™®é€šæˆ¿15%æ‰å›¾è…¾
            this.spawnTotemPickup();
        } else if (roll < 0.4) {
            // 25%æ‰é“å…·
            this.spawnItemPickup();
        } else if (roll < 0.6) {
            // 20%æ‰æ­¦å™¨
            this.spawnWeaponPickup();
        }
    }
    
    spawnTotemPickup() {
        const totemId = randInt(1, 8); // 1-7 å›¾è…¾ID
        const totem = TOTEMS[totemId];
        if (!totem) return;
        
        this.curRoom.items.push({
            x: 450,
            y: 300,
            type: 'totem',
            totemId: totemId,
            icon: totem.icon,
            name: totem.name
        });
        
        console.log(`æ‰è½å›¾è…¾: ${totem.name}`);
    }
    
    spawnItemPickup() {
        const itemId = randInt(1, 16); // 1-15 é“å…·ID
        const item = ITEMS[itemId];
        if (!item) return;
        
        this.curRoom.items.push({
            x: 450,
            y: 300,
            id: itemId,
            icon: item.icon,
            name: item.name
        });
        
        console.log(`æ‰è½é“å…·: ${item.name}`);
    }
    
    spawnWeaponPickup() {
        const wKeys = Object.keys(WEAPONS);
        const randKey = wKeys[Math.floor(Math.random() * wKeys.length)];
        
        this.curRoom.items.push({
            x: 450,
            y: 300,
            type: 'weapon',
            weaponKey: randKey,
            icon: WEAPONS[randKey].icon,
            name: WEAPONS[randKey].name
        });
        
        console.log(`æ‰è½æ­¦å™¨: ${WEAPONS[randKey].name}`);
    }
}

// å¯åŠ¨
window.onload = () => {
    const game = new Game();
    setTimeout(() => game.start(), 500);
};
</script>
</body>
</html>
