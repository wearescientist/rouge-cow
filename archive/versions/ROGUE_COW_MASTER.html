<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è‚‰é¸½ç‰›ç‰› v0.7.1 - ç›²çœ¼å•†åº—</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        html, body { width: 100%; height: 100%; background: #000; overflow: hidden; }
        #gameCanvas { display: block; }
        #ui { position: fixed; top: 0; left: 0; pointer-events: none; }
        #loading { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: #0a0a14; display: flex; flex-direction: column; 
            justify-content: center; align-items: center; z-index: 1000;
            transition: opacity 0.5s;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        .cow { font-size: 100px; animation: bounce 0.6s infinite alternate; }
        @keyframes bounce { from { transform: translateY(0) scale(1); } to { transform: translateY(-30px) scale(1.1); } }
        .loading-text { color: #4488ff; margin-top: 30px; font-size: 24px; font-family: Arial; }
        .controls-hint { 
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #666; font-family: Arial; font-size: 14px; text-align: center;
            background: rgba(0,0,0,0.8); padding: 10px 20px; border-radius: 20px;
        }
        .key { background: #333; color: #fff; padding: 2px 8px; border-radius: 4px; margin: 0 2px; }
    </style>
</head>
<body>
    <div id="loading">
        <div class="cow">ğŸ®</div>
        <div class="loading-text">æ­£åœ¨åˆå§‹åŒ–ç‰›ç‰›çš„å†’é™©... v0.7.1</div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div class="controls-hint">
        <span class="key">WASD</span>ç§»åŠ¨ 
        <span class="key">1-9</span>é“å…· 
        <span class="key">W</span>æ­¦å™¨ 
        <span class="key">E</span>äº’åŠ¨ 
        <span class="key">F</span>å…¨å±
    </div>

<script>
// ============================================================================
// è‚‰é¸½ç‰›ç‰› v0.7.1 - ç›²çœ¼NPCå•†åº—ç³»ç»Ÿ
// ============================================================================

const VERSION = 'v0.7.1';

// å·¥å…·å‡½æ•°
const $ = (fn) => fn();
const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
const dist = (x1, y1, x2, y2) => Math.sqrt((x2-x1)**2 + (y2-y1)**2);
const rand = (min, max) => Math.random() * (max - min) + min;
const randInt = (min, max) => Math.floor(rand(min, max));
const randChoice = (arr) => arr[Math.floor(Math.random() * arr.length)];

// å‘é‡ç±»
class Vec2 {
    constructor(x = 0, y = 0) { this.x = x; this.y = y; }
    add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
    mul(s) { return new Vec2(this.x * s, this.y * s); }
    len() { return Math.sqrt(this.x**2 + this.y**2); }
    norm() { const l = this.len(); return l > 0.001 ? new Vec2(this.x/l, this.y/l) : new Vec2(0, 0); }
    dist(v) { return Math.sqrt((this.x-v.x)**2 + (this.y-v.y)**2); }
    static fromAngle(a, len = 1) { return new Vec2(Math.cos(a) * len, Math.sin(a) * len); }
}

// ============================================================================
// ç²’å­ç³»ç»Ÿï¼ˆå¸¦å¯¹è±¡æ± ï¼‰
// ============================================================================
class ParticleSystem {
    constructor(max = 200) {
        this.pool = Array(max).fill(null).map(() => ({
            x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 1,
            color: '#fff', size: 4, active: false
        }));
        this.active = [];
    }

    emit(x, y, color, opts = {}) {
        const p = this.pool.find(p => !p.active) || this.pool[0];
        p.x = x; p.y = y; p.color = color; p.active = true;
        p.life = opts.life || 1; p.maxLife = p.life;
        p.size = opts.size || 4;
        const speed = opts.speed || 100;
        const angle = opts.angle != null ? opts.angle : Math.random() * Math.PI * 2;
        p.vx = Math.cos(angle) * speed;
        p.vy = Math.sin(angle) * speed;
        if (!this.active.includes(p)) this.active.push(p);
    }

    burst(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
            this.emit(x, y, color, { 
                speed: rand(50, 150), 
                life: rand(0.3, 0.8),
                size: rand(2, 5)
            });
        }
    }

    update(dt) {
        for (let i = this.active.length - 1; i >= 0; i--) {
            const p = this.active[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt;
            if (p.life <= 0) {
                p.active = false;
                this.active.splice(i, 1);
            }
        }
    }

    draw(ctx) {
        for (const p of this.active) {
            const alpha = p.life / p.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
        }
        ctx.globalAlpha = 1;
    }
}

// ============================================================================
// é“å…·æ•°æ®åº“ï¼ˆä¿®å¤ç‰ˆï¼‰
// ============================================================================
const ITEMS = {
    // æ”»å‡»ç±»
    1: { id: 1, name: 'å¤šé‡å°„å‡»', icon: 'ğŸ¯', rarity: 'common', effect: 'projCount', value: 1, desc: 'å­å¼¹+1', price: 50 },
    2: { id: 2, name: 'å·¨å¤§åŒ–', icon: 'ğŸ“', rarity: 'common', effect: 'projSize', value: 0.3, desc: 'å­å¼¹å˜å¤§', price: 40 },
    3: { id: 3, name: 'å¿«é€Ÿå°„å‡»', icon: 'âš¡', rarity: 'common', effect: 'fireRate', value: 0.15, desc: 'å°„é€Ÿ+15%', price: 60 },
    4: { id: 4, name: 'ç©¿ç”²å¼¹', icon: 'ğŸ”©', rarity: 'rare', effect: 'pierce', value: 1, desc: 'ç©¿é€+1', price: 100 },
    5: { id: 5, name: 'æš´å‡»é•œç‰‡', icon: 'ğŸ”', rarity: 'rare', effect: 'crit', value: 0.1, desc: 'æš´å‡»+10%', price: 120 },
    // é˜²å¾¡ç±»
    6: { id: 6, name: 'å¿ƒä¹‹å®¹å™¨', icon: 'â¤ï¸', rarity: 'common', effect: 'maxHp', value: 2, desc: 'ç”Ÿå‘½+2', price: 80 },
    7: { id: 7, name: 'é’¢é“æŠ¤ç”²', icon: 'ğŸ›¡ï¸', rarity: 'rare', effect: 'armor', value: 1, desc: 'æŠ¤ç”²+1', price: 150 },
    8: { id: 8, name: 'å¸è¡€ç ç‰™', icon: 'ğŸ¦·', rarity: 'rare', effect: 'lifeSteal', value: 0.05, desc: 'å¸è¡€5%', price: 130 },
    // ç§»åŠ¨ç±»
    9: { id: 9, name: 'åŠ é€Ÿé´', icon: 'ğŸ‘Ÿ', rarity: 'common', effect: 'speed', value: 0.2, desc: 'ç§»é€Ÿ+20%', price: 50 },
    10: { id: 10, name: 'é£è¡Œç¿…è†€', icon: 'ğŸ¦…', rarity: 'epic', effect: 'fly', value: 1, desc: 'å¯ä»¥é£è¡Œ', price: 200 },
    // ç‰¹æ®Š
    11: { id: 11, name: 'ç£é“', icon: 'ğŸ§²', rarity: 'rare', effect: 'magnet', value: 50, desc: 'å¸èŒƒå›´+50', price: 90 },
    12: { id: 12, name: 'é‡‘è›‹', icon: 'ğŸ¥š', rarity: 'epic', effect: 'goldBonus', value: 0.5, desc: 'é‡‘å¸+50%', price: 180 }
};

class ItemManager {
    constructor(player) {
        this.player = player;
        this.owned = {}; // id -> count
        this.cache = null;
        this.dirty = true;
    }

    add(id) {
        const item = ITEMS[id];
        if (!item) return false;
        this.owned[id] = (this.owned[id] || 0) + 1;
        this.dirty = true;
        
        // å³æ—¶æ•ˆæœ
        if (item.effect === 'maxHp') {
            this.player.maxHp += item.value;
            this.player.hp += item.value;
        }
        return true;
    }

    getStats() {
        if (!this.dirty) return this.cache;
        
        const s = {
            projCount: 1, projSize: 1, fireRate: 1, pierce: 0,
            crit: 0, maxHp: 0, armor: 0, lifeSteal: 0,
            speed: 1, fly: false, magnet: 100, goldBonus: 1
        };
        
        for (const [id, count] of Object.entries(this.owned)) {
            const item = ITEMS[id];
            if (!item) continue;
            const v = item.value * count;
            
            switch (item.effect) {
                case 'projCount': s.projCount += v; break;
                case 'projSize': s.projSize += v; break;
                case 'fireRate': s.fireRate *= (1 + v); break;
                case 'pierce': s.pierce += v; break;
                case 'crit': s.crit = Math.min(1, s.crit + v); break;
                case 'maxHp': s.maxHp += v; break;
                case 'armor': s.armor += v; break;
                case 'lifeSteal': s.lifeSteal += v; break;
                case 'speed': s.speed += v; break;
                case 'fly': s.fly = true; break;
                case 'magnet': s.magnet += v; break;
                case 'goldBonus': s.goldBonus += v; break;
            }
        }
        
        this.cache = s;
        this.dirty = false;
        return s;
    }

    has(id) { return (this.owned[id] || 0) > 0; }
    count(id) { return this.owned[id] || 0; }
    getList() { return Object.entries(this.owned).map(([id, c]) => ({ ...ITEMS[id], count: c })).filter(x => x.name); }
}

// ============================================================================
// æ­¦å™¨ç³»ç»Ÿï¼ˆä¿®å¤ç‰ˆï¼‰
// ============================================================================
const WEAPONS = {
    whip: { key: 'whip', name: 'é­å­', icon: 'ğŸª„', dmg: 12, cd: 1.2, range: 80, type: 'melee', color: '#f60' },
    wand: { key: 'wand', name: 'é­”æ–', icon: 'ğŸ”®', dmg: 8, cd: 0.8, speed: 250, type: 'proj', color: '#48f' },
    knife: { key: 'knife', name: 'é£åˆ€', icon: 'ğŸ—¡ï¸', dmg: 6, cd: 0.5, speed: 350, pierce: 2, type: 'proj', color: '#ccc' },
    axe: { key: 'axe', name: 'æ–§å¤´', icon: 'ğŸª“', dmg: 15, cd: 1.5, speed: 200, type: 'proj', color: '#8b4513' }
};

class Weapon {
    constructor(key, level = 1) {
        this.cfg = WEAPONS[key];
        this.level = level;
        this.cd = 0;
    }
    
    getDamage(stats) { return this.cfg.dmg * (1 + (this.level - 1) * 0.15) * stats.projSize; }
    
    update(dt) { this.cd -= dt; }
    canFire() { return this.cd <= 0; }
    
    fire(player, target, stats) {
        this.cd = this.cfg.cd / stats.fireRate;
        const bullets = [];
        const count = Math.floor(stats.projCount);
        
        for (let i = 0; i < count; i++) {
            let angle = 0;
            if (target) {
                angle = Math.atan2(target.y - player.y, target.x - player.x);
                if (count > 1) angle += (i - (count - 1) / 2) * 0.15;
            } else {
                angle = Math.random() * Math.PI * 2;
            }
            
            bullets.push({
                x: player.x, y: player.y,
                vx: Math.cos(angle) * (this.cfg.speed || 0),
                vy: Math.sin(angle) * (this.cfg.speed || 0),
                dmg: this.getDamage(stats),
                color: this.cfg.color,
                life: 3,
                pierce: (this.cfg.pierce || 0) + stats.pierce,
                type: this.cfg.type,
                range: this.cfg.range,
                hits: new Set()
            });
        }
        return bullets;
    }
}

// ============================================================================
// æ•Œäººç±»ï¼ˆä¿®å¤ç‰ˆï¼‰
// ============================================================================
class Enemy {
    constructor(x, y, config) {
        this.x = x; this.y = y;
        this.hp = config.hp;
        this.maxHp = config.hp;
        this.speed = config.speed;
        this.dmg = config.dmg;
        this.exp = config.exp;
        this.gold = config.gold || 0;
        this.color = config.color || '#f44';
        this.vx = 0; this.vy = 0;
        this.hitTimer = 0;
        this.attackCd = 0;
    }

    update(dt, player, room) {
        // å¯»è·¯
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const d = Math.sqrt(dx*dx + dy*dy);
        
        if (d > 0) {
            this.vx = (dx / d) * this.speed;
            this.vy = (dy / d) * this.speed;
        }
        
        // ç®€å•åˆ†ç¦»
        for (const other of room.enemies) {
            if (other === this) continue;
            const odx = this.x - other.x;
            const ody = this.y - other.y;
            const od = Math.sqrt(odx*odx + ody*ody);
            if (od < 30 && od > 0) {
                this.vx += (odx / od) * 50;
                this.vy += (ody / od) * 50;
            }
        }
        
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        // è¾¹ç•Œ
        this.x = clamp(this.x, 50, 850);
        this.y = clamp(this.y, 50, 550);
        
        // æ”»å‡»CD
        if (this.attackCd > 0) this.attackCd -= dt;
        if (this.hitTimer > 0) this.hitTimer -= dt;
    }

    takeDamage(amt) {
        this.hp -= amt;
        this.hitTimer = 0.2;
        return this.hp <= 0;
    }

    draw(ctx) {
        if (this.hitTimer > 0) {
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillRect(this.x - 15, this.y - 15, 30, 30);
        }
        
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - 12, this.y - 12, 24, 24);
        
        // è¡€æ¡
        if (this.hp < this.maxHp) {
            ctx.fillStyle = '#333';
            ctx.fillRect(this.x - 12, this.y - 20, 24, 4);
            ctx.fillStyle = this.hp / this.maxHp > 0.5 ? '#0f0' : '#f00';
            ctx.fillRect(this.x - 12, this.y - 20, 24 * (this.hp / this.maxHp), 4);
        }
    }
}

// ============================================================================
// å•†åº—NPCç±» - ç›²çœ¼é¼¹é¼ å•†äºº
// ============================================================================
class ShopNPC {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.icon = 'ğŸ¦”';
        this.name = 'ç›²çœ¼é¼¹é¼ å•†äºº';
        this.dialogues = [
            'é—»åˆ°äº†é‡‘å¸çš„å‘³é“...',
            'è¦ä¹°ç‚¹ä»€ä¹ˆå—ï¼Œé™Œç”Ÿäººï¼Ÿ',
            'æˆ‘çš„è´§ç‰©éƒ½æ˜¯å¥½è´§è‰²ï¼',
            'çœ‹ä¸è§ï¼Œä½†æˆ‘èƒ½æ„ŸçŸ¥åˆ°ä½ ...'
        ];
        this.currentDialogue = '';
        this.dialogueTimer = 0;
        this.shopItems = [];
        this.generateShopItems();
    }

    generateShopItems() {
        // éšæœºç”Ÿæˆ3ä¸ªå•†å“
        const itemIds = Object.keys(ITEMS).map(Number);
        const selected = [];
        while (selected.length < 3) {
            const id = randChoice(itemIds);
            if (!selected.includes(id)) {
                selected.push(id);
            }
        }
        this.shopItems = selected.map(id => ({
            ...ITEMS[id],
            sold: false
        }));
    }

    update(dt, player) {
        this.dialogueTimer -= dt;
        if (this.dialogueTimer <= 0) {
            this.currentDialogue = randChoice(this.dialogues);
            this.dialogueTimer = rand(3, 6);
        }
    }

    draw(ctx) {
        // ç»˜åˆ¶NPC
        ctx.font = '32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(this.icon, this.x, this.y + 10);
        
        // ç»˜åˆ¶åå­—
        ctx.font = '12px Arial';
        ctx.fillStyle = '#fc0';
        ctx.fillText(this.name, this.x, this.y - 25);
        
        // ç»˜åˆ¶å¯¹è¯æ°”æ³¡
        if (this.currentDialogue) {
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            const textWidth = ctx.measureText(this.currentDialogue).width;
            ctx.fillRect(this.x - textWidth/2 - 10, this.y - 65, textWidth + 20, 25);
            ctx.fillStyle = '#fff';
            ctx.fillText(this.currentDialogue, this.x, this.y - 48);
        }
        
        // äº’åŠ¨æç¤º
        ctx.font = '14px Arial';
        ctx.fillStyle = '#4f4';
        ctx.fillText('æŒ‰ E æ‰“å¼€å•†åº—', this.x, this.y + 35);
    }

    isNear(player) {
        return dist(this.x, this.y, player.x, player.y) < 60;
    }

    buyItem(index, player) {
        if (index < 0 || index >= this.shopItems.length) return { success: false, msg: 'æ— æ•ˆå•†å“' };
        const item = this.shopItems[index];
        if (item.sold) return { success: false, msg: 'å·²å”®ç½„' };
        if (player.gold < item.price) return { success: false, msg: 'é‡‘å¸ä¸è¶³' };
        
        player.gold -= item.price;
        item.sold = true;
        return { success: true, item: item };
    }
}

// ============================================================================
// æˆ¿é—´ç³»ç»Ÿï¼ˆä¿®å¤ç‰ˆï¼‰
// ============================================================================
class Room {
    constructor(x, y, type = 'normal') {
        this.gx = x; this.gy = y;
        this.type = type;
        this.id = `${x},${y}`;
        this.w = 900; this.h = 600;
        this.wall = 40;
        
        this.doors = { up: null, right: null, down: null, left: null };
        this.visited = false;
        this.cleared = false;
        this.enemies = [];
        this.obstacles = [];
        this.wave = 0;
        this.maxWave = type === 'boss' ? 3 : type === 'normal' ? 2 : 0;
        this.spawnTimer = 0;
        
        // å•†åº—æˆ¿é—´ç‰¹æ®Šå¤„ç†
        this.npc = null;
        if (type === 'shop') {
            this.npc = new ShopNPC(450, 250);
            this.cleared = true; // å•†åº—æˆ¿é—´ä¸éœ€è¦æˆ˜æ–—
        }
        
        // ç”Ÿæˆéšœç¢ç‰©
        const obsCount = type === 'boss' ? 5 : type === 'treasure' ? 2 : type === 'shop' ? 0 : randInt(2, 5);
        for (let i = 0; i < obsCount; i++) {
            this.obstacles.push({
                x: rand(100, 800), y: rand(100, 500),
                w: rand(30, 60), h: rand(30, 60)
            });
        }
    }

    update(dt, player, game) {
        if (!this.visited) return null;
        
        // æ›´æ–°NPC
        if (this.npc) {
            this.npc.update(dt, player);
        }
        
        if (this.cleared) return null;
        
        // æ›´æ–°æ•Œäºº
        const events = [];
        for (let i = this.enemies.length - 1; i >= 0; i--) {
            const e = this.enemies[i];
            e.update(dt, player, this);
            
            // ç¢°æ’ç©å®¶
            if (dist(e.x, e.y, player.x, player.y) < 25 && e.attackCd <= 0) {
                player.hp -= e.dmg;
                e.attackCd = 1;
                events.push({ type: 'player_hit' });
            }
            
            // æ­»äº¡
            if (e.hp <= 0) {
                events.push({ type: 'enemy_die', x: e.x, y: e.y, exp: e.exp, gold: e.gold });
                this.enemies.splice(i, 1);
            }
        }
        
        // åˆ·æ€ª
        if (this.wave < this.maxWave) {
            this.spawnTimer += dt;
            if (this.spawnTimer > 2) {
                this.spawnTimer = 0;
                this.wave++;
                const count = 2 + this.wave;
                for (let i = 0; i < count; i++) {
                    this.spawnEnemy(game);
                }
            }
        }
        
        // æ¸…ç†æ£€æŸ¥
        if (this.wave >= this.maxWave && this.enemies.length === 0 && !this.cleared) {
            this.cleared = true;
            this.openDoors();
            events.push({ type: 'room_clear' });
        }
        
        return events;
    }

    spawnEnemy(game) {
        const side = randInt(0, 4);
        let x, y;
        switch (side) {
            case 0: x = rand(50, 850); y = 60; break;
            case 1: x = 840; y = rand(50, 550); break;
            case 2: x = rand(50, 850); y = 540; break;
            case 3: x = 60; y = rand(50, 550); break;
        }
        
        const configs = {
            normal: [
                { hp: 10, speed: 40, dmg: 1, exp: 2, gold: 5, color: '#f88' },
                { hp: 15, speed: 60, dmg: 2, exp: 3, gold: 8, color: '#f44' }
            ],
            boss: [
                { hp: 50, speed: 30, dmg: 3, exp: 10, gold: 50, color: '#f00' }
            ]
        };
        const cfg = randChoice(configs[this.type] || configs.normal);
        this.enemies.push(new Enemy(x, y, cfg));
    }

    openDoors() {
        for (const d in this.doors) if (this.doors[d]) this.doors[d].open = true;
    }

    checkTransition(p) {
        const cx = this.w / 2, cy = this.h / 2;
        if (this.doors.up?.open && p.y < 60 && Math.abs(p.x - cx) < 40) return 'up';
        if (this.doors.down?.open && p.y > 540 && Math.abs(p.x - cx) < 40) return 'down';
        if (this.doors.left?.open && p.x < 60 && Math.abs(p.y - cy) < 40) return 'left';
        if (this.doors.right?.open && p.x > 840 && Math.abs(p.y - cy) < 40) return 'right';
        return null;
    }

    draw(ctx) {
        // åœ°æ¿
        const colors = { 
            normal: '#2a2a3e', 
            boss: '#3e1a1a', 
            treasure: '#1a3e1a', 
            start: '#2a3e2a',
            shop: '#3e2a1a'
        };
        ctx.fillStyle = colors[this.type] || colors.normal;
        ctx.fillRect(0, 0, this.w, this.h);
        
        // ç½‘æ ¼
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1;
        for (let x = 0; x < this.w; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, this.h); ctx.stroke(); }
        for (let y = 0; y < this.h; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(this.w, y); ctx.stroke(); }
        
        // å¢™å£
        ctx.fillStyle = this.cleared ? '#3a3a4e' : '#1a1a2e';
        const d = 40, cx = this.w / 2, cy = this.h / 2;
        // ä¸Šé—¨
        if (!this.doors.up?.open) { ctx.fillRect(0, 0, cx - 40, d); ctx.fillRect(cx + 40, 0, cx - 40, d); }
        else ctx.fillRect(0, 0, this.w, d);
        // ä¸‹é—¨
        if (!this.doors.down?.open) { ctx.fillRect(0, this.h - d, cx - 40, d); ctx.fillRect(cx + 40, this.h - d, cx - 40, d); }
        else ctx.fillRect(0, this.h - d, this.w, d);
        // å·¦é—¨
        if (!this.doors.left?.open) { ctx.fillRect(0, 0, d, cy - 40); ctx.fillRect(0, cy + 40, d, cy - 40); }
        else ctx.fillRect(0, 0, d, this.h);
        // å³é—¨
        if (!this.doors.right?.open) { ctx.fillRect(this.w - d, 0, d, cy - 40); ctx.fillRect(this.w - d, cy + 40, d, cy - 40); }
        else ctx.fillRect(this.w - d, 0, d, this.h);
        
        // éšœç¢ç‰©
        for (const o of this.obstacles) {
            ctx.fillStyle = '#444';
            ctx.fillRect(o.x - o.w/2, o.y - o.h/2, o.w, o.h);
            ctx.fillStyle = '#555';
            ctx.fillRect(o.x - o.w/2 + 3, o.y - o.h/2 + 3, o.w - 6, o.h - 6);
        }
        
        // NPC
        if (this.npc) this.npc.draw(ctx);
        
        // æ•Œäºº
        for (const e of this.enemies) e.draw(ctx);
        
        // é”å®šå›¾æ ‡
        if (!this.cleared && this.enemies.length > 0) {
            ctx.fillStyle = '#f44';
            ctx.font = '20px Arial';
            ctx.fillText('ğŸ”’', cx, d + 30);
        }
    }
}

class MapGenerator {
    generate() {
        const rooms = new Map();
        const start = new Room(0, 0, 'start');
        rooms.set(start.id, start);
        
        const queue = [start];
        const dirs = [
            { dx: 0, dy: -1, name: 'up', opp: 'down' },
            { dx: 1, dy: 0, name: 'right', opp: 'left' },
            { dx: 0, dy: 1, name: 'down', opp: 'up' },
            { dx: -1, dy: 0, name: 'left', opp: 'right' }
        ];
        
        let count = 1;
        let shopPlaced = false;
        
        while (queue.length && count < 12) {
            const cur = queue.shift();
            for (const dir of dirs.sort(() => Math.random() - 0.5)) {
                const nx = cur.gx + dir.dx, ny = cur.gy + dir.dy;
                const id = `${nx},${ny}`;
                
                if (rooms.has(id)) {
                    const ex = rooms.get(id);
                    if (!cur.doors[dir.name]) {
                        cur.doors[dir.name] = { open: false, target: ex };
                        ex.doors[dir.opp] = { open: false, target: cur };
                    }
                    continue;
                }
                
                if (Math.random() > 0.4 || count < 5) {
                    let type = 'normal';
                    if (count === 11) type = 'boss';
                    else if (!shopPlaced && count > 3 && Math.random() < 0.3) {
                        type = 'shop';
                        shopPlaced = true;
                    } else if (Math.random() < 0.2) type = 'treasure';
                    
                    const nr = new Room(nx, ny, type);
                    cur.doors[dir.name] = { open: false, target: nr };
                    nr.doors[dir.opp] = { open: false, target: cur };
                    rooms.set(id, nr);
                    queue.push(nr);
                    count++;
                }
            }
        }
        
        return { start, rooms };
    }
}

// ============================================================================
// ä¸»æ¸¸æˆç±»ï¼ˆå®Œå…¨é‡æ„ï¼‰
// ============================================================================
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // æ¸¸æˆçŠ¶æ€
        this.state = 'loading'; // loading, playing, paused, gameover, shop
        this.player = { x: 450, y: 300, hp: 6, maxHp: 6, exp: 0, lv: 1, gold: 100 };
        this.items = new ItemManager(this.player);
        this.weapons = [new Weapon('whip', 1)];
        this.bullets = [];
        this.particles = new ParticleSystem();
        this.gems = []; // ç»éªŒå®çŸ³
        this.coins = []; // é‡‘å¸
        
        // åœ°å›¾
        const gen = new MapGenerator();
        const map = gen.generate();
        this.curRoom = map.start;
        this.allRooms = map.rooms;
        this.curRoom.visited = true;
        
        // å•†åº—UI
        this.shopUI = {
            visible: false,
            selectedIndex: -1,
            msg: '',
            msgTimer: 0
        };
        
        // ç³»ç»Ÿ
        this.keys = {};
        this.keysPressed = {}; // ç”¨äºæ£€æµ‹å•æ¬¡æŒ‰é”®
        this.transition = { active: false, timer: 0, dir: null, target: null };
        this.rafId = null;
        
        this.setupInput();
    }

    resize() {
        const w = window.innerWidth, h = window.innerHeight;
        const targetRatio = 900 / 600;
        const actualRatio = w / h;
        
        if (actualRatio > targetRatio) {
            this.canvas.height = h;
            this.canvas.width = h * targetRatio;
        } else {
            this.canvas.width = w;
            this.canvas.height = w / targetRatio;
        }
        
        this.scale = this.canvas.width / 900;
        this.offsetX = (w - this.canvas.width) / 2;
        this.offsetY = (h - this.canvas.height) / 2;
    }

    setupInput() {
        window.addEventListener('keydown', e => {
            this.keys[e.key] = true;
            
            // å•†åº—ç•Œé¢æŒ‰é”®
            if (this.shopUI.visible) {
                if (e.key >= '1' && e.key <= '3') {
                    this.buyItem(parseInt(e.key) - 1);
                }
                if (e.key === 'Escape' || e.key === 'e' || e.key === 'E') {
                    this.closeShop();
                }
                return;
            }
            
            // æ™®é€šæ¸¸æˆæŒ‰é”®
            if (e.key >= '1' && e.key <= '9') {
                const id = parseInt(e.key);
                if (this.items.add(id)) {
                    const item = ITEMS[id];
                    this.particles.burst(this.player.x, this.player.y, item.rarity === 'legendary' ? '#fc0' : '#48f', 20);
                }
            }
            if (e.key === '0') {
                const id = randInt(1, 13);
                if (this.items.add(id)) {
                    this.particles.burst(this.player.x, this.player.y, '#48f', 20);
                }
            }
            if (e.key === 'w' || e.key === 'W') {
                const keys = Object.keys(WEAPONS);
                const k = randChoice(keys);
                const ex = this.weapons.find(w => w.cfg.key === k);
                if (ex) ex.level++;
                else this.weapons.push(new Weapon(k, 1));
            }
            if (e.key === 'f' || e.key === 'F') {
                if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                else document.exitFullscreen();
            }
            if ((e.key === 'e' || e.key === 'E') && !this.keysPressed['e']) {
                this.keysPressed['e'] = true;
                this.interact();
            }
            // æ— æ•Œæ¨¡å¼è°ƒè¯•é”®
            if (e.key === 'g' || e.key === 'G') {
                this.player.gold += 100;
            }
        });
        
        window.addEventListener('keyup', e => {
            this.keys[e.key] = false;
            if (e.key === 'e' || e.key === 'E') {
                this.keysPressed['e'] = false;
            }
        });
    }

    interact() {
        // æ£€æŸ¥æ˜¯å¦åœ¨å•†åº—æˆ¿é—´ä¸”é è¿‘NPC
        if (this.curRoom.type === 'shop' && this.curRoom.npc) {
            if (this.curRoom.npc.isNear(this.player)) {
                this.openShop();
            }
        }
    }

    openShop() {
        this.shopUI.visible = true;
        this.shopUI.selectedIndex = -1;
        this.shopUI.msg = '';
        this.state = 'shop';
    }

    closeShop() {
        this.shopUI.visible = false;
        this.state = 'playing';
    }

    buyItem(index) {
        if (!this.curRoom.npc) return;
        const result = this.curRoom.npc.buyItem(index, this.player);
        if (result.success) {
            this.items.add(result.item.id);
            this.particles.burst(this.player.x, this.player.y, '#fc0', 15);
            this.shopUI.msg = `è´­ä¹°äº† ${result.item.icon} ${result.item.name}ï¼`;
        } else {
            this.shopUI.msg = result.msg;
        }
        this.shopUI.msgTimer = 2;
    }

    start() {
        document.getElementById('loading').classList.add('hidden');
        this.state = 'playing';
        this.loop(0);
    }

    update(dt) {
        if (this.shopUI.visible) {
            this.shopUI.msgTimer -= dt;
            if (this.shopUI.msgTimer <= 0) this.shopUI.msg = '';
            return;
        }
        
        if (this.state !== 'playing') return;
        
        // è½¬åœº
        if (this.transition.active) {
            this.transition.timer += dt;
            if (this.transition.timer > 0.3) {
                this.curRoom = this.transition.target;
                this.curRoom.visited = true;
                this.bullets = [];
                this.gems = [];
                this.coins = [];
                // æ”¾ç½®ç©å®¶
                const pos = { up: [450, 550], down: [450, 50], left: [850, 300], right: [50, 300] };
                const opposite = { up: 'down', down: 'up', left: 'right', right: 'left' };
                [this.player.x, this.player.y] = pos[opposite[this.transition.dir]];
                this.transition.active = false;
            }
            return;
        }
        
        const stats = this.items.getStats();
        
        // ç©å®¶ç§»åŠ¨
        let vx = 0, vy = 0;
        if (this.keys['w'] || this.keys['ArrowUp']) vy -= 1;
        if (this.keys['s'] || this.keys['ArrowDown']) vy += 1;
        if (this.keys['a'] || this.keys['ArrowLeft']) vx -= 1;
        if (this.keys['d'] || this.keys['ArrowRight']) vx += 1;
        
        if (vx !== 0 || vy !== 0) {
            const len = Math.sqrt(vx*vx + vy*vy);
            vx /= len; vy /= len;
            this.player.x += vx * 150 * stats.speed * dt;
            this.player.y += vy * 150 * stats.speed * dt;
        }
        
        // è¾¹ç•Œ
        this.player.x = clamp(this.player.x, 50, 850);
        this.player.y = clamp(this.player.y, 50, 550);
        
        // æˆ¿é—´æ›´æ–°
        const events = this.curRoom.update(dt, this.player, this);
        if (events) {
            for (const ev of events) {
                if (ev.type === 'enemy_die') {
                    this.gems.push({ x: ev.x, y: ev.y, v: ev.exp, life: 30 });
                    // æ‰è½é‡‘å¸
                    const goldAmount = Math.floor(ev.gold * stats.goldBonus);
                    for (let i = 0; i < Math.min(goldAmount, 5); i++) {
                        this.coins.push({
                            x: ev.x + rand(-20, 20),
                            y: ev.y + rand(-20, 20),
                            v: Math.max(1, Math.floor(goldAmount / Math.min(goldAmount, 5))),
                            life: 30
                        });
                    }
                    this.particles.burst(ev.x, ev.y, '#fc0', 8);
                }
                if (ev.type === 'player_hit') {
                    this.particles.burst(this.player.x, this.player.y, '#f00', 5);
                }
                if (ev.type === 'room_clear') {
                    // ç»™äºˆå¥–åŠ±
                    this.player.gold += 20;
                }
            }
        }
        
        // é—¨ä¼ é€
        const door = this.curRoom.checkTransition(this.player);
        if (door && this.curRoom.cleared && !this.transition.active) {
            this.transition.active = true;
            this.transition.timer = 0;
            this.transition.dir = door;
            this.transition.target = this.curRoom.doors[door].target;
        }
        
        // æ­¦å™¨
        let target = null, minD = 9999;
        for (const e of this.curRoom.enemies) {
            const d = dist(e.x, e.y, this.player.x, this.player.y);
            if (d < minD) { minD = d; target = e; }
        }
        
        for (const w of this.weapons) {
            w.update(dt);
            if (w.canFire() && target) {
                this.bullets.push(...w.fire(this.player, target, stats));
            }
        }
        
        // å­å¼¹
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            const b = this.bullets[i];
            b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
            
            if (b.life <= 0) { this.bullets.splice(i, 1); continue; }
            
            // ç¢°æ’æ•Œäºº
            let hit = false;
            for (let j = this.curRoom.enemies.length - 1; j >= 0; j--) {
                const e = this.curRoom.enemies[j];
                if (dist(b.x, b.y, e.x, e.y) < 20 && !b.hits.has(e)) {
                    b.hits.add(e);
                    if (e.takeDamage(b.dmg)) {
                        this.curRoom.enemies.splice(j, 1);
                        this.gems.push({ x: e.x, y: e.y, v: e.exp, life: 30 });
                        // æ‰è½é‡‘å¸
                        const goldAmount = Math.floor(e.gold * stats.goldBonus);
                        for (let k = 0; k < Math.min(goldAmount, 3); k++) {
                            this.coins.push({
                                x: e.x + rand(-20, 20),
                                y: e.y + rand(-20, 20),
                                v: Math.max(1, Math.floor(goldAmount / Math.min(goldAmount, 3))),
                                life: 30
                            });
                        }
                    }
                    if (b.pierce-- <= 0) { hit = true; break; }
                }
            }
            if (hit) this.bullets.splice(i, 1);
        }
        
        // ç»éªŒå®çŸ³
        for (let i = this.gems.length - 1; i >= 0; i--) {
            const g = this.gems[i];
            const d = dist(g.x, g.y, this.player.x, this.player.y);
            if (d < stats.magnet) {
                g.x += (this.player.x - g.x) * 5 * dt;
                g.y += (this.player.y - g.y) * 5 * dt;
            }
            if (d < 20) {
                this.player.exp += g.v;
                this.gems.splice(i, 1);
                // å‡çº§æ£€æŸ¥
                if (this.player.exp >= this.player.lv * 100) {
                    this.player.exp -= this.player.lv * 100;
                    this.player.lv++;
                    this.player.maxHp++;
                    this.player.hp++;
                }
            }
        }
        
        // é‡‘å¸
        for (let i = this.coins.length - 1; i >= 0; i--) {
            const c = this.coins[i];
            const d = dist(c.x, c.y, this.player.x, this.player.y);
            if (d < stats.magnet) {
                c.x += (this.player.x - c.x) * 5 * dt;
                c.y += (this.player.y - c.y) * 5 * dt;
            }
            if (d < 20) {
                this.player.gold += c.v;
                this.coins.splice(i, 1);
            }
        }
        
        this.particles.update(dt);
    }

    draw() {
        // èƒŒæ™¯
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.save();
        this.ctx.translate(this.offsetX, this.offsetY);
        this.ctx.scale(this.scale, this.scale);
        
        // æˆ¿é—´
        this.curRoom.draw(this.ctx);
        
        // å®çŸ³
        for (const g of this.gems) {
            this.ctx.fillStyle = '#48f';
            this.ctx.beginPath();
            this.ctx.moveTo(g.x, g.y - 5);
            this.ctx.lineTo(g.x + 4, g.y);
            this.ctx.lineTo(g.x, g.y + 5);
            this.ctx.lineTo(g.x - 4, g.y);
            this.ctx.fill();
        }
        
        // é‡‘å¸
        for (const c of this.coins) {
            this.ctx.fillStyle = '#fc0';
            this.ctx.beginPath();
            this.ctx.arc(c.x, c.y, 4, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.fillStyle = '#ff0';
            this.ctx.beginPath();
            this.ctx.arc(c.x - 1, c.y - 1, 2, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // å­å¼¹
        for (const b of this.bullets) {
            this.ctx.fillStyle = b.color;
            this.ctx.beginPath();
            this.ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // ç©å®¶
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '24px Arial';
        this.ctx.fillText('ğŸ®', this.player.x - 12, this.player.y + 8);
        
        // ç²’å­
        this.particles.draw(this.ctx);
        
        // è½¬åœºé®ç½©
        if (this.transition.active) {
            const alpha = Math.sin(this.transition.timer / 0.3 * Math.PI);
            this.ctx.fillStyle = `rgba(0,0,0,${alpha})`;
            this.ctx.fillRect(0, 0, 900, 600);
        }
        
        this.ctx.restore();
        
        // UIï¼ˆå±å¹•åæ ‡ï¼‰
        this.drawUI();
        
        // å•†åº—UI
        if (this.shopUI.visible) {
            this.drawShopUI();
        }
    }

    drawUI() {
        const ctx = this.ctx;
        const pad = 20;
        
        // ç‰ˆæœ¬å·
        ctx.fillStyle = '#666';
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(VERSION, pad, this.canvas.height - 10);
        
        // çŠ¶æ€é¢æ¿
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(pad, pad, 180, 100);
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('â¤ï¸'.repeat(Math.max(0, Math.ceil(this.player.hp))), pad + 10, pad + 35);
        
        ctx.fillStyle = '#48f';
        ctx.fillText(`Lv.${this.player.lv} EXP:${Math.floor(this.player.exp)}/${this.player.lv*100}`, pad + 10, pad + 60);
        
        ctx.fillStyle = '#fc0';
        ctx.fillText(`ğŸ’° ${this.player.gold}`, pad + 10, pad + 85);
        
        // æˆ¿é—´ä¿¡æ¯
        ctx.textAlign = 'right';
        ctx.fillStyle = '#fff';
        const names = { normal: 'æ™®é€š', boss: 'BOSS', treasure: 'å®ç®±', start: 'èµ·ç‚¹', shop: 'å•†åº—' };
        ctx.fillText(`${names[this.curRoom.type]}æˆ¿é—´`, this.canvas.width - pad, pad + 35);
        ctx.fillText(`æ•Œäºº:${this.curRoom.enemies.length}`, this.canvas.width - pad, pad + 60);
        
        if (!this.curRoom.cleared) {
            ctx.fillStyle = '#f44';
            ctx.fillText('ğŸ”’ é”å®š', this.canvas.width - pad, pad + 85);
        } else {
            ctx.fillStyle = '#4f4';
            ctx.fillText('âœ“ å·²æ¸…ç†', this.canvas.width - pad, pad + 85);
        }
        
        // å°åœ°å›¾
        const mx = this.canvas.width - 150, my = 120;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(mx, my, 130, 130);
        
        for (const [, r] of this.allRooms) {
            if (!r.visited) continue;
            const rx = mx + 10 + (r.gx + 5) * 10;
            const ry = my + 10 + (r.gy + 5) * 10;
            ctx.fillStyle = r === this.curRoom ? '#ff0' : { normal: '#666', boss: '#f00', treasure: '#0f0', start: '#66f', shop: '#fc0' }[r.type];
            ctx.fillRect(rx, ry, 8, 8);
        }
        
        // åº•éƒ¨æ­¦å™¨æ 
        const by = this.canvas.height - 70;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(pad, by, 300, 50);
        
        let wx = pad + 10;
        for (const w of this.weapons) {
            ctx.fillStyle = '#333';
            ctx.fillRect(wx, by + 5, 40, 40);
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(w.cfg.icon, wx + 20, by + 32);
            wx += 50;
        }
    }

    drawShopUI() {
        const ctx = this.ctx;
        const w = this.canvas.width, h = this.canvas.height;
        
        // åŠé€æ˜èƒŒæ™¯
        ctx.fillStyle = 'rgba(0,0,0,0.85)';
        ctx.fillRect(0, 0, w, h);
        
        // å•†åº—æ ‡é¢˜
        ctx.fillStyle = '#fc0';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ¦” ç›²çœ¼é¼¹é¼ çš„å•†åº—', w/2, 80);
        
        // é‡‘å¸æ˜¾ç¤º
        ctx.fillStyle = '#fc0';
        ctx.font = '20px Arial';
        ctx.fillText(`ğŸ’° ${this.player.gold} é‡‘å¸`, w/2, 120);
        
        // å•†å“åˆ—è¡¨
        if (this.curRoom.npc) {
            const items = this.curRoom.npc.shopItems;
            const startX = w/2 - 300;
            const itemW = 180;
            const gap = 30;
            
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const x = startX + i * (itemW + gap);
                const y = 180;
                
                // å•†å“èƒŒæ™¯
                if (item.sold) {
                    ctx.fillStyle = 'rgba(50,50,50,0.8)';
                } else {
                    const rarityColors = { common: 'rgba(100,100,100,0.8)', rare: 'rgba(50,100,150,0.8)', epic: 'rgba(150,50,150,0.8)' };
                    ctx.fillStyle = rarityColors[item.rarity] || rarityColors.common;
                }
                ctx.fillRect(x, y, itemW, 220);
                
                // è¾¹æ¡†
                ctx.strokeStyle = item.sold ? '#444' : '#fc0';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, itemW, 220);
                
                // å›¾æ ‡
                ctx.font = '48px Arial';
                ctx.fillStyle = '#fff';
                ctx.fillText(item.icon, x + itemW/2, y + 60);
                
                // åç§°
                ctx.font = 'bold 16px Arial';
                ctx.fillStyle = item.sold ? '#666' : '#fff';
                ctx.fillText(item.name, x + itemW/2, y + 100);
                
                // æè¿°
                ctx.font = '12px Arial';
                ctx.fillStyle = item.sold ? '#555' : '#aaa';
                ctx.fillText(item.desc, x + itemW/2, y + 125);
                
                // ä»·æ ¼
                if (!item.sold) {
                    ctx.font = 'bold 18px Arial';
                    ctx.fillStyle = this.player.gold >= item.price ? '#fc0' : '#f44';
                    ctx.fillText(`ğŸ’° ${item.price}`, x + itemW/2, y + 160);
                    
                    // è´­ä¹°æç¤º
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#4f4';
                    ctx.fillText(`æŒ‰ ${i+1} è´­ä¹°`, x + itemW/2, y + 190);
                } else {
                    ctx.font = 'bold 18px Arial';
                    ctx.fillStyle = '#666';
                    ctx.fillText('å·²å”®ç½„', x + itemW/2, y + 175);
                }
            }
        }
        
        // æ¶ˆæ¯æç¤º
        if (this.shopUI.msg) {
            ctx.font = 'bold 18px Arial';
            ctx.fillStyle = this.shopUI.msg.includes('è´­ä¹°') ? '#4f4' : '#f44';
            ctx.fillText(this.shopUI.msg, w/2, h - 120);
        }
        
        // å…³é—­æç¤º
        ctx.font = '14px Arial';
        ctx.fillStyle = '#888';
        ctx.fillText('æŒ‰ E æˆ– ESC å…³é—­å•†åº—', w/2, h - 80);
    }

    loop(t) {
        const dt = Math.min((t - (this.lastT || t)) / 1000, 0.1);
        this.lastT = t;
        
        this.update(dt);
        this.draw();
        
        this.rafId = requestAnimationFrame(t => this.loop(t));
    }
}

// å¯åŠ¨
window.onload = () => {
    const game = new Game();
    setTimeout(() => game.start(), 500);
};
</script>
</body>
</html>
