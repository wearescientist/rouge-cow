<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è‚‰é¸½ç‰›ç‰› - v0.7.1 ç›²çœ¼å•†åº—</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        html, body { 
            width: 100%; 
            height: 100%; 
            background: #0a0a14; 
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameContainer {
            position: relative;
            width: 900px;
            height: 600px;
            max-width: 100vw;
            max-height: 100vh;
        }
        #gameCanvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
            background: #0d0d1a;
            border: 3px solid #333;
            border-radius: 8px;
        }
        #loading { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: #0a0a14; display: flex; flex-direction: column; 
            justify-content: center; align-items: center; z-index: 1000;
            transition: opacity 0.5s;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        .cow { font-size: 100px; animation: bounce 0.6s infinite alternate; }
        @keyframes bounce { from { transform: translateY(0) scale(1); } to { transform: translateY(-30px) scale(1.1); } }
        .loading-text { color: #4488ff; margin-top: 30px; font-size: 24px; font-family: Arial; }
        .loading-bar { width: 300px; height: 10px; background: #333; border-radius: 5px; margin-top: 20px; overflow: hidden; }
        .loading-progress { width: 0%; height: 100%; background: #4488ff; transition: width 0.3s; }
        .controls-hint { 
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #666; font-family: Arial; font-size: 14px; text-align: center;
            background: rgba(0,0,0,0.8); padding: 10px 20px; border-radius: 20px;
            z-index: 100;
        }
        .key { background: #333; color: #fff; padding: 2px 8px; border-radius: 4px; margin: 0 2px; }
    </style>
</head>
<body>
    <div id="loading">
        <div class="cow">ğŸ®</div>
        <div class="loading-text" id="loadingText">æ­£åœ¨åŠ è½½ç²¾çµå›¾èµ„æº...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>
    
    <div id="story" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#0a0a14; z-index:999; color:#fff; font-family:Arial; overflow-y:auto;">
        <div style="max-width:800px; margin:50px auto; padding:20px; line-height:1.8;">
            <h1 style="color:#4f4; text-align:center; margin-bottom:30px;">ğŸŒ¾ æ·±æ ¹ä¹‹ç–«</h1>
            <div id="storyContent" style="font-size:18px; color:#ccc;">
                <p style="margin-bottom:20px;">åœ¨<strong style="color:#fa0;">é’ç©—å¤§è‰åŸ</strong>çš„è…¹åœ°ï¼Œæµä¼ ç€ä¸€ä¸ªå¤è€çš„é¢„è¨€ï¼š</p>
                <p style="margin:20px 0; padding:20px; background:rgba(255,255,255,0.05); border-left:4px solid #fa0; font-style:italic;">"å½“å¤§åœ°å¼€å§‹æ¸´é¥®é²œè¡€ï¼Œæ ¹é¡»å°†åå™¬å¤©ç©ºã€‚å”¯æœ‰çŠ„è§’åˆºç ´é»‘æš—è€…ï¼Œæ–¹èƒ½å”¤é†’æ²‰ç¡çš„å¤ªé˜³ã€‚"</p>
                <p style="margin-bottom:20px;">ç‰›ç‰›å‡ºç”Ÿåœ¨<strong style="color:#48f;">è§’æ—éƒ¨è½</strong>ï¼Œä¸–ä»£å®ˆæŠ¤ç€è‰åŸçš„<strong style="color:#4f4;">çµè„‰èŠ‚ç‚¹</strong>â€”â€”åƒæ ¹åœ£æ‰€ã€‚</p>
                <p style="margin-bottom:20px;">ä½†åœ¨ä»–å¤–å‡ºä¿®è¡Œå½’æ¥æ—¶ï¼Œè‰åŸå·²å˜æˆä¸€ç‰‡æ­»å¯‚ã€‚éƒ¨è½ç©ºæ— ä¸€äººï¼Œåªæœ‰ä¸€ä¸ªé€šå¾€åœ°åº•çš„æ´ç©´ï¼Œæ•£å‘ç€è…çƒ‚çš„ç”œé¦™...</p>
                <p style="margin-bottom:20px;">ä»–å¬è§äº†åœ°åº•æ·±å¤„çš„å¿ƒè·³å£°ï¼Œè¿˜æœ‰æ¯äº²ç†Ÿæ‚‰çš„å“¼å”±ã€‚</p>
                <p style="margin-bottom:20px; color:#f44;">"ç­‰æˆ‘ï¼Œé˜¿å¦ˆã€‚"</p>
            </div>
            <div style="text-align:center; margin-top:40px;">
                <button id="startGameBtn" style="padding:15px 40px; font-size:20px; background:#4f4; color:#000; border:none; border-radius:8px; cursor:pointer;">è¸å…¥æ´ç©´</button>
            </div>
        </div>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="600"></canvas>
    </div>
    
    <div class="controls-hint">
        <span class="key">WASD</span>ç§»åŠ¨ 
        <span class="key">1-9</span>é“å…· 
        <span class="key">E</span>äº¤äº’/å•†åº— 
        <span class="key">F</span>å…¨å±
    </div>

<script>
// ============================================================================
// è‚‰é¸½ç‰›ç‰› v0.7.1 - ç›²çœ¼NPCå•†åº—ç³»ç»Ÿ + ç©¿å¢™ä¿®å¤
// ============================================================================

const $ = (fn) => fn();
const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
const dist = (x1, y1, x2, y2) => Math.sqrt((x2-x1)**2 + (y2-y1)**2);
const rand = (min, max) => Math.random() * (max - min) + min;
const randInt = (min, max) => Math.floor(rand(min, max));
const randChoice = (arr) => arr[Math.floor(Math.random() * arr.length)];

// ç²¾çµå›¾åŠ è½½å™¨
class SpriteLoader {
    constructor() {
        this.sprites = {};
        this.loaded = 0;
        this.total = 0;
        this.errors = [];
    }
    
    load(name, src) {
        this.total++;
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                this.sprites[name] = img;
                this.loaded++;
                console.log(`âœ“ Loaded: ${name}`);
                resolve(img);
            };
            
            img.onerror = () => {
                console.warn(`âœ— Failed to load: ${src}`);
                this.errors.push({ name, src });
                this.loaded++;
                resolve(null);
            };
            
            setTimeout(() => {
                if (!img.complete) {
                    console.warn(`â± Timeout: ${src}`);
                    this.errors.push({ name, src, timeout: true });
                    resolve(null);
                }
            }, 5000);
            
            img.src = src;
        });
    }
    
    get(name) { return this.sprites[name]; }
    has(name) { return name in this.sprites; }
    isReady() { return this.loaded >= this.total; }
    getProgress() { return this.total > 0 ? this.loaded / this.total : 1; }
    getErrorCount() { return this.errors.length; }
}

// ç²’å­ç³»ç»Ÿ
class ParticleSystem {
    constructor(max = 200) {
        this.pool = Array(max).fill(null).map(() => ({
            x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 1,
            color: '#fff', size: 4, active: false
        }));
        this.active = [];
    }

    emit(x, y, color, opts = {}) {
        const p = this.pool.find(p => !p.active) || this.pool[0];
        p.x = x; p.y = y; p.color = color; p.active = true;
        p.life = opts.life || 1; p.maxLife = p.life;
        p.size = opts.size || 4;
        const speed = opts.speed || 100;
        const angle = opts.angle != null ? opts.angle : Math.random() * Math.PI * 2;
        p.vx = Math.cos(angle) * speed;
        p.vy = Math.sin(angle) * speed;
        if (!this.active.includes(p)) this.active.push(p);
    }

    burst(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
            this.emit(x, y, color, { 
                speed: rand(50, 150), 
                life: rand(0.3, 0.8),
                size: rand(2, 5)
            });
        }
    }

    update(dt) {
        for (let i = this.active.length - 1; i >= 0; i--) {
            const p = this.active[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt;
            if (p.life <= 0) {
                p.active = false;
                this.active.splice(i, 1);
            }
        }
    }

    draw(ctx) {
        for (const p of this.active) {
            const alpha = p.life / p.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
        }
        ctx.globalAlpha = 1;
    }
}

// éŸ³æ•ˆç³»ç»Ÿ
class SoundManager {
    constructor() {
        this.ctx = null;
        this.enabled = true;
    }
    
    init() {
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn('Web Audio API not supported');
            this.enabled = false;
        }
    }
    
    play(type) {
        if (!this.enabled || !this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        switch(type) {
            case 'shoot':
                osc.frequency.value = 800;
                gain.gain.value = 0.1;
                osc.start();
                osc.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.stop(this.ctx.currentTime + 0.1);
                break;
            case 'hit':
                osc.frequency.value = 200;
                osc.type = 'square';
                gain.gain.value = 0.15;
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.stop(this.ctx.currentTime + 0.15);
                break;
            case 'kill':
                osc.frequency.value = 600;
                gain.gain.value = 0.2;
                osc.start();
                osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                osc.frequency.setValueAtTime(800, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.stop(this.ctx.currentTime + 0.3);
                break;
            case 'levelup':
                osc.frequency.value = 400;
                gain.gain.value = 0.25;
                osc.start();
                for (let i = 0; i < 5; i++) {
                    osc.frequency.setValueAtTime(400 + i * 100, this.ctx.currentTime + i * 0.05);
                }
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.stop(this.ctx.currentTime + 0.5);
                break;
            case 'door':
                osc.frequency.value = 300;
                gain.gain.value = 0.2;
                osc.start();
                osc.frequency.exponentialRampToValueAtTime(600, this.ctx.currentTime + 0.3);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.stop(this.ctx.currentTime + 0.3);
                break;
            case 'damage':
                osc.frequency.value = 150;
                osc.type = 'sawtooth';
                gain.gain.value = 0.2;
                osc.start();
                osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.stop(this.ctx.currentTime + 0.2);
                break;
            case 'item':
                osc.frequency.value = 600;
                gain.gain.value = 0.15;
                osc.start();
                osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                osc.frequency.setValueAtTime(800, this.ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.stop(this.ctx.currentTime + 0.2);
                break;
            case 'buy':
                osc.frequency.value = 500;
                gain.gain.value = 0.2;
                osc.start();
                osc.frequency.setValueAtTime(500, this.ctx.currentTime);
                osc.frequency.setValueAtTime(700, this.ctx.currentTime + 0.1);
                osc.frequency.setValueAtTime(900, this.ctx.currentTime + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.stop(this.ctx.currentTime + 0.3);
                break;
        }
    }
}

// é“å…·æ•°æ®åº“ - æ·»åŠ ä»·æ ¼
const ITEMS = {
    1: { id: 1, name: 'å¤šé‡å°„å‡»', icon: 'ğŸ¯', rarity: 'common', effect: 'projCount', value: 1, desc: 'å­å¼¹+1', price: 40 },
    2: { id: 2, name: 'å·¨å¤§åŒ–', icon: 'ğŸ“', rarity: 'common', effect: 'projSize', value: 0.3, desc: 'å­å¼¹å˜å¤§', price: 35 },
    3: { id: 3, name: 'å¿«é€Ÿå°„å‡»', icon: 'âš¡', rarity: 'common', effect: 'fireRate', value: 0.15, desc: 'å°„é€Ÿ+15%', price: 45 },
    4: { id: 4, name: 'ç©¿ç”²å¼¹', icon: 'ğŸ”©', rarity: 'rare', effect: 'pierce', value: 1, desc: 'ç©¿é€+1', price: 80 },
    5: { id: 5, name: 'æš´å‡»é•œç‰‡', icon: 'ğŸ”', rarity: 'rare', effect: 'crit', value: 0.1, desc: 'æš´å‡»+10%', price: 75 },
    6: { id: 6, name: 'å¿ƒä¹‹å®¹å™¨', icon: 'â¤ï¸', rarity: 'common', effect: 'maxHp', value: 2, desc: 'ç”Ÿå‘½+2', price: 50 },
    7: { id: 7, name: 'é’¢é“æŠ¤ç”²', icon: 'ğŸ›¡ï¸', rarity: 'rare', effect: 'armor', value: 1, desc: 'æŠ¤ç”²+1', price: 85 },
    8: { id: 8, name: 'å¸è¡€ç ç‰™', icon: 'ğŸ¦·', rarity: 'rare', effect: 'lifeSteal', value: 0.05, desc: 'å¸è¡€5%', price: 90 },
    9: { id: 9, name: 'åŠ é€Ÿé´', icon: 'ğŸ‘Ÿ', rarity: 'common', effect: 'speed', value: 0.2, desc: 'ç§»é€Ÿ+20%', price: 40 },
    10: { id: 10, name: 'é£è¡Œç¿…è†€', icon: 'ğŸ¦…', rarity: 'epic', effect: 'fly', value: 1, desc: 'å¯ä»¥é£è¡Œ', price: 150 },
    11: { id: 11, name: 'ç£é“', icon: 'ğŸ§²', rarity: 'rare', effect: 'magnet', value: 50, desc: 'å¸èŒƒå›´+50', price: 70 },
    12: { id: 12, name: 'é‡‘è›‹', icon: 'ğŸ¥š', rarity: 'epic', effect: 'goldBonus', value: 0.5, desc: 'é‡‘å¸+50%', price: 120 },
    13: { id: 13, name: 'ç«ç„°é™„é­”', icon: 'ğŸ”¥', rarity: 'rare', effect: 'fireDmg', value: 5, desc: 'ç«ç„°ä¼¤å®³+5', price: 85 },
    14: { id: 14, name: 'å†°å†»æ ¸å¿ƒ', icon: 'â„ï¸', rarity: 'rare', effect: 'slow', value: 0.2, desc: 'å‡é€Ÿæ•Œäºº20%', price: 80 },
    15: { id: 15, name: 'é›·ç”µå®ç ', icon: 'âš¡', rarity: 'epic', effect: 'chain', value: 1, desc: 'è¿é”æ”»å‡»+1', price: 140 }
};

// è·å–é“å…·ä»·æ ¼ï¼ˆå¸¦éšæœºæ³¢åŠ¨ï¼‰
function getItemPrice(itemId) {
    const item = ITEMS[itemId];
    if (!item) return 100;
    const basePrice = item.price || 50;
    const variance = basePrice * 0.2; // 20%æ³¢åŠ¨
    return Math.floor(basePrice + rand(-variance, variance));
}

class ItemManager {
    constructor(player) {
        this.player = player;
        this.owned = {};
        this.cache = null;
        this.dirty = true;
    }

    add(id) {
        const item = ITEMS[id];
        if (!item) return false;
        this.owned[id] = (this.owned[id] || 0) + 1;
        this.dirty = true;
        
        if (item.effect === 'maxHp') {
            this.player.maxHp += item.value;
            this.player.hp += item.value;
        }
        return true;
    }

    getStats() {
        if (!this.dirty) return this.cache;
        
        const s = {
            projCount: 1, projSize: 1, fireRate: 1, pierce: 0,
            crit: 0, maxHp: 0, armor: 0, lifeSteal: 0,
            speed: 1, fly: false, magnet: 100, goldBonus: 1
        };
        
        for (const [id, count] of Object.entries(this.owned)) {
            const item = ITEMS[id];
            if (!item) continue;
            const v = item.value * count;
            
            switch (item.effect) {
                case 'projCount': s.projCount += v; break;
                case 'projSize': s.projSize += v; break;
                case 'fireRate': s.fireRate *= (1 + v); break;
                case 'pierce': s.pierce += v; break;
                case 'crit': s.crit = Math.min(1, s.crit + v); break;
                case 'maxHp': s.maxHp += v; break;
                case 'armor': s.armor += v; break;
                case 'lifeSteal': s.lifeSteal += v; break;
                case 'speed': s.speed += v; break;
                case 'fly': s.fly = true; break;
                case 'magnet': s.magnet += v; break;
                case 'goldBonus': s.goldBonus += v; break;
            }
        }
        
        this.cache = s;
        this.dirty = false;
        return s;
    }

    has(id) { return (this.owned[id] || 0) > 0; }
    count(id) { return this.owned[id] || 0; }
    getList() { return Object.entries(this.owned).map(([id, c]) => ({ ...ITEMS[id], count: c })).filter(x => x.name); }
}

// æ­¦å™¨ç³»ç»Ÿ
const WEAPONS = {
    whip: { key: 'whip', name: 'é­å­', icon: 'ğŸª„', dmg: 20, cd: 1.0, range: 100, type: 'melee', color: '#f60' },
    wand: { key: 'wand', name: 'é­”æ–', icon: 'ğŸ”®', dmg: 15, cd: 0.6, speed: 300, type: 'proj', color: '#48f' },
    knife: { key: 'knife', name: 'é£åˆ€', icon: 'ğŸ—¡ï¸', dmg: 12, cd: 0.4, speed: 400, pierce: 3, type: 'proj', color: '#ccc' },
    axe: { key: 'axe', name: 'æ–§å¤´', dmg: 25, cd: 1.2, speed: 250, type: 'proj', color: '#8b4513' }
};

class Weapon {
    constructor(key, level = 1) {
        this.cfg = WEAPONS[key];
        this.level = level;
        this.cd = 0;
        this.xp = 0;
        this.xpToNext = 100;
    }
    
    getDamage(stats) { return this.cfg.dmg * (1 + (this.level - 1) * 0.15) * stats.projSize; }
    update(dt) { this.cd -= dt; }
    canFire() { return this.cd <= 0; }
    
    addXp(amount) {
        this.xp += amount;
        if (this.xp >= this.xpToNext) {
            this.xp -= this.xpToNext;
            this.level++;
            this.xpToNext = Math.floor(this.xpToNext * 1.5);
            return true;
        }
        return false;
    }
    
    getLevelColor() {
        if (this.level >= 5) return '#f0f';
        if (this.level >= 3) return '#fa0';
        if (this.level >= 2) return '#0ff';
        return '#fff';
    }
    
    fire(player, target, stats) {
        this.cd = this.cfg.cd / stats.fireRate;
        const bullets = [];
        const count = Math.floor(stats.projCount);
        
        for (let i = 0; i < count; i++) {
            let angle = 0;
            if (target) {
                angle = Math.atan2(target.y - player.y, target.x - player.x);
                if (count > 1) angle += (i - (count - 1) / 2) * 0.15;
            } else {
                angle = Math.random() * Math.PI * 2;
            }
            
            bullets.push({
                x: player.x, y: player.y,
                vx: Math.cos(angle) * (this.cfg.speed || 200),
                vy: Math.sin(angle) * (this.cfg.speed || 200),
                dmg: this.getDamage(stats),
                color: this.cfg.color,
                life: this.cfg.type === 'melee' ? 0.3 : 3,
                pierce: (this.cfg.pierce || 0) + stats.pierce,
                type: this.cfg.type,
                range: this.cfg.range,
                hits: new Set(),
                homing: this.cfg.type !== 'melee',
                target: target
            });
        }
        return bullets;
    }
}

// æ•Œäººé…ç½®
const ENEMY_TYPES = {
    chick: { name: 'å˜å¼‚å°é¸¡', hp: 10, speed: 80, dmg: 1, exp: 2, gold: 5, color: '#ff6', sprite: 'chick' },
    pig: { name: 'å˜å¼‚å°çŒª', hp: 20, speed: 50, dmg: 2, exp: 4, gold: 8, color: '#f9c', sprite: 'pig' },
    sheep: { name: 'å˜å¼‚å°ç¾Š', hp: 15, speed: 60, dmg: 1, exp: 3, gold: 6, color: '#eee', sprite: 'sheep' },
    dog: { name: 'ç–¯ç‹—', hp: 18, speed: 100, dmg: 2, exp: 5, gold: 7, color: '#963', sprite: 'dog' },
    cat: { name: 'å˜å¼‚çŒ«', hp: 12, speed: 90, dmg: 1, exp: 3, gold: 6, color: '#fa3', sprite: 'cat' },
    bear: { name: 'å·¨ç†Š', hp: 35, speed: 40, dmg: 3, exp: 8, gold: 15, color: '#630', sprite: 'bear' },
    
    tiaotiao: { name: 'è·³è·³', hp: 25, speed: 120, dmg: 2, exp: 6, gold: 12, color: '#c85', sprite: 'rabbit', special: 'jump' },
    tiezhua: { name: 'é“çˆª', hp: 22, speed: 150, dmg: 3, exp: 7, gold: 14, color: '#a52', sprite: 'bird', special: 'dive' },
    nibei: { name: 'æ³¥èƒŒ', hp: 50, speed: 30, dmg: 2, exp: 8, gold: 20, color: '#6a5', sprite: 'turtle', special: 'tank', armor: 2 },
    yinya: { name: 'é“¶ç‰™', hp: 30, speed: 90, dmg: 2, exp: 10, gold: 18, color: '#789', sprite: 'dog2', special: 'summon' }
};

// BOSSé…ç½®
const BOSS_TYPES = {
    mother: {
        name: 'æ¯ä½“',
        hp: 500,
        speed: 30,
        dmg: 5,
        exp: 100,
        gold: 200,
        color: '#f0f',
        sprite: 'bear',
        scale: 2,
        phases: [
            { hpPercent: 100, behavior: 'normal' },
            { hpPercent: 70, behavior: 'enrage' },
            { hpPercent: 30, behavior: 'desperate' }
        ]
    }
};

class Enemy {
    constructor(x, y, typeKey) {
        const cfg = ENEMY_TYPES[typeKey] || ENEMY_TYPES.chick;
        this.x = x; this.y = y;
        this.typeKey = typeKey;
        this.hp = cfg.hp + (cfg.armor || 0) * 10;
        this.maxHp = this.hp;
        this.speed = cfg.speed;
        this.dmg = cfg.dmg;
        this.exp = cfg.exp;
        this.gold = cfg.gold || 5;
        this.color = cfg.color;
        this.sprite = cfg.sprite;
        this.special = cfg.special;
        this.armor = cfg.armor || 0;
        this.vx = 0; this.vy = 0;
        this.hitTimer = 0;
        this.attackCd = 0;
        this.specialCd = 0;
    }

    update(dt, player, room) {
        if (this.special === 'jump' && this.specialCd <= 0) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d > 0 && d < 200) {
                this.vx = (dx / d) * this.speed * 2;
                this.vy = (dy / d) * this.speed * 2;
                this.specialCd = 2;
            }
        } else if (this.special === 'dive' && this.specialCd <= 0) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d > 100 && d < 400) {
                this.vx = (dx / d) * this.speed * 3;
                this.vy = (dy / d) * this.speed * 3;
                this.specialCd = 3;
            }
        } else {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            
            if (d > 0) {
                this.vx = (dx / d) * this.speed;
                this.vy = (dy / d) * this.speed;
            }
        }
        
        if (this.special === 'tank') {
            this.vx *= 0.8;
            this.vy *= 0.8;
        }
        
        if (this.special === 'summon' && this.specialCd <= 0 && room.enemies.length < 10) {
            this.specialCd = 5;
            const angle = Math.random() * Math.PI * 2;
            const r = 30;
            room.enemies.push(new Enemy(
                this.x + Math.cos(angle) * r,
                this.y + Math.sin(angle) * r,
                'dog'
            ));
        }
        
        for (const other of room.enemies) {
            if (other === this) continue;
            const odx = this.x - other.x;
            const ody = this.y - other.y;
            const od = Math.sqrt(odx*odx + ody*ody);
            if (od < 30 && od > 0) {
                this.vx += (odx / od) * 50;
                this.vy += (ody / od) * 50;
            }
        }
        
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        // è¾¹ç•Œé™åˆ¶ - ä¿®å¤ç©¿å¢™
        this.x = clamp(this.x, 50, 850);
        this.y = clamp(this.y, 50, 550);
        
        if (this.hitTimer > 0) this.hitTimer -= dt;
        if (this.attackCd > 0) this.attackCd -= dt;
        if (this.specialCd > 0) this.specialCd -= dt;
    }

    takeDamage(dmg) {
        const actualDmg = Math.max(1, dmg - this.armor);
        this.hp -= actualDmg;
        this.hitTimer = 0.1;
        return this.hp <= 0;
    }

    draw(ctx, sprites) {
        const size = this.isBoss ? 36 : 16;
        
        if (this.hitTimer > 0 && Math.floor(Date.now() / 50) % 2) {
            ctx.globalAlpha = 0.5;
        }
        
        if (this.isBoss) {
            ctx.strokeStyle = `rgba(255, 0, 255, ${0.3 + Math.sin(Date.now() / 200) * 0.2})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size + 10, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        const sprite = sprites.get(this.sprite);
        if (sprite) {
            ctx.drawImage(sprite, this.x - size, this.y - size, size * 2, size * 2);
        } else {
            const emojiMap = {
                chick: 'ğŸ¤', pig: 'ğŸ·', sheep: 'ğŸ‘', dog: 'ğŸ•',
                cat: 'ğŸ±', bear: 'ğŸ»', rabbit: 'ğŸ¦˜', bird: 'ğŸ¦…',
                turtle: 'ğŸ¢', dog2: 'ğŸº'
            };
            ctx.font = this.isBoss ? '48px Arial' : '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(emojiMap[this.sprite] || 'ğŸ‘¾', this.x, this.y + 8);
        }
        
        ctx.globalAlpha = 1;
        
        if (this.hp < this.maxHp) {
            const barWidth = this.isBoss ? 100 : 24;
            ctx.fillStyle = '#000';
            ctx.fillRect(this.x - barWidth/2, this.y - size - 10, barWidth, 6);
            ctx.fillStyle = this.isBoss ? '#f0f' : '#f00';
            ctx.fillRect(this.x - barWidth/2, this.y - size - 10, barWidth * (this.hp / this.maxHp), 6);
        }
        
        if (this.isBoss) {
            ctx.fillStyle = '#f0f';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(this.name, this.x, this.y - size - 20);
        }
    }
}

// ç›²çœ¼NPCç±»
class ShopNPC {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.name = 'ç›²çœ¼';
        this.dialogues = [
            "ä½ çˆ¶äº²...æ˜¯ä¸ªå›ºæ‰§çš„å‚»ç“œ...",
            "æ¯è™«åœ¨æ”¶é›†å®ˆæŠ¤è€…è¡€è„‰...",
            "é‚£äº›æ­Œå£°æ˜¯è¯±é¥µ...",
            "åˆ«ç›¸ä¿¡...æ¢¦å¢ƒ...",
            "åœ°åº•ä¸‹...æœ‰æ›´å¯æ€•çš„ä¸œè¥¿...",
            "ä½ çˆ¶æ¯è¿˜æ´»ç€...ä½†å¿«...",
            "èƒå–æ¶²å¯ä»¥å±è”½æ§åˆ¶...",
            "å°å°æ¾åŠ¨äº†..."
        ];
        this.currentDialogue = '';
        this.dialogueTimer = 0;
    }
    
    getDialogue() {
        return this.dialogues[Math.floor(Math.random() * this.dialogues.length)];
    }
    
    draw(ctx, playerNear = false) {
        // NPCèƒŒæ™¯ï¼ˆéš”ç¦»è…”å®¤ï¼‰
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(this.x - 35, this.y - 35, 70, 70);
        ctx.strokeStyle = '#4a4';
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x - 35, this.y - 35, 70, 70);
        
        // ç›²çœ¼å½¢è±¡ ğŸ¦¯ğŸ‘ï¸
        ctx.font = '32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ¦¯', this.x - 8, this.y + 8);
        ctx.fillText('ğŸ‘ï¸', this.x + 8, this.y + 8);
        
        // åå­—
        ctx.fillStyle = '#4f4';
        ctx.font = '12px Arial';
        ctx.fillText('ç›²çœ¼', this.x, this.y + 30);
        
        // äº¤äº’æç¤º
        if (playerNear) {
            ctx.fillStyle = '#ff0';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('æŒ‰ E æ‰“å¼€å•†åº—', this.x, this.y - 45);
        }
    }
    
    drawShop(ctx, items, playerGold, selectedIndex = -1) {
        const boxWidth = 500;
        const boxHeight = 350;
        const boxX = 450 - boxWidth / 2;
        const boxY = 300 - boxHeight / 2;
        
        // å•†åº—èƒŒæ™¯
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = '#4a4';
        ctx.lineWidth = 3;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // æ ‡é¢˜
        ctx.fillStyle = '#4f4';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ¦¯ ç›²çœ¼çš„å•†åº— ğŸ‘ï¸', 450, boxY + 40);
        
        // ç©å®¶é‡‘å¸
        ctx.fillStyle = '#fc0';
        ctx.font = '18px Arial';
        ctx.fillText(`ğŸ’° ${playerGold}`, 450, boxY + 70);
        
        // å•†å“
        const itemWidth = 130;
        const itemHeight = 160;
        const startX = 450 - (items.length * itemWidth) / 2 + itemWidth / 2;
        
        items.forEach((item, i) => {
            const ix = startX + i * (itemWidth + 20);
            const iy = boxY + 160;
            
            // å•†å“èƒŒæ™¯
            ctx.fillStyle = i === selectedIndex ? '#2a4a2a' : '#1a1a2e';
            ctx.fillRect(ix - itemWidth/2, iy - itemHeight/2, itemWidth, itemHeight);
            ctx.strokeStyle = playerGold >= item.price ? '#4a4' : '#a44';
            ctx.lineWidth = 2;
            ctx.strokeRect(ix - itemWidth/2, iy - itemHeight/2, itemWidth, itemHeight);
            
            // é“å…·å›¾æ ‡
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(item.icon, ix, iy - 20);
            
            // é“å…·å
            ctx.fillStyle = '#fff';
            ctx.font = '14px Arial';
            ctx.fillText(item.name, ix, iy + 15);
            
            // æè¿°
            ctx.fillStyle = '#aaa';
            ctx.font = '11px Arial';
            ctx.fillText(item.desc, ix, iy + 35);
            
            // ä»·æ ¼
            ctx.fillStyle = playerGold >= item.price ? '#fc0' : '#f44';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`ğŸ’°${item.price}`, ix, iy + 60);
            
            // åºå·
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.fillText(`[${i + 1}]`, ix, iy + 80);
        });
        
        // æ“ä½œæç¤º
        ctx.fillStyle = '#888';
        ctx.font = '14px Arial';
        ctx.fillText('æŒ‰ 1-3 è´­ä¹° | æŒ‰ E å…³é—­', 450, boxY + boxHeight - 20);
    }
}

// å›¾è…¾ç³»ç»Ÿ
const TOTEMS = {
    1: { id: 1, name: 'å…ˆç¥–ä¹‹åŠ›', icon: 'ğŸ¦´', desc: 'æ”»å‡»åŠ›+10%', effect: 'dmg', value: 0.1 },
    2: { id: 2, name: 'åœ°è„‰å®ˆæŠ¤', icon: 'ğŸ›¡ï¸', desc: 'æœ€å¤§ç”Ÿå‘½+1', effect: 'maxHp', value: 1 },
    3: { id: 3, name: 'ç–¾é£æ­¥', icon: 'ğŸ‘Ÿ', desc: 'ç§»åŠ¨é€Ÿåº¦+10%', effect: 'speed', value: 0.1 },
    4: { id: 4, name: 'æ™ºæ…§ä¹‹çœ¼', icon: 'ğŸ‘ï¸', desc: 'ç»éªŒè·å–+20%', effect: 'exp', value: 0.2 },
    5: { id: 5, name: 'è´ªå©ªä¹‹æ‰‹', icon: 'ğŸ’°', desc: 'é‡‘å¸è·å–+25%', effect: 'gold', value: 0.25 },
    6: { id: 6, name: 'å†ç”Ÿä¹‹è¡€', icon: 'â¤ï¸', desc: 'ç”Ÿå‘½æ¢å¤+0.1/ç§’', effect: 'regen', value: 0.1 },
    7: { id: 7, name: 'å¹¸è¿æ˜Ÿ', icon: 'â­', desc: 'æš´å‡»ç‡+5%', effect: 'crit', value: 0.05 }
};

class TotemManager {
    constructor() {
        this.owned = new Set();
        this.load();
    }
    
    load() {
        try {
            const saved = localStorage.getItem('rougecow_totems');
            if (saved) this.owned = new Set(JSON.parse(saved));
        } catch (e) {}
    }
    
    save() {
        try {
            localStorage.setItem('rougecow_totems', JSON.stringify([...this.owned]));
        } catch (e) {}
    }
    
    collect(id) {
        if (this.owned.has(id)) return false;
        this.owned.add(id);
        this.save();
        return true;
    }
    
    has(id) { return this.owned.has(id); }
    getCount() { return this.owned.size; }
    
    getAllBonuses() {
        const bonuses = { dmg: 0, maxHp: 0, speed: 0, exp: 0, gold: 0, regen: 0, crit: 0 };
        for (const id of this.owned) {
            const totem = TOTEMS[id];
            if (totem) bonuses[totem.effect] += totem.value;
        }
        return bonuses;
    }
}

// æˆ¿é—´ç±»
class Room {
    constructor(gx, gy, type = 'normal', floor = 1) {
        this.gx = gx; this.gy = gy;
        this.id = `${gx},${gy}`;
        this.type = type;
        this.floor = floor;
        this.doors = { up: null, down: null, left: null, right: null };
        this.enemies = [];
        this.cleared = type === 'start' || type === 'treasure' || type === 'shop';
        this.visited = false;
        this.items = [];
        this.npc = null;
        
        // å•†åº—æˆ¿åˆ›å»ºç›²çœ¼NPC
        if (type === 'shop') {
            this.npc = new ShopNPC(80, 300);
        }
        
        this.spawnEnemies();
        this.spawnRoomItems();
    }
    
    spawnRoomItems() {
        if (this.type === 'treasure') {
            const count = randInt(2, 4);
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const r = 100;
                const x = 450 + Math.cos(angle) * r;
                const y = 300 + Math.sin(angle) * r;
                const itemId = randInt(1, 16);
                const item = ITEMS[itemId];
                if (item) {
                    this.items.push({ x, y, id: itemId, icon: item.icon, name: item.name });
                }
            }
        } else if (this.type === 'hidden') {
            const itemId = randInt(1, 16);
            const item = ITEMS[itemId];
            if (item) {
                this.items.push({
                    x: 450, y: 300,
                    id: itemId, icon: item.icon,
                    name: item.name + '(è¯…å’’)', cursed: true
                });
            }
        }
    }

    spawnEnemies() {
        if (this.type === 'start' || this.type === 'treasure' || this.type === 'shop') return;
        
        if (this.type === 'hidden') {
            const eliteTypes = ['bear', 'yinya'];
            const typeKey = randChoice(eliteTypes);
            const elite = new Enemy(450, 300, typeKey);
            elite.hp *= 2;
            elite.maxHp *= 2;
            elite.dmg *= 1.5;
            elite.isElite = true;
            this.enemies.push(elite);
            return;
        }
        
        if (this.type === 'boss') {
            const bossCfg = BOSS_TYPES.mother;
            const boss = new Enemy(450, 200, 'bear');
            boss.name = bossCfg.name;
            boss.hp = bossCfg.hp;
            boss.maxHp = bossCfg.hp;
            boss.speed = bossCfg.speed;
            boss.dmg = bossCfg.dmg;
            boss.exp = bossCfg.exp;
            boss.gold = bossCfg.gold;
            boss.color = bossCfg.color;
            boss.isBoss = true;
            boss.phase = 0;
            this.enemies.push(boss);
            return;
        }
        
        const count = randInt(3, 7);
        const types = Object.keys(ENEMY_TYPES).filter(k => !ENEMY_TYPES[k].special);
        
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const r = 150 + Math.random() * 100;
            const x = 450 + Math.cos(angle) * r;
            const y = 300 + Math.sin(angle) * r;
            
            if (Math.random() < 0.1 && (this.gx + this.gy) > 2) {
                const specialTypes = ['tiaotiao', 'tiezhua', 'nibei', 'yinya'];
                this.enemies.push(new Enemy(x, y, randChoice(specialTypes)));
            } else {
                this.enemies.push(new Enemy(x, y, randChoice(types)));
            }
        }
    }

    draw(ctx) {
        const floorColors = { 
            start: '#1a1a2e', normal: '#16213e', boss: '#2d1b2e', 
            treasure: '#2d2d1b', shop: '#1b1b2d', hidden: '#2d1b2d'
        };
        ctx.fillStyle = floorColors[this.type] || '#16213e';
        ctx.fillRect(0, 0, 900, 600);
        
        const roomLabels = {
            start: 'èµ·ç‚¹', normal: 'æˆ˜æ–—', boss: 'BOSS',
            treasure: 'ğŸ’ å®ç®±æˆ¿', shop: 'ğŸª å•†åº—', hidden: 'ğŸ‘ï¸ éšè—æˆ¿'
        };
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(roomLabels[this.type] || 'æˆ¿é—´', 450, 80);
        
        // ç½‘æ ¼
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1;
        for (let x = 0; x <= 900; x += 50) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, 600); ctx.stroke();
        }
        for (let y = 0; y <= 600; y += 50) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(900, y); ctx.stroke();
        }
        
        // å¢™å£ - ä¿®å¤ç©¿å¢™çš„å…³é”®è¾¹ç•Œ
        ctx.fillStyle = '#0f0f1a';
        ctx.fillRect(0, 0, 900, 40);      // ä¸Šå¢™
        ctx.fillRect(0, 560, 900, 40);    // ä¸‹å¢™
        ctx.fillRect(0, 0, 40, 600);      // å·¦å¢™
        ctx.fillRect(860, 0, 40, 600);    // å³å¢™
        
        // é—¨
        for (const [dir, door] of Object.entries(this.doors)) {
            if (!door) continue;
            ctx.fillStyle = door.open ? '#4a4' : '#a44';
            const pos = { 
                up: [420, 0, 60, 40], down: [420, 560, 60, 40], 
                left: [0, 260, 40, 80], right: [860, 260, 40, 80] 
            }[dir];
            ctx.fillRect(...pos);
        }
    }
}

// åœ°å›¾ç”Ÿæˆå™¨ - æ”¯æŒå¤šå±‚
class MapGenerator {
    generate(floor = 1) {
        const rooms = new Map();
        const start = new Room(0, 0, 'start', floor);
        rooms.set(start.id, start);
        
        const queue = [start];
        const dirs = [
            { dx: 0, dy: -1, name: 'up', opp: 'down' },
            { dx: 1, dy: 0, name: 'right', opp: 'left' },
            { dx: 0, dy: 1, name: 'down', opp: 'up' },
            { dx: -1, dy: 0, name: 'left', opp: 'right' }
        ];
        
        let count = 1;
        const maxRooms = 8 + floor * 2; // æ¯å±‚æˆ¿é—´æ•°é€’å¢
        
        while (queue.length && count < maxRooms) {
            const cur = queue.shift();
            for (const dir of dirs.sort(() => Math.random() - 0.5)) {
                const nx = cur.gx + dir.dx, ny = cur.gy + dir.dy;
                const id = `${nx},${ny}`;
                
                if (rooms.has(id)) {
                    const ex = rooms.get(id);
                    if (!cur.doors[dir.name]) {
                        cur.doors[dir.name] = { open: cur.cleared, target: ex };
                        ex.doors[dir.opp] = { open: ex.cleared, target: cur };
                    }
                    continue;
                }
                
                if (Math.random() > 0.4 || count < 5) {
                    let type = 'normal';
                    if (count === maxRooms - 1) {
                        type = 'boss';
                    } else if (count > 3) {
                        const roll = Math.random();
                        if (roll < 0.15) type = 'treasure';
                        else if (roll < 0.30) type = 'shop';
                        else if (roll < 0.35) type = 'hidden';
                    }
                    
                    const nr = new Room(nx, ny, type, floor);
                    cur.doors[dir.name] = { open: cur.cleared, target: nr };
                    nr.doors[dir.opp] = { open: nr.cleared, target: cur };
                    rooms.set(id, nr);
                    queue.push(nr);
                    count++;
                }
            }
        }
        
        return { start, rooms };
    }
}

// ============================================================================
// ä¸»æ¸¸æˆç±» v0.7.1
// ============================================================================
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = 900;
        this.canvas.height = 600;
        
        this.sprites = new SpriteLoader();
        this.state = 'loading';
        this.player = { x: 450, y: 300, hp: 6, maxHp: 6, exp: 0, lv: 1, gold: 100 };
        this.items = new ItemManager(this.player);
        this.totems = new TotemManager();
        this.weapons = [new Weapon('whip', 1)];
        this.activeWeapon = 0;
        this.bullets = [];
        this.particles = new ParticleSystem();
        this.gems = [];
        this.goldDrops = []; // é‡‘å¸æ‰è½
        
        // å¤šå±‚ç³»ç»Ÿ
        this.currentFloor = 1;
        this.maxFloors = 6;
        this.allFloors = new Map();
        
        const gen = new MapGenerator();
        const map = gen.generate(1);
        this.curRoom = map.start;
        this.allRooms = map.rooms;
        this.curRoom.visited = true;
        this.allFloors.set(1, { start: map.start, rooms: map.rooms });
        
        this.keys = {};
        this.transition = { active: false, timer: 0, dir: null, target: null };
        this.rafId = null;
        this.godMode = false;
        
        // å•†åº—ç³»ç»Ÿ
        this.shopOpen = false;
        this.shopItems = [];
        this.shopSelected = -1;
        
        this.sounds = new SoundManager();
        this.setupInput();
    }

    async loadSprites() {
        const basePath = 'https://wearescientist.github.io/rouge-cow/assets/sprites/';
        await this.sprites.load('player', basePath + 'player_cow.png');
        
        const enemies = ['chick', 'pig', 'sheep', 'dog', 'cat', 'bear'];
        for (const name of enemies) {
            await this.sprites.load(name, basePath + name + '.png');
            this.updateLoadingProgress();
        }
        
        const specialEnemies = ['rabbit', 'bird', 'turtle', 'dog2'];
        for (const name of specialEnemies) {
            await this.sprites.load(name, basePath + name + '.png');
            this.updateLoadingProgress();
        }
    }
    
    updateLoadingProgress() {
        const progress = this.sprites.getProgress() * 100;
        const progressBar = document.getElementById('loadingProgress');
        const loadingText = document.getElementById('loadingText');
        if (progressBar) progressBar.style.width = `${progress}%`;
        if (loadingText) loadingText.textContent = `æ­£åœ¨åŠ è½½... ${Math.floor(progress)}%`;
    }

    setupInput() {
        window.addEventListener('keydown', e => {
            this.keys[e.key] = true;
            
            // å•†åº—äº¤äº’
            if (e.key === 'e' || e.key === 'E') {
                if (this.shopOpen) {
                    this.closeShop();
                } else if (this.curRoom.type === 'shop' && this.curRoom.npc) {
                    const d = dist(this.player.x, this.player.y, this.curRoom.npc.x, this.curRoom.npc.y);
                    if (d < 80) {
                        this.openShop();
                    }
                }
            }
            
            // å•†åº—è´­ä¹°
            if (this.shopOpen) {
                if (e.key >= '1' && e.key <= '3') {
                    const idx = parseInt(e.key) - 1;
                    if (idx < this.shopItems.length) {
                        this.buyItem(idx);
                    }
                }
                return; // å•†åº—æ‰“å¼€æ—¶ç¦æ­¢å…¶ä»–æ“ä½œ
            }
            
            if (e.key >= '1' && e.key <= '9') {
                const id = parseInt(e.key);
                if (this.items.add(id)) {
                    this.particles.burst(this.player.x, this.player.y, '#ff0', 15);
                }
            }
            
            if (e.key === 'f' || e.key === 'F') {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }
            
            if (e.key === 'g' || e.key === 'G') {
                this.godMode = !this.godMode;
                console.log(`æ— æ•Œæ¨¡å¼: ${this.godMode ? 'å¼€å¯' : 'å…³é—­'}`);
            }
        });
        
        window.addEventListener('keyup', e => this.keys[e.key] = false);
    }
    
    openShop() {
        if (this.shopItems.length === 0) {
            // ç”Ÿæˆå•†åº—å•†å“
            const itemIds = Object.keys(ITEMS).map(Number);
            const selected = [];
            while (selected.length < 3 && itemIds.length > 0) {
                const idx = Math.floor(Math.random() * itemIds.length);
                const itemId = itemIds.splice(idx, 1)[0];
                const item = ITEMS[itemId];
                if (item) {
                    selected.push({
                        id: itemId,
                        icon: item.icon,
                        name: item.name,
                        desc: item.desc,
                        price: getItemPrice(itemId),
                        rarity: item.rarity
                    });
                }
            }
            this.shopItems = selected;
        }
        this.shopOpen = true;
        console.log('å•†åº—å·²æ‰“å¼€');
    }
    
    closeShop() {
        this.shopOpen = false;
        this.shopSelected = -1;
        console.log('å•†åº—å·²å…³é—­');
    }
    
    buyItem(index) {
        if (index < 0 || index >= this.shopItems.length) return;
        const item = this.shopItems[index];
        if (this.player.gold >= item.price) {
            this.player.gold -= item.price;
            this.items.add(item.id);
            this.particles.burst(this.player.x, this.player.y, '#ff0', 20);
            this.sounds.play('buy');
            this.shopItems.splice(index, 1); // ç§»é™¤å·²è´­ä¹°å•†å“
            console.log(`è´­ä¹°æˆåŠŸ: ${item.name}`);
        } else {
            console.log('é‡‘å¸ä¸è¶³');
        }
    }

    async start() {
        await this.loadSprites();
        this.sounds.init();
        document.getElementById('loading').classList.add('hidden');
        
        document.getElementById('story').style.display = 'block';
        document.getElementById('startGameBtn').addEventListener('click', () => {
            document.getElementById('story').style.display = 'none';
            this.state = 'playing';
            this.loop(0);
        });
    }

    update(dt) {
        if (this.shopOpen) return; // å•†åº—æ‰“å¼€æ—¶æš‚åœæ¸¸æˆ
        
        if (this.transition.active) {
            this.transition.timer -= dt;
            if (this.transition.timer <= 0) {
                this.curRoom = this.transition.target;
                this.curRoom.visited = true;
                // æ ¹æ®è¿›å…¥æ–¹å‘è®¾ç½®ç©å®¶ä½ç½®
                if (this.transition.dir === 'left') this.player.x = 820;
                else if (this.transition.dir === 'right') this.player.x = 80;
                else this.player.x = 450;
                
                if (this.transition.dir === 'up') this.player.y = 520;
                else if (this.transition.dir === 'down') this.player.y = 80;
                else this.player.y = 300;
                
                this.transition.active = false;
            }
            return;
        }

        const stats = this.items.getStats();
        const totemBonuses = this.totems.getAllBonuses();
        stats.dmg = (stats.dmg || 1) * (1 + totemBonuses.dmg);
        stats.maxHp += totemBonuses.maxHp;
        stats.speed *= (1 + totemBonuses.speed);
        stats.crit = Math.min(1, stats.crit + totemBonuses.crit);
        
        const speed = 150 * stats.speed;
        
        // ç©å®¶ç§»åŠ¨
        let dx = 0, dy = 0;
        if (this.keys['w'] || this.keys['W'] || this.keys['ArrowUp']) dy -= 1;
        if (this.keys['s'] || this.keys['S'] || this.keys['ArrowDown']) dy += 1;
        if (this.keys['a'] || this.keys['A'] || this.keys['ArrowLeft']) dx -= 1;
        if (this.keys['d'] || this.keys['D'] || this.keys['ArrowRight']) dx += 1;
        
        if (dx !== 0 || dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            const newX = this.player.x + (dx / len) * speed * dt;
            const newY = this.player.y + (dy / len) * speed * dt;
            
            // ä¿®å¤ç©¿å¢™ï¼šä¸¥æ ¼çš„è¾¹ç•Œæ£€æµ‹
            // å¢™å£åšåº¦40ï¼Œé—¨åŒºåŸŸé™¤å¤–
            const wallThickness = 40;
            const doorWidth = 60;  // ä¸Šä¸‹é—¨å®½åº¦
            const doorHeight = 80; // å·¦å³é—¨é«˜åº¦
            
            // Xè½´è¾¹ç•Œæ£€æµ‹
            let canMoveX = true;
            if (newX < wallThickness) {
                // æ£€æŸ¥æ˜¯å¦åœ¨å·¦é—¨åŒºåŸŸ
                if (!(this.player.y > 260 && this.player.y < 340 && this.curRoom.doors.left && this.curRoom.doors.left.open)) {
                    canMoveX = false;
                }
            }
            if (newX > 900 - wallThickness) {
                // æ£€æŸ¥æ˜¯å¦åœ¨å³é—¨åŒºåŸŸ
                if (!(this.player.y > 260 && this.player.y < 340 && this.curRoom.doors.right && this.curRoom.doors.right.open)) {
                    canMoveX = false;
                }
            }
            
            // Yè½´è¾¹ç•Œæ£€æµ‹
            let canMoveY = true;
            if (newY < wallThickness) {
                // æ£€æŸ¥æ˜¯å¦åœ¨ä¸Šé—¨åŒºåŸŸ
                if (!(this.player.x > 420 && this.player.x < 480 && this.curRoom.doors.up && this.curRoom.doors.up.open)) {
                    canMoveY = false;
                }
            }
            if (newY > 600 - wallThickness) {
                // æ£€æŸ¥æ˜¯å¦åœ¨ä¸‹é—¨åŒºåŸŸ
                if (!(this.player.x > 420 && this.player.x < 480 && this.curRoom.doors.down && this.curRoom.doors.down.open)) {
                    canMoveY = false;
                }
            }
            
            if (canMoveX) this.player.x = newX;
            if (canMoveY) this.player.y = newY;
        }
        
        // æœ€ç»ˆè¾¹ç•Œé™åˆ¶ï¼ˆä¿é™©ï¼‰
        this.player.x = clamp(this.player.x, 20, 880);
        this.player.y = clamp(this.player.y, 20, 580);
        
        // é—¨æ£€æµ‹ - è¿›å…¥æ–°æˆ¿é—´
        if (this.curRoom.cleared) {
            for (const [dir, door] of Object.entries(this.curRoom.doors)) {
                if (!door || !door.open) continue;
                const pos = { 
                    up: [420, 0, 60, 40], down: [420, 560, 60, 40], 
                    left: [0, 260, 40, 80], right: [860, 260, 40, 80] 
                }[dir];
                if (this.player.x > pos[0] && this.player.x < pos[0] + pos[2] &&
                    this.player.y > pos[1] && this.player.y < pos[1] + pos[3]) {
                    this.transition = { active: true, timer: 0.3, dir, target: door.target };
                    break;
                }
            }
        }
        
        // æ•Œäººæ›´æ–°
        for (const e of this.curRoom.enemies) {
            e.update(dt, this.player, this.curRoom);
            const d = dist(e.x, e.y, this.player.x, this.player.y);
            if (d < 25 && e.attackCd <= 0) {
                if (!this.godMode) {
                    this.player.hp -= Math.max(0, e.dmg - stats.armor);
                    this.sounds.play('damage');
                }
                e.attackCd = 0.5;
                if (this.player.hp <= 0) this.state = 'gameover';
            }
        }
        
        // æˆ¿é—´æ¸…ç†æ£€æµ‹
        if (this.curRoom.enemies.length === 0 && !this.curRoom.cleared) {
            this.curRoom.cleared = true;
            for (const door of Object.values(this.curRoom.doors)) {
                if (door) door.open = true;
            }
            this.particles.burst(450, 300, '#4f4', 30);
            this.sounds.play('door');
            
            if (this.curRoom.type === 'boss') {
                this.state = 'victory';
                this.sounds.play('levelup');
                this.spawnTotemPickup();
                return;
            }
            
            this.spawnRoomReward();
        }
        
        // æ­¦å™¨
        let target = null, minD = 9999;
        for (const e of this.curRoom.enemies) {
            const d = dist(e.x, e.y, this.player.x, this.player.y);
            if (d < minD) { minD = d; target = e; }
        }
        
        for (const w of this.weapons) w.update(dt);
        
        const activeW = this.weapons[this.activeWeapon];
        if (activeW && activeW.canFire() && target) {
            this.bullets.push(...activeW.fire(this.player, target, stats));
            this.sounds.play('shoot');
        }
        
        // å­å¼¹æ›´æ–°
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            const b = this.bullets[i];
            
            // ä¿®å¤å­å¼¹ç©¿å¢™ï¼šå­å¼¹ç¢°åˆ°å¢™å£æ¶ˆå¤±
            if (b.x < 40 || b.x > 860 || b.y < 40 || b.y > 560) {
                this.bullets.splice(i, 1);
                continue;
            }
            
            if (b.homing && b.target && this.curRoom.enemies.includes(b.target)) {
                const dx = b.target.x - b.x;
                const dy = b.target.y - b.y;
                const d = Math.sqrt(dx*dx + dy*dy);
                if (d > 0) {
                    const targetAngle = Math.atan2(dy, dx);
                    const currentAngle = Math.atan2(b.vy, b.vx);
                    let angleDiff = targetAngle - currentAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    const turnRate = 3 * dt;
                    const newAngle = currentAngle + Math.max(-turnRate, Math.min(turnRate, angleDiff));
                    const spd = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
                    b.vx = Math.cos(newAngle) * spd;
                    b.vy = Math.sin(newAngle) * spd;
                }
            }
            
            b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
            
            if (b.life <= 0) { this.bullets.splice(i, 1); continue; }
            
            let hit = false;
            for (let j = this.curRoom.enemies.length - 1; j >= 0; j--) {
                const e = this.curRoom.enemies[j];
                if (dist(b.x, b.y, e.x, e.y) < 15 && !b.hits.has(e)) {
                    b.hits.add(e);
                    if (e.takeDamage(b.dmg)) {
                        this.curRoom.enemies.splice(j, 1);
                        this.gems.push({ x: e.x, y: e.y, v: e.exp, life: 30 });
                        this.goldDrops.push({ x: e.x, y: e.y, v: e.gold, life: 30 });
                        this.particles.burst(e.x, e.y, e.color, 8);
                        this.sounds.play('kill');
                    } else {
                        this.sounds.play('hit');
                    }
                    if (b.pierce-- <= 0) { hit = true; break; }
                }
            }
            if (hit) this.bullets.splice(i, 1);
        }
        
        // ç»éªŒå®çŸ³
        for (let i = this.gems.length - 1; i >= 0; i--) {
            const g = this.gems[i];
            const d = dist(g.x, g.y, this.player.x, this.player.y);
            if (d < stats.magnet) {
                g.x += (this.player.x - g.x) * 5 * dt;
                g.y += (this.player.y - g.y) * 5 * dt;
            }
            if (d < 20) {
                this.player.exp += g.v;
                this.gems.splice(i, 1);
                if (this.player.exp >= this.player.lv * 100) {
                    this.player.exp -= this.player.lv * 100;
                    this.player.lv++;
                    this.player.maxHp++;
                    this.player.hp++;
                    this.particles.burst(this.player.x, this.player.y, '#ff0', 20);
                    this.sounds.play('levelup');
                }
            }
        }
        
        // é‡‘å¸æ‰è½
        for (let i = this.goldDrops.length - 1; i >= 0; i--) {
            const g = this.goldDrops[i];
            const d = dist(g.x, g.y, this.player.x, this.player.y);
            if (d < stats.magnet) {
                g.x += (this.player.x - g.x) * 5 * dt;
                g.y += (this.player.y - g.y) * 5 * dt;
            }
            if (d < 20) {
                this.player.gold += g.v;
                this.goldDrops.splice(i, 1);
                this.particles.burst(this.player.x, this.player.y, '#fc0', 5);
            }
        }
        
        // æ‹¾å–é“å…·
        for (let i = this.curRoom.items.length - 1; i >= 0; i--) {
            const item = this.curRoom.items[i];
            const d = dist(item.x, item.y, this.player.x, this.player.y);
            
            if (d < 30) {
                if (item.type === 'weapon') {
                    const existingIdx = this.weapons.findIndex(w => w.cfg.key === item.weaponKey);
                    if (existingIdx >= 0) {
                        const leveledUp = this.weapons[existingIdx].addXp(100);
                        if (leveledUp) this.particles.burst(item.x, item.y, '#f0f', 20);
                    } else if (this.weapons.length < 5) {
                        this.weapons.push(new Weapon(item.weaponKey, 1));
                    }
                } else if (item.type === 'totem') {
                    if (this.totems.collect(item.totemId)) {
                        this.particles.burst(item.x, item.y, '#ff0', 30);
                        const totem = TOTEMS[item.totemId];
                        if (totem.effect === 'maxHp') {
                            this.player.maxHp += totem.value;
                            this.player.hp += totem.value;
                        }
                    }
                } else {
                    this.items.add(item.id);
                }
                this.curRoom.items.splice(i, 1);
                this.particles.burst(item.x, item.y, '#ff0', 10);
                this.sounds.play('item');
            }
        }
        
        this.particles.update(dt);
    }

    draw() {
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, 900, 600);
        
        this.curRoom.draw(this.ctx);
        
        // é‡‘å¸
        for (const g of this.goldDrops) {
            this.ctx.fillStyle = '#fc0';
            this.ctx.font = '16px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('ğŸ’°', g.x, g.y);
        }
        
        // ç»éªŒå®çŸ³
        for (const g of this.gems) {
            this.ctx.fillStyle = '#48f';
            this.ctx.beginPath();
            this.ctx.moveTo(g.x, g.y - 5);
            this.ctx.lineTo(g.x + 4, g.y);
            this.ctx.lineTo(g.x, g.y + 5);
            this.ctx.lineTo(g.x - 4, g.y);
            this.ctx.fill();
        }
        
        // å­å¼¹
        for (const b of this.bullets) {
            this.ctx.fillStyle = b.color;
            this.ctx.beginPath();
            this.ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // æˆ¿é—´é“å…·
        for (const item of this.curRoom.items) {
            this.ctx.fillStyle = '#ff0';
            this.ctx.font = '20px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(item.icon, item.x, item.y + 5);
            
            this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(item.x, item.y, 15 + Math.sin(Date.now() / 200) * 3, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        
        // æ•Œäºº
        for (const e of this.curRoom.enemies) {
            e.draw(this.ctx, this.sprites);
        }
        
        // ç›²çœ¼NPCï¼ˆå•†åº—æˆ¿ï¼‰
        if (this.curRoom.type === 'shop' && this.curRoom.npc) {
            const d = dist(this.player.x, this.player.y, this.curRoom.npc.x, this.curRoom.npc.y);
            this.curRoom.npc.draw(this.ctx, d < 80 && !this.shopOpen);
        }
        
        // ç©å®¶
        const playerSprite = this.sprites.get('player');
        if (playerSprite) {
            this.ctx.drawImage(playerSprite, this.player.x - 16, this.player.y - 16, 32, 32);
        } else {
            this.ctx.font = '24px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('ğŸ®', this.player.x, this.player.y + 8);
        }
        
        this.particles.draw(this.ctx);
        
        if (this.transition.active) {
            const alpha = Math.sin(this.transition.timer / 0.3 * Math.PI);
            this.ctx.fillStyle = `rgba(0,0,0,${alpha})`;
            this.ctx.fillRect(0, 0, 900, 600);
        }
        
        // å•†åº—UI
        if (this.shopOpen && this.curRoom.npc) {
            this.curRoom.npc.drawShop(this.ctx, this.shopItems, this.player.gold, this.shopSelected);
        }
        
        this.drawUI();
    }

    drawUI() {
        const ctx = this.ctx;
        const pad = 20;
        
        // çŠ¶æ€é¢æ¿
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(pad, pad, 180, 110);
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('â¤ï¸'.repeat(Math.max(0, Math.ceil(this.player.hp))), pad + 10, pad + 35);
        
        ctx.fillStyle = '#48f';
        ctx.fillText(`Lv.${this.player.lv} EXP:${Math.floor(this.player.exp)}/${this.player.lv*100}`, pad + 10, pad + 60);
        
        ctx.fillStyle = '#fc0';
        ctx.fillText(`ğŸ’° ${this.player.gold}`, pad + 10, pad + 85);
        
        // å±‚æ•°æ˜¾ç¤º
        ctx.fillStyle = '#aaa';
        ctx.fillText(`ç¬¬ ${this.currentFloor}/${this.maxFloors} å±‚`, pad + 10, pad + 105);
        
        // æ— æ•Œæ¨¡å¼
        if (this.godMode) {
            ctx.fillStyle = '#f0f';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('ğŸ‘‘ GOD MODE', pad + 10, pad + 125);
        }
        
        // æˆ¿é—´ä¿¡æ¯
        ctx.textAlign = 'right';
        ctx.fillStyle = '#fff';
        const names = { start: 'èµ·ç‚¹', normal: 'æˆ˜æ–—', boss: 'BOSS', treasure: 'å®ç®±', shop: 'å•†åº—', hidden: 'éšè—' };
        ctx.fillText(`${names[this.curRoom.type]}æˆ¿é—´`, 880, pad + 35);
        ctx.fillText(`æ•Œäºº:${this.curRoom.enemies.length}`, 880, pad + 60);
        
        if (!this.curRoom.cleared) {
            ctx.fillStyle = '#f44';
            ctx.fillText('ğŸ”’ é”å®š', 880, pad + 85);
        } else {
            ctx.fillStyle = '#4f4';
            ctx.fillText('âœ“ å·²æ¸…ç†', 880, pad + 85);
        }
        
        // å°åœ°å›¾
        const mx = 750, my = 140;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(mx, my, 130, 130);
        
        for (const [, r] of this.allRooms) {
            if (!r.visited) continue;
            const rx = mx + 10 + (r.gx + 5) * 10;
            const ry = my + 10 + (r.gy + 5) * 10;
            ctx.fillStyle = r === this.curRoom ? '#ff0' : { normal: '#666', boss: '#f00', treasure: '#0f0', start: '#66f', shop: '#48f', hidden: '#f0f' }[r.type];
            ctx.fillRect(rx, ry, 8, 8);
        }
        
        // æ­¦å™¨æ 
        const by = 530;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(pad, by, 300, 50);
        
        let wx = pad + 10;
        for (let i = 0; i < this.weapons.length; i++) {
            const w = this.weapons[i];
            ctx.fillStyle = i === this.activeWeapon ? '#444' : '#333';
            ctx.fillRect(wx, by + 5, 40, 40);
            
            ctx.fillStyle = w.getLevelColor();
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(w.cfg.icon, wx + 20, by + 32);
            
            if (w.level > 1) {
                ctx.fillStyle = '#ff0';
                ctx.font = '10px Arial';
                ctx.fillText('+' + (w.level - 1), wx + 35, by + 15);
            }
            
            wx += 50;
        }
        
        // å›¾è…¾æ”¶é›†
        const totemCount = this.totems.getCount();
        if (totemCount > 0) {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(320, by, 120, 50);
            ctx.fillStyle = '#fc0';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`å›¾è…¾: ${totemCount}/7`, 380, by + 20);
            ctx.font = '12px Arial';
            ctx.fillStyle = '#aaa';
            ctx.fillText('æ°¸ä¹…åŠ æˆ', 380, by + 40);
        }
        
        // æ¸¸æˆç»“æŸ
        if (this.state === 'gameover') {
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, 900, 600);
            ctx.fillStyle = '#f44';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('æ¸¸æˆç»“æŸ', 450, 280);
            ctx.font = '24px Arial';
            ctx.fillStyle = '#fff';
            ctx.fillText(`åˆ°è¾¾å±‚æ•°: ${this.currentFloor} | é‡‘å¸: ${this.player.gold}`, 450, 340);
            ctx.fillText('æŒ‰ F5 é‡æ–°å¼€å§‹', 450, 380);
        }
        
        // èƒœåˆ©
        if (this.state === 'victory') {
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, 900, 600);
            ctx.fillStyle = '#4f4';
            ctx.font = 'bold 56px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸ‰ èƒœåˆ©! ğŸ‰', 450, 260);
            ctx.font = '24px Arial';
            ctx.fillStyle = '#fff';
            ctx.fillText('ä½ å‡»è´¥äº†æ¯ä½“ï¼Œæ‹¯æ•‘äº†å†œåœº!', 450, 320);
            ctx.fillText(`æœ€ç»ˆç­‰çº§: ${this.player.lv} | é‡‘å¸: ${this.player.gold}`, 450, 360);
            ctx.fillText('æŒ‰ F5 å†æ¬¡æŒ‘æˆ˜', 450, 420);
        }
    }
    
    spawnRoomReward() {
        const roll = Math.random();
        if (this.curRoom.type === 'boss') {
            this.spawnWeaponPickup();
        } else if (this.curRoom.type === 'treasure') {
            this.spawnItemPickup();
        } else if (roll < 0.3) {
            this.spawnItemPickup();
        } else if (roll < 0.5) {
            this.spawnWeaponPickup();
        }
    }
    
    spawnItemPickup() {
        const itemId = randInt(1, 16);
        const item = ITEMS[itemId];
        if (!item) return;
        this.curRoom.items.push({ x: 450, y: 300, id: itemId, icon: item.icon, name: item.name });
    }
    
    spawnWeaponPickup() {
        const wKeys = Object.keys(WEAPONS);
        const randKey = wKeys[Math.floor(Math.random() * wKeys.length)];
        this.curRoom.items.push({
            x: 450, y: 300,
            type: 'weapon', weaponKey: randKey,
            icon: WEAPONS[randKey].icon, name: WEAPONS[randKey].name
        });
    }
    
    spawnTotemPickup() {
        const totemId = randInt(1, 8);
        const totem = TOTEMS[totemId];
        if (!totem) return;
        this.curRoom.items.push({
            x: 450, y: 300,
            type: 'totem', totemId: totemId,
            icon: totem.icon, name: totem.name
        });
    }

    loop(t) {
        const dt = Math.min((t - (this.lastT || t)) / 1000, 0.1);
        this.lastT = t;
        
        if (this.state === 'playing' || this.transition.active) {
            this.update(dt);
        }
        this.draw();
        
        this.rafId = requestAnimationFrame(t => this.loop(t));
    }
}

// å¯åŠ¨
window.onload = () => {
    const game = new Game();
    setTimeout(() => game.start(), 500);
};
</script>
</body>
</html>
